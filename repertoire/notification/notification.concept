@version(1)
concept Notification [N] {
  purpose {
    Deliver user-facing alerts across multiple channels with subscription
    management, templating, and inbox tracking.
  }

  state {
    channels: set String;
    templates: N -> String;
    subscriptions: N -> String;
    inbox: N -> String;
    deliveryLog: N -> String;
    read: N -> Bool
  }

  actions {
    action registerChannel(name: String, config: String) {
      -> ok() {
        Delivery channel registered with the given transport configuration
        (email, SMS, push, in-app, webhook, etc.).
      }
      -> exists(message: String) {
        A channel with this name is already registered.
      }
    }

    action defineTemplate(notification: N, template: String) {
      -> ok() {
        Notification template defined with placeholders for dynamic data
        interpolation during delivery.
      }
      -> exists(message: String) {
        A template already exists for this notification type.
      }
    }

    action subscribe(user: String, eventType: String, channel: String) {
      -> ok() {
        User subscribed to receive notifications for the given event
        type through the specified channel.
      }
      -> exists(message: String) {
        This user-event-channel subscription already exists.
      }
    }

    action unsubscribe(user: String, eventType: String, channel: String) {
      -> ok() {
        User unsubscribed from the event type on the given channel.
        Future events of this type will not be delivered on this channel.
      }
      -> notfound(message: String) {
        No matching subscription exists for this user-event-channel combination.
      }
    }

    action notify(notification: N, user: String, template: String, data: String) {
      -> ok() {
        Notification rendered from the template with the provided data
        and delivered to the user's inbox across subscribed channels.
      }
      -> error(message: String) {
        Delivery failed due to a channel transport error or missing template.
      }
    }

    action markRead(notification: N) {
      -> ok() {
        Notification marked as read, removing it from the user's unread count.
      }
      -> notfound(message: String) {
        No notification exists with this identifier.
      }
    }

    action getUnread(user: String) {
      -> ok(notifications: String) {
        Returns all unread notifications for the user, ordered by delivery time.
      }
    }
  }

  invariant {
    after registerChannel(name: c, config: cfg) -> ok()
    then defineTemplate(notification: n, template: t) -> ok()
    and subscribe(user: u, eventType: e, channel: c) -> ok()
    and notify(notification: n, user: u, template: t, data: d) -> ok()
    and  getUnread(user: u) -> ok(notifications: n)
  }

  invariant {
    after notify(notification: n, user: u, template: t, data: d) -> ok()
    then  markRead(notification: n) -> ok()
    and   getUnread(user: u) -> ok(notifications: _)
    // n is no longer present in the unread notifications
  }
}
