@version(1)
widget combobox {

  purpose {
    Searchable single-choice selector combining a text input with a
    dropdown listbox. As the user types, options are filtered in real time.
    Supports custom value entry when allowCustom is enabled.
  }

  anatomy {
    root: container            { Outermost wrapper; groups label, input, and dropdown }
    label: text                { Visible label describing the field purpose }
    inputWrapper: container    { Container for input and trigger controls }
    input: action              { Editable text input for search/filter }
    trigger: action            { Toggle button to open/close the dropdown }
    clearButton: action        { Optional button to clear the current selection }
    positioner: container      { Floating positioning wrapper for the dropdown }
    content: container         { Scrollable list container holding filtered options }
    item: action               { Individual selectable option in the filtered list }
    itemLabel: text            { Label text for an individual option }
    empty: text                { Message displayed when no options match the filter }
  }

  slots {
    clearButton { accepts: action; optional: true }
  }

  states {
    openClose {
      closed [initial] {
        on OPEN -> open;
        on INPUT -> open;
      }
      open {
        on CLOSE -> closed;
        on SELECT -> closed;
        on BLUR -> closed;
        entry [positionContent, focusInput, beginFilter];
        exit [endFilter];
      }
    }

    filtering {
      idle [initial] {
        on BEGIN_FILTER -> filtering;
      }
      filtering {
        on END_FILTER -> idle;
        on INPUT -> filtering;
      }
    }
  }

  accessibility {
    role: combobox;
    keyboard {
      ArrowDown -> OPEN_OR_NEXT;
      ArrowUp   -> PREV;
      Enter     -> SELECT;
      Escape    -> CLOSE;
      Home      -> FIRST;
      End       -> LAST;
    }
    focus {
      input: focusable;
    }
    aria {
      input -> {
        role: "combobox";
        aria-label: ?label;
        aria-expanded: if state.openClose == "open" then "true" else "false";
        aria-haspopup: "listbox";
        aria-controls: content;
        aria-activedescendant: if state.openClose == "open" then activeItem else none;
        aria-autocomplete: "list";
        aria-disabled: if ?disabled then "true" else "false";
        aria-required: if ?required then "true" else "false";
      };
      content -> {
        role: "listbox";
        aria-label: ?label;
      };
      item -> {
        role: "option";
        aria-selected: if item.value == ?value then "true" else "false";
        aria-disabled: if item.disabled then "true" else "false";
        aria-label: item.label;
      };
      empty -> {
        role: "status";
        aria-live: "polite";
      };
    }
  }

  props {
    value: option String
    inputValue: String = ""
    options: list { label: String, value: String }
    placeholder: String = "Search..."
    allowCustom: Bool = false
    label: String
    disabled: Bool = false
    required: Bool = false
    name: option String
  }

  connect {
    root -> {
      data-state: if state.openClose == "open" then "open" else "closed";
      data-disabled: if ?disabled then "true" else "false";
    }
    label -> {
      text: ?label;
      for: input;
      id: comboLabel;
    }
    inputWrapper -> {
      data-state: if state.openClose == "open" then "open" else "closed";
      data-focus: if state.openClose == "open" then "true" else "false";
    }
    input -> {
      value: ?inputValue;
      placeholder: ?placeholder;
      disabled: ?disabled;
      required: ?required;
      name: ?name;
      onInput: send(INPUT);
      onFocus: send(OPEN);
      onBlur: send(BLUR);
      onKeyDown-ArrowDown: send(OPEN_OR_NEXT);
      onKeyDown-ArrowUp: send(PREV);
      onKeyDown-Enter: send(SELECT);
      onKeyDown-Escape: send(CLOSE);
      onKeyDown-Home: send(FIRST);
      onKeyDown-End: send(LAST);
      aria-labelledby: comboLabel;
      autocomplete: "off";
    }
    trigger -> {
      onClick: send(TOGGLE);
      disabled: ?disabled;
      tabIndex: -1;
      aria-label: "Toggle options";
      aria-hidden: "true";
      data-state: if state.openClose == "open" then "open" else "closed";
    }
    clearButton -> {
      onClick: send(CLEAR);
      visible: if ?value then true else false;
      tabIndex: -1;
      aria-label: "Clear selection";
    }
    positioner -> {
      visible: if state.openClose == "open" then true else false;
    }
    content -> {
      role: "listbox";
      aria-labelledby: comboLabel;
    }
    item -> {
      data-state: if item.value == ?value then "selected" else "unselected";
      data-highlighted: if item.highlighted then "true" else "false";
      onClick: send(SELECT, { value: item.value });
      onPointerEnter: send(HIGHLIGHT, { value: item.value });
      role: "option";
    }
    itemLabel -> {
      text: item.label;
      data-match: highlightMatch(item.label, ?inputValue);
    }
    empty -> {
      text: if ?allowCustom then concat("Create \"", ?inputValue, "\"") else "No results found";
      visible: if filteredCount(?options, ?inputValue) == 0 then true else false;
      onClick: if ?allowCustom then send(CREATE, { value: ?inputValue }) else noop;
    }
  }

  affordance {
    serves: single-choice;
    specificity: 8;
    when { minOptions: 20 }
  }

  affordance {
    serves: single-pick;
    specificity: 10;
  }

  compose {
    input: widget("text-input", { value: ?inputValue, placeholder: ?placeholder })
    label: widget("label", { text: ?label, for: input })
    positioner: widget("portal", {})
  }

  invariant {
    ?value and not ?allowCustom => exists(?options, o -> o.value == ?value);
  }
}
