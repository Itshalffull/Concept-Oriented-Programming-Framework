// Authentication — handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe, flow } from 'fp-ts/function';

import type {
  AuthenticationStorage,
  AuthenticationRegisterInput,
  AuthenticationRegisterOutput,
  AuthenticationLoginInput,
  AuthenticationLoginOutput,
  AuthenticationLogoutInput,
  AuthenticationLogoutOutput,
  AuthenticationResetPasswordInput,
  AuthenticationResetPasswordOutput,
} from './types.js';

import {
  registerOk,
  registerAlreadyExists,
  loginOk,
  loginInvalidCredentials,
  logoutOk,
  logoutNotfound,
  resetPasswordOk,
  resetPasswordNotfound,
} from './types.js';

export interface AuthenticationError {
  readonly code: string;
  readonly message: string;
}

// --- Pure helper: wrap storage calls in TaskEither ---

const storageGet = (
  storage: AuthenticationStorage,
  relation: string,
  key: string,
): TE.TaskEither<AuthenticationError, O.Option<Record<string, unknown>>> =>
  TE.tryCatch(
    async () => {
      const result = await storage.get(relation, key);
      return result === null ? O.none : O.some(result);
    },
    (error): AuthenticationError => ({
      code: 'STORAGE_ERROR',
      message: error instanceof Error ? error.message : String(error),
    }),
  );

const storagePut = (
  storage: AuthenticationStorage,
  relation: string,
  key: string,
  value: Record<string, unknown>,
): TE.TaskEither<AuthenticationError, void> =>
  TE.tryCatch(
    () => storage.put(relation, key, value),
    (error): AuthenticationError => ({
      code: 'STORAGE_ERROR',
      message: error instanceof Error ? error.message : String(error),
    }),
  );

// --- Handler type (record of pure functions) ---

export interface AuthenticationHandler {
  readonly register: (
    input: AuthenticationRegisterInput,
    storage: AuthenticationStorage,
  ) => TE.TaskEither<AuthenticationError, AuthenticationRegisterOutput>;
  readonly login: (
    input: AuthenticationLoginInput,
    storage: AuthenticationStorage,
  ) => TE.TaskEither<AuthenticationError, AuthenticationLoginOutput>;
  readonly logout: (
    input: AuthenticationLogoutInput,
    storage: AuthenticationStorage,
  ) => TE.TaskEither<AuthenticationError, AuthenticationLogoutOutput>;
  readonly resetPassword: (
    input: AuthenticationResetPasswordInput,
    storage: AuthenticationStorage,
  ) => TE.TaskEither<AuthenticationError, AuthenticationResetPasswordOutput>;
}

// --- Implementation ---

export const authenticationHandler: AuthenticationHandler = {
  register: (input, storage) =>
    pipe(
      storageGet(storage, 'account', input.userId),
      TE.chain(
        O.fold(
          // Account does not exist — create it
          () =>
            pipe(
              storagePut(storage, 'account', input.userId, {
                userId: input.userId,
                credentials: input.credentials,
                createdAt: new Date().toISOString(),
                active: true,
              }),
              TE.map(() => registerOk(input.userId)),
            ),
          // Account already exists
          () => TE.right(registerAlreadyExists(input.userId)),
        ),
      ),
    ),

  login: (input, storage) =>
    pipe(
      storageGet(storage, 'account', input.userId),
      TE.chain(
        O.fold(
          () => TE.right(loginInvalidCredentials('invalid user or credentials')),
          (account) => {
            const storedCredentials = (account.credentials as string) ?? '';
            if (storedCredentials !== input.credentials) {
              return TE.right(loginInvalidCredentials('invalid user or credentials'));
            }
            const token = `tok_${Date.now()}_${Math.random().toString(36).slice(2)}`;
            return pipe(
              storagePut(storage, 'account', input.userId, {
                ...account,
                lastLogin: new Date().toISOString(),
                token,
              }),
              TE.map(() => loginOk(input.userId, token)),
            );
          },
        ),
      ),
    ),

  logout: (input, storage) =>
    pipe(
      storageGet(storage, 'account', input.userId),
      TE.chain(
        O.fold(
          () => TE.right(logoutNotfound(`account '${input.userId}' not found`)),
          (account) =>
            pipe(
              storagePut(storage, 'account', input.userId, {
                ...account,
                token: null,
              }),
              TE.map(() => logoutOk(input.userId)),
            ),
        ),
      ),
    ),

  resetPassword: (input, storage) =>
    pipe(
      storageGet(storage, 'account', input.userId),
      TE.chain(
        O.fold(
          () => TE.right(resetPasswordNotfound(`account '${input.userId}' not found`)),
          (account) => {
            const resetToken = `reset_${Date.now()}_${Math.random().toString(36).slice(2)}`;
            return pipe(
              storagePut(storage, 'account', input.userId, {
                ...account,
                resetToken,
                resetRequestedAt: new Date().toISOString(),
              }),
              TE.map(() => resetPasswordOk(input.userId, resetToken)),
            );
          },
        ),
      ),
    ),
};
