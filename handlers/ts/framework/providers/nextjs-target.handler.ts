// ============================================================
// NextjsTarget Provider — Clef Bind
//
// Generates Next.js App Router route files from ConceptManifest
// data. Each concept produces route.ts files using fp-ts
// TaskEither for typed action dispatch, plus Server Actions
// for mutations. All generated code is purely functional.
// ============================================================

import type {
  ConceptHandler,
  ConceptStorage,
  ConceptManifest,
  ActionSchema,
} from '../../../../runtime/types.js';

import {
  inferHttpRoute,
  toKebabCase,
  toPascalCase,
  generateFileHeader,
  getActionOverrides,
  getRestBasePath,
  getHierarchicalTrait,
  inferHierarchicalRoutes,
  getEnrichmentContent,
  getManifestEnrichment,
  typeToNextjs,
} from './codegen-utils.js';

import type { HttpRoute, HierarchicalConfig } from './codegen-utils.js';

interface GeneratedFile {
  path: string;
  content: string;
}

interface RouteSummary {
  action: string;
  method: string;
  path: string;
  statusCodes: { ok: number; notFound?: number; error?: number };
}

// --- Next.js Route Code Generation ---

function toNextjsPath(routePath: string): string {
  return routePath.replace(/\{(\w+)\}/g, '[\\$1]');
}

function generateRouteHandler(
  action: ActionSchema,
  route: HttpRoute,
  conceptName: string,
): string {
  const lines: string[] = [];
  const method = route.method;
  const hasId = route.path.includes('{id}');
  const hasBody = method === 'POST' || method === 'PUT';

  lines.push(`    case '${action.name}': {`);

  if (hasId) {
    lines.push(`      const id = params.id;`);
  }

  if (hasBody) {
    lines.push(`      const body = await request.json();`);
  }

  // Build input object
  const inputFields: string[] = [];
  for (const param of action.params) {
    if (param.name === 'id' && hasId) {
      inputFields.push(`${param.name}: id`);
    } else if (hasBody) {
      inputFields.push(`${param.name}: body.${param.name}`);
    } else {
      inputFields.push(`${param.name}: searchParams.get('${param.name}') ?? ''`);
    }
  }

  lines.push(`      const result = await pipe(`);
  lines.push(`        handler.${action.name}({ ${inputFields.join(', ')} }, storage),`);
  lines.push(`        TE.fold(`);
  lines.push(`          (error) => T.of(NextResponse.json({ errors: [error] }, { status: 422 })),`);
  lines.push(`          (output) => {`);

  // Map variants to status codes
  if (action.variants.some(v => v.tag === 'notfound' || v.tag === 'not_found')) {
    lines.push(`            if (output.variant === 'notfound' || output.variant === 'not_found') {`);
    lines.push(`              return T.of(NextResponse.json(output, { status: 404 }));`);
    lines.push(`            }`);
  }

  const okStatus = route.statusCodes.ok;
  lines.push(`            return T.of(NextResponse.json(output, { status: ${okStatus} }));`);
  lines.push(`          },`);
  lines.push(`        ),`);
  lines.push(`      )();`);
  lines.push(`      return result;`);
  lines.push(`    }`);

  return lines.join('\n');
}

function generateRouteFile(
  manifest: ConceptManifest,
  basePath: string,
  overrides: Record<string, unknown>,
): string {
  const conceptName = manifest.name;
  const kebabName = toKebabCase(conceptName);

  const lines: string[] = [
    `// ${conceptName} — Next.js App Router Route Handler`,
    `// Generated by NextjsTarget. Do not edit manually.`,
    `// Uses fp-ts TaskEither for purely functional action dispatch.`,
    ``,
    `import { NextRequest, NextResponse } from 'next/server';`,
    `import * as TE from 'fp-ts/TaskEither';`,
    `import * as T from 'fp-ts/Task';`,
    `import * as E from 'fp-ts/Either';`,
    `import { pipe } from 'fp-ts/function';`,
    ``,
    `import type { ${conceptName}Handler } from './${kebabName}/handler.js';`,
    `import type { ${conceptName}Storage } from './${kebabName}/types.js';`,
    ``,
  ];

  // Collect routes
  const routes: RouteSummary[] = [];
  for (const action of manifest.actions) {
    const route = inferHttpRoute(action.name, basePath);
    routes.push({
      action: action.name,
      method: route.method,
      path: route.path,
      statusCodes: route.statusCodes,
    });
  }

  // Group by method
  const getActions = manifest.actions.filter(a => {
    const r = inferHttpRoute(a.name, basePath);
    return r.method === 'GET';
  });
  const postActions = manifest.actions.filter(a => {
    const r = inferHttpRoute(a.name, basePath);
    return r.method === 'POST';
  });
  const putActions = manifest.actions.filter(a => {
    const r = inferHttpRoute(a.name, basePath);
    return r.method === 'PUT';
  });
  const deleteActions = manifest.actions.filter(a => {
    const r = inferHttpRoute(a.name, basePath);
    return r.method === 'DELETE';
  });

  // Create route factory
  lines.push(`export const create${conceptName}Route = (`);
  lines.push(`  handler: ${conceptName}Handler,`);
  lines.push(`  storage: ${conceptName}Storage,`);
  lines.push(`) => {`);

  // Dispatch helper
  lines.push(`  const dispatch = async (`);
  lines.push(`    action: string,`);
  lines.push(`    request: NextRequest,`);
  lines.push(`    params: Record<string, string>,`);
  lines.push(`    searchParams: URLSearchParams,`);
  lines.push(`  ): Promise<NextResponse> => {`);
  lines.push(`    switch (action) {`);

  for (const action of manifest.actions) {
    const route = inferHttpRoute(action.name, basePath);
    lines.push(generateRouteHandler(action, route, conceptName));
  }

  lines.push(`      default:`);
  lines.push(`        return NextResponse.json(`);
  lines.push(`          { errors: [{ code: 'UNKNOWN_ACTION', message: \`Unknown action: \${action}\` }] },`);
  lines.push(`          { status: 404 },`);
  lines.push(`        );`);
  lines.push(`    }`);
  lines.push(`  };`);
  lines.push('');

  // Export HTTP method handlers
  if (getActions.length > 0) {
    lines.push(`  const GET = async (request: NextRequest, { params }: { params: Record<string, string> }): Promise<NextResponse> => {`);
    lines.push(`    const searchParams = new URL(request.url).searchParams;`);
    lines.push(`    const action = searchParams.get('action') ?? '${getActions[0].name}';`);
    lines.push(`    return dispatch(action, request, params, searchParams);`);
    lines.push(`  };`);
    lines.push('');
  }

  if (postActions.length > 0) {
    lines.push(`  const POST = async (request: NextRequest, { params }: { params: Record<string, string> }): Promise<NextResponse> => {`);
    lines.push(`    const searchParams = new URL(request.url).searchParams;`);
    lines.push(`    const body = await request.clone().json().catch(() => ({}));`);
    lines.push(`    const action = body.action ?? searchParams.get('action') ?? '${postActions[0].name}';`);
    lines.push(`    return dispatch(action, request, params, searchParams);`);
    lines.push(`  };`);
    lines.push('');
  }

  if (putActions.length > 0) {
    lines.push(`  const PUT = async (request: NextRequest, { params }: { params: Record<string, string> }): Promise<NextResponse> => {`);
    lines.push(`    const searchParams = new URL(request.url).searchParams;`);
    lines.push(`    const action = searchParams.get('action') ?? '${putActions[0].name}';`);
    lines.push(`    return dispatch(action, request, params, searchParams);`);
    lines.push(`  };`);
    lines.push('');
  }

  if (deleteActions.length > 0) {
    lines.push(`  const DELETE = async (request: NextRequest, { params }: { params: Record<string, string> }): Promise<NextResponse> => {`);
    lines.push(`    const searchParams = new URL(request.url).searchParams;`);
    lines.push(`    const action = searchParams.get('action') ?? '${deleteActions[0].name}';`);
    lines.push(`    return dispatch(action, request, params, searchParams);`);
    lines.push(`  };`);
    lines.push('');
  }

  const handlers = ['GET', 'POST', 'PUT', 'DELETE'].filter(m => {
    switch (m) {
      case 'GET': return getActions.length > 0;
      case 'POST': return postActions.length > 0;
      case 'PUT': return putActions.length > 0;
      case 'DELETE': return deleteActions.length > 0;
      default: return false;
    }
  });

  lines.push(`  return { ${handlers.join(', ')} };`);
  lines.push(`};`);

  return lines.join('\n');
}

// --- Server Action Generation ---

function generateServerActionsFile(manifest: ConceptManifest): string {
  const conceptName = manifest.name;
  const kebabName = toKebabCase(conceptName);

  const lines: string[] = [
    `'use server';`,
    ``,
    `// ${conceptName} — Server Actions`,
    `// Generated by NextjsTarget. Do not edit manually.`,
    `// Uses fp-ts TaskEither for purely functional mutations.`,
    ``,
    `import * as TE from 'fp-ts/TaskEither';`,
    `import * as E from 'fp-ts/Either';`,
    `import { pipe } from 'fp-ts/function';`,
    ``,
  ];

  // Import types
  const imports: string[] = [];
  for (const action of manifest.actions) {
    imports.push(`${conceptName}${action.name.charAt(0).toUpperCase() + action.name.slice(1)}Input`);
    imports.push(`${conceptName}${action.name.charAt(0).toUpperCase() + action.name.slice(1)}Output`);
  }
  lines.push(`import type { ${imports.join(', ')} } from './${kebabName}/types.js';`);
  lines.push('');

  // Generate one server action per mutation action
  for (const action of manifest.actions) {
    const route = inferHttpRoute(action.name, '');
    if (route.method === 'GET') continue; // Skip read-only actions

    const pascalAction = action.name.charAt(0).toUpperCase() + action.name.slice(1);
    const inputType = `${conceptName}${pascalAction}Input`;
    const outputType = `${conceptName}${pascalAction}Output`;

    lines.push(`export const ${action.name}${conceptName} = async (`);
    lines.push(`  input: ${inputType},`);
    lines.push(`): Promise<${outputType}> => {`);
    lines.push(`  // TODO: Wire to concept handler and storage`);
    lines.push(`  throw new Error('Server Action not wired: ${action.name}');`);
    lines.push(`};`);
    lines.push('');
  }

  return lines.join('\n');
}

// --- Handler Export ---

export const nextjsTargetHandler: ConceptHandler = {
  async register(_input, _storage) {
    return {
      variant: 'ok',
      name: 'NextjsTarget',
      inputKind: 'InterfaceProjection',
      outputKind: 'NextjsRouteFiles',
      capabilities: JSON.stringify(['server-components', 'server-actions', 'app-router', 'fp-ts']),
      targetKey: 'nextjs',
      providerType: 'target',
    };
  },

  async generate(input, storage) {
    const projection = typeof input.projection === 'string'
      ? JSON.parse(input.projection)
      : input.projection;

    const config = typeof input.config === 'string'
      ? JSON.parse(input.config || '{}')
      : (input.config || {});

    const manifestStr = projection?.conceptManifest;
    let manifest: ConceptManifest;
    try {
      manifest = typeof manifestStr === 'string' ? JSON.parse(manifestStr) : manifestStr;
    } catch {
      return { variant: 'error', message: 'Failed to parse conceptManifest from projection' };
    }

    if (!manifest?.name) {
      return { variant: 'error', message: 'Projection missing conceptManifest with name' };
    }

    const overrides = typeof input.overrides === 'string'
      ? JSON.parse(input.overrides || '{}')
      : (input.overrides || {});

    const allProjections = typeof input.allProjections === 'string'
      ? JSON.parse(input.allProjections || '[]')
      : (input.allProjections || []);

    const kebabName = toKebabCase(manifest.name);
    const basePath = (config as any).basePath || `/api/${kebabName}`;

    const files: GeneratedFile[] = [];

    // Route handler
    files.push({
      path: `${kebabName}/route.ts`,
      content: generateRouteFile(manifest, basePath, overrides as Record<string, unknown>),
    });

    // Server Actions
    files.push({
      path: `${kebabName}/actions.ts`,
      content: generateServerActionsFile(manifest),
    });

    return {
      variant: 'ok',
      routes: manifest.actions.map(a => {
        const r = inferHttpRoute(a.name, basePath);
        return `${r.method} ${r.path}`;
      }),
      files: files.map(f => ({ path: f.path, content: f.content })),
    };
  },

  async validate(input, storage) {
    return { variant: 'ok', route: input.route };
  },

  async listRoutes(input, storage) {
    return { variant: 'ok', routes: [], methods: [] };
  },
};
