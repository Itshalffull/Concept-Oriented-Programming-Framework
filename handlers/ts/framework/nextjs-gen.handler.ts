// ============================================================
// NextjsGen Concept Implementation
//
// Generates Next.js App Router code from a ConceptManifest using
// fp-ts for purely functional concept implementations. All output
// is purely functional: no classes, no mutation, TaskEither-based
// error handling, pipe-based composition.
//
// Type mapping table:
//   String   → string        Int      → number
//   Float    → number        Bool     → boolean
//   Bytes    → Buffer        DateTime → Date
//   ID       → string        option T → O.Option<T>
//   set T    → ReadonlySet<T>  list T → readonly T[]
//   A -> B   → ReadonlyMap<A, B>  params → string (opaque)
//
// Generated files per concept:
//   - types.ts         (readonly interfaces, branded types, tagged unions)
//   - handler.ts       (pure functions returning TE.TaskEither)
//   - route.ts         (Next.js App Router Route Handler adapter)
//   - conformance.test.ts  (vitest tests from invariants)
// ============================================================

import type {
  ConceptHandler,
  ConceptStorage,
  ConceptManifest,
  ResolvedType,
  ActionSchema,
  VariantSchema,
  InvariantSchema,
  InvariantStep,
  InvariantValue,
} from '../../../runtime/types.js';

// --- Naming helpers ---

function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

function toKebabCase(s: string): string {
  return s.replace(/([A-Z])/g, '-$1').toLowerCase().replace(/^-/, '');
}

function toCamelCase(s: string): string {
  return s.charAt(0).toLowerCase() + s.slice(1);
}

// --- ResolvedType → fp-ts TypeScript mapping ---

function resolvedTypeToNextjs(t: ResolvedType): string {
  switch (t.kind) {
    case 'primitive':
      return primitiveToNextjs(t.primitive);
    case 'param':
      return 'string'; // type parameters are opaque string IDs on wire
    case 'set':
      return `ReadonlySet<${resolvedTypeToNextjs(t.inner)}>`;
    case 'list':
      return `readonly ${resolvedTypeToNextjs(t.inner)}[]`;
    case 'option':
      return `O.Option<${resolvedTypeToNextjs(t.inner)}>`;
    case 'map':
      return `ReadonlyMap<${resolvedTypeToNextjs(t.keyType)}, ${resolvedTypeToNextjs(t.inner)}>`;
    case 'record': {
      const fields = t.fields.map(f => {
        const opt = f.optional ? '?' : '';
        return `readonly ${f.name}${opt}: ${resolvedTypeToNextjs(f.type)}`;
      });
      return `{ ${fields.join('; ')} }`;
    }
  }
}

function primitiveToNextjs(name: string): string {
  switch (name) {
    case 'String':   return 'string';
    case 'Int':      return 'number';
    case 'Float':    return 'number';
    case 'Bool':     return 'boolean';
    case 'Bytes':    return 'Buffer';
    case 'DateTime': return 'Date';
    case 'ID':       return 'string';
    default:         return 'unknown';
  }
}

// --- Import detection ---

function typeNeedsOption(t: ResolvedType): boolean {
  if (t.kind === 'option') return true;
  if (t.kind === 'list' || t.kind === 'set') return typeNeedsOption(t.inner);
  if (t.kind === 'map') return typeNeedsOption(t.keyType) || typeNeedsOption(t.inner);
  if (t.kind === 'record') return t.fields.some(f => typeNeedsOption(f.type));
  return false;
}

function manifestNeedsOption(manifest: ConceptManifest): boolean {
  for (const action of manifest.actions) {
    for (const p of action.params) {
      if (typeNeedsOption(p.type)) return true;
    }
    for (const v of action.variants) {
      for (const f of v.fields) {
        if (typeNeedsOption(f.type)) return true;
      }
    }
  }
  return false;
}

// --- File header ---

function fileHeader(conceptName: string, fileName: string): string {
  return [
    `// ${conceptName} — ${fileName}`,
    `// Generated by NextjsGen. Do not edit manually.`,
    `// Uses fp-ts for purely functional, composable concept implementations.`,
    '',
  ].join('\n');
}

// --- Type Definitions File ---

function generateTypesFile(manifest: ConceptManifest): string {
  const conceptName = manifest.name;
  const lines: string[] = [
    fileHeader(conceptName, 'types.ts'),
  ];

  // fp-ts imports
  const needsOption = manifestNeedsOption(manifest);
  if (needsOption) {
    lines.push(`import * as O from 'fp-ts/Option';`);
    lines.push('');
  }

  // Storage type alias
  lines.push(`// Storage interface for ${conceptName}`);
  lines.push(`export interface ${conceptName}Storage {`);
  lines.push(`  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;`);
  lines.push(`  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;`);
  lines.push(`  readonly delete: (relation: string, key: string) => Promise<boolean>;`);
  lines.push(`  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;`);
  lines.push(`}`);
  lines.push('');

  for (const action of manifest.actions) {
    const inputTypeName = `${conceptName}${capitalize(action.name)}Input`;
    const outputTypeName = `${conceptName}${capitalize(action.name)}Output`;

    // --- Input type (readonly interface) ---
    lines.push(`export interface ${inputTypeName} {`);
    for (const p of action.params) {
      lines.push(`  readonly ${p.name}: ${resolvedTypeToNextjs(p.type)};`);
    }
    lines.push(`}`);
    lines.push('');

    // --- Output type (discriminated union via tagged types) ---
    if (action.variants.length === 1) {
      const v = action.variants[0];
      lines.push(`export interface ${outputTypeName} {`);
      lines.push(`  readonly variant: '${v.tag}';`);
      for (const f of v.fields) {
        lines.push(`  readonly ${f.name}: ${resolvedTypeToNextjs(f.type)};`);
      }
      lines.push(`}`);
    } else {
      // Individual variant interfaces
      for (const v of action.variants) {
        const variantTypeName = `${outputTypeName}${capitalize(v.tag)}`;
        lines.push(`export interface ${variantTypeName} {`);
        lines.push(`  readonly variant: '${v.tag}';`);
        for (const f of v.fields) {
          lines.push(`  readonly ${f.name}: ${resolvedTypeToNextjs(f.type)};`);
        }
        lines.push(`}`);
        lines.push('');
      }

      // Union type
      const variantTypes = action.variants.map(
        v => `${outputTypeName}${capitalize(v.tag)}`
      );
      lines.push(`export type ${outputTypeName} = ${variantTypes.join(' | ')};`);
    }
    lines.push('');
  }

  // Variant constructors (smart constructors for tagged unions)
  lines.push(`// --- Variant constructors ---`);
  lines.push('');
  for (const action of manifest.actions) {
    const outputTypeName = `${conceptName}${capitalize(action.name)}Output`;
    for (const v of action.variants) {
      const constructorName = `${toCamelCase(action.name)}${capitalize(v.tag)}`;
      const fields = v.fields.map(f => `${f.name}: ${resolvedTypeToNextjs(f.type)}`).join(', ');
      const fieldAssignments = v.fields.map(f => f.name).join(', ');

      if (v.fields.length === 0) {
        lines.push(`export const ${constructorName} = (): ${outputTypeName} => ({ variant: '${v.tag}' } as ${outputTypeName});`);
      } else {
        lines.push(`export const ${constructorName} = (${fields}): ${outputTypeName} => ({ variant: '${v.tag}', ${fieldAssignments} } as ${outputTypeName});`);
      }
    }
    lines.push('');
  }

  return lines.join('\n');
}

// --- Handler File (pure functions with TaskEither) ---

function generateHandlerFile(manifest: ConceptManifest): string {
  const conceptName = manifest.name;
  const lines: string[] = [
    fileHeader(conceptName, 'handler.ts'),
    `import * as TE from 'fp-ts/TaskEither';`,
    `import * as E from 'fp-ts/Either';`,
    `import { pipe } from 'fp-ts/function';`,
    '',
  ];

  // Import types
  const typeImports: string[] = [`${conceptName}Storage`];
  for (const action of manifest.actions) {
    typeImports.push(`${conceptName}${capitalize(action.name)}Input`);
    typeImports.push(`${conceptName}${capitalize(action.name)}Output`);
  }
  lines.push(`import type {`);
  lines.push(`  ${typeImports.join(',\n  ')},`);
  lines.push(`} from './types.js';`);
  lines.push('');

  // Import variant constructors
  const constructors: string[] = [];
  for (const action of manifest.actions) {
    for (const v of action.variants) {
      constructors.push(`${toCamelCase(action.name)}${capitalize(v.tag)}`);
    }
  }
  lines.push(`import {`);
  lines.push(`  ${constructors.join(',\n  ')},`);
  lines.push(`} from './types.js';`);
  lines.push('');

  // Error type for TaskEither left channel
  lines.push(`export interface ${conceptName}Error {`);
  lines.push(`  readonly code: string;`);
  lines.push(`  readonly message: string;`);
  lines.push(`}`);
  lines.push('');

  // Handler type (record of pure functions)
  lines.push(`export interface ${conceptName}Handler {`);
  for (const action of manifest.actions) {
    const inputType = `${conceptName}${capitalize(action.name)}Input`;
    const outputType = `${conceptName}${capitalize(action.name)}Output`;
    lines.push(`  readonly ${action.name}: (`);
    lines.push(`    input: ${inputType},`);
    lines.push(`    storage: ${conceptName}Storage,`);
    lines.push(`  ) => TE.TaskEither<${conceptName}Error, ${outputType}>;`);
  }
  lines.push(`}`);
  lines.push('');

  // Default implementation with TODO stubs
  lines.push(`// --- Default implementation (fill in business logic) ---`);
  lines.push('');
  lines.push(`export const ${toCamelCase(conceptName)}Handler: ${conceptName}Handler = {`);
  for (let i = 0; i < manifest.actions.length; i++) {
    const action = manifest.actions[i];
    const inputType = `${conceptName}${capitalize(action.name)}Input`;
    const outputType = `${conceptName}${capitalize(action.name)}Output`;
    const firstVariant = action.variants[0];
    const constructorName = `${toCamelCase(action.name)}${capitalize(firstVariant.tag)}`;

    lines.push(`  ${action.name}: (input, storage) =>`);
    lines.push(`    pipe(`);
    lines.push(`      TE.tryCatch(`);
    lines.push(`        async () => {`);
    lines.push(`          // TODO: Implement ${action.name} logic`);

    // Generate a reasonable stub based on the first variant
    if (firstVariant.fields.length === 0) {
      lines.push(`          return ${constructorName}();`);
    } else {
      const fieldValues = firstVariant.fields.map(f => {
        if (f.type.kind === 'param') return `input.${action.params[0]?.name ?? 'id'}`;
        if (f.type.kind === 'primitive') {
          switch (f.type.primitive) {
            case 'String': return `''`;
            case 'Int': case 'Float': return `0`;
            case 'Bool': return `true`;
            default: return `'' as any`;
          }
        }
        return `undefined as any`;
      });
      lines.push(`          return ${constructorName}(${fieldValues.join(', ')});`);
    }

    lines.push(`        },`);
    lines.push(`        (error): ${conceptName}Error => ({`);
    lines.push(`          code: 'STORAGE_ERROR',`);
    lines.push(`          message: error instanceof Error ? error.message : String(error),`);
    lines.push(`        }),`);
    lines.push(`      ),`);
    lines.push(`    ),`);
    if (i < manifest.actions.length - 1) lines.push('');
  }
  lines.push(`};`);

  return lines.join('\n');
}

// --- Next.js Route Handler Adapter ---

function generateRouteFile(manifest: ConceptManifest): string {
  const conceptName = manifest.name;
  const kebabName = toKebabCase(conceptName);
  const lines: string[] = [
    fileHeader(conceptName, 'route.ts'),
    `// Next.js App Router Route Handler — maps HTTP to concept actions`,
    `// Place at: app/api/${kebabName}/route.ts`,
    '',
    `import { NextRequest, NextResponse } from 'next/server';`,
    `import * as TE from 'fp-ts/TaskEither';`,
    `import * as E from 'fp-ts/Either';`,
    `import { pipe } from 'fp-ts/function';`,
    '',
  ];

  // Import handler and types
  lines.push(`import type { ${conceptName}Handler, ${conceptName}Error } from './handler.js';`);
  lines.push(`import type { ${conceptName}Storage } from './types.js';`);
  lines.push('');

  // Error response helper
  lines.push(`const errorResponse = (error: ${conceptName}Error, status = 422): NextResponse =>`);
  lines.push(`  NextResponse.json({ errors: [{ code: error.code, message: error.message }] }, { status });`);
  lines.push('');

  // Success response helper
  lines.push(`const successResponse = <T>(data: T, status = 200): NextResponse =>`);
  lines.push(`  NextResponse.json(data, { status });`);
  lines.push('');

  // Route handler factory
  lines.push(`export const create${conceptName}Routes = (`);
  lines.push(`  handler: ${conceptName}Handler,`);
  lines.push(`  storage: ${conceptName}Storage,`);
  lines.push(`) => {`);
  lines.push('');

  // Dispatch function
  lines.push(`  const dispatch = async (action: string, input: Record<string, unknown>): Promise<NextResponse> => {`);
  lines.push(`    switch (action) {`);

  for (const action of manifest.actions) {
    lines.push(`      case '${action.name}': {`);
    lines.push(`        const result = await handler.${action.name}(input as any, storage)();`);
    lines.push(`        return pipe(`);
    lines.push(`          result,`);
    lines.push(`          E.fold(`);
    lines.push(`            (error) => errorResponse(error),`);
    lines.push(`            (output) => successResponse(output),`);
    lines.push(`          ),`);
    lines.push(`        );`);
    lines.push(`      }`);
  }

  lines.push(`      default:`);
  lines.push(`        return NextResponse.json(`);
  lines.push(`          { errors: [{ code: 'UNKNOWN_ACTION', message: \`Unknown action: \${action}\` }] },`);
  lines.push(`          { status: 404 },`);
  lines.push(`        );`);
  lines.push(`    }`);
  lines.push(`  };`);
  lines.push('');

  // POST handler (action dispatch)
  lines.push(`  const POST = async (request: NextRequest): Promise<NextResponse> => {`);
  lines.push(`    const body = await request.json() as { action: string; input: Record<string, unknown> };`);
  lines.push(`    return dispatch(body.action, body.input);`);
  lines.push(`  };`);
  lines.push('');

  // GET handler (list/get actions)
  const getActions = manifest.actions.filter(a =>
    a.name.startsWith('get') || a.name.startsWith('list') || a.name.startsWith('find') || a.name === 'all'
  );

  if (getActions.length > 0) {
    lines.push(`  const GET = async (request: NextRequest): Promise<NextResponse> => {`);
    lines.push(`    const { searchParams } = new URL(request.url);`);
    lines.push(`    const action = searchParams.get('action') ?? '${getActions[0].name}';`);
    lines.push(`    const input: Record<string, unknown> = {};`);
    lines.push(`    searchParams.forEach((value, key) => {`);
    lines.push(`      if (key !== 'action') input[key] = value;`);
    lines.push(`    });`);
    lines.push(`    return dispatch(action, input);`);
    lines.push(`  };`);
    lines.push('');
  }

  // Return exported handlers
  const exportedHandlers = ['POST'];
  if (getActions.length > 0) exportedHandlers.push('GET');

  lines.push(`  return { ${exportedHandlers.join(', ')} };`);
  lines.push(`};`);

  return lines.join('\n');
}

// --- Conformance Test File ---

function generateConformanceTestFile(manifest: ConceptManifest): string | null {
  if (manifest.invariants.length === 0) {
    return null;
  }

  const conceptName = manifest.name;
  const lines: string[] = [
    fileHeader(conceptName, 'conformance.test.ts'),
    `import { describe, it, expect } from 'vitest';`,
    `import * as TE from 'fp-ts/TaskEither';`,
    `import * as E from 'fp-ts/Either';`,
    `import { pipe } from 'fp-ts/function';`,
    '',
    `import { ${toCamelCase(conceptName)}Handler } from './handler.js';`,
    `import type { ${conceptName}Storage } from './types.js';`,
    '',
    `// In-memory storage for conformance tests`,
    `const createTestStorage = (): ${conceptName}Storage => {`,
    `  const store = new Map<string, Map<string, Record<string, unknown>>>();`,
    `  return {`,
    `    get: async (relation, key) => store.get(relation)?.get(key) ?? null,`,
    `    put: async (relation, key, value) => {`,
    `      if (!store.has(relation)) store.set(relation, new Map());`,
    `      store.get(relation)!.set(key, value);`,
    `    },`,
    `    delete: async (relation, key) => store.get(relation)?.delete(key) ?? false,`,
    `    find: async (relation) => [...(store.get(relation)?.values() ?? [])],`,
    `  };`,
    `};`,
    '',
  ];

  lines.push(`describe('${conceptName} conformance', () => {`);

  for (let invIdx = 0; invIdx < manifest.invariants.length; invIdx++) {
    const inv = manifest.invariants[invIdx];

    lines.push(`  it('${inv.description.replace(/'/g, "\\'")}', async () => {`);
    lines.push(`    const storage = createTestStorage();`);
    lines.push(`    const handler = ${toCamelCase(conceptName)}Handler;`);
    lines.push('');

    // Free variable declarations
    for (const fv of inv.freeVariables) {
      lines.push(`    const ${fv.name} = '${fv.testValue}';`);
    }
    lines.push('');

    // Setup steps (AFTER clause)
    for (const step of inv.setup) {
      lines.push(generateStepCode(step, conceptName, 'setup'));
    }

    // Assertion steps (THEN clause)
    for (const step of inv.assertions) {
      lines.push(generateStepCode(step, conceptName, 'assert'));
    }

    lines.push(`  });`);
    lines.push('');
  }

  lines.push(`});`);

  return lines.join('\n');
}

function generateStepCode(
  step: InvariantStep,
  conceptName: string,
  phase: 'setup' | 'assert',
): string {
  const lines: string[] = [];

  // Build input object
  const inputFields = step.inputs.map(input => {
    if (input.value.kind === 'literal') {
      const v = input.value.value;
      if (typeof v === 'string') return `      ${input.name}: '${v}',`;
      return `      ${input.name}: ${v},`;
    } else {
      return `      ${input.name}: ${input.value.name},`;
    }
  });

  lines.push(`    // ${phase}: ${step.action} -> ${step.expectedVariant}`);
  lines.push(`    const ${step.action}Result${phase === 'assert' ? 'Assert' : 'Setup'} = await pipe(`);
  lines.push(`      handler.${step.action}({`);
  lines.push(inputFields.join('\n'));
  lines.push(`      }, storage),`);
  lines.push(`      TE.map((output) => {`);
  lines.push(`        expect(output.variant).toBe('${step.expectedVariant}');`);

  // Assert expected output values
  for (const output of step.expectedOutputs) {
    if (output.value.kind === 'literal') {
      const v = output.value.value;
      if (typeof v === 'string') {
        lines.push(`        expect((output as any).${output.name}).toBe('${v}');`);
      } else {
        lines.push(`        expect((output as any).${output.name}).toBe(${v});`);
      }
    } else {
      lines.push(`        expect((output as any).${output.name}).toBe(${output.value.name});`);
    }
  }

  lines.push(`        return output;`);
  lines.push(`      }),`);
  lines.push(`    )();`);
  lines.push(`    expect(E.isRight(${step.action}Result${phase === 'assert' ? 'Assert' : 'Setup'})).toBe(true);`);
  lines.push('');

  return lines.join('\n');
}

// --- Handler Export ---

export const nextjsGenHandler: ConceptHandler = {
  async generate(input, storage) {
    const spec = input.spec as string;
    const manifest = input.manifest as ConceptManifest;

    if (!manifest || !manifest.name) {
      return { variant: 'error', message: 'Invalid manifest: missing concept name' };
    }

    try {
      const lowerName = toKebabCase(manifest.name);

      const files: { path: string; content: string }[] = [
        { path: `${lowerName}/types.ts`, content: generateTypesFile(manifest) },
        { path: `${lowerName}/handler.ts`, content: generateHandlerFile(manifest) },
        { path: `${lowerName}/route.ts`, content: generateRouteFile(manifest) },
      ];

      const conformanceTest = generateConformanceTestFile(manifest);
      if (conformanceTest) {
        files.push({ path: `${lowerName}/conformance.test.ts`, content: conformanceTest });
      }

      return { variant: 'ok', files };
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : String(err);
      return { variant: 'error', message };
    }
  },
};
