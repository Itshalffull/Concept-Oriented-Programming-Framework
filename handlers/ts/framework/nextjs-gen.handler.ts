// ============================================================
// NextjsGen Concept Implementation
//
// Generates Next.js App Router code from a ConceptManifest using
// fp-ts for purely functional concept implementations. All output
// is purely functional: no classes, no mutation, TaskEither-based
// error handling, pipe-based composition.
//
// Type mapping table:
//   String   → string        Int      → number
//   Float    → number        Bool     → boolean
//   Bytes    → Buffer        DateTime → Date
//   ID       → string        option T → O.Option<T>
//   set T    → ReadonlySet<T>  list T → readonly T[]
//   A -> B   → ReadonlyMap<A, B>  params → string (opaque)
//
// Generated files per concept:
//   - types.ts         (readonly interfaces, branded types, tagged unions)
//   - handler.ts       (pure functions returning TE.TaskEither)
//   - route.ts         (Next.js App Router Route Handler adapter)
//   - conformance.test.ts  (vitest tests from invariants)
// ============================================================

import type {
  ConceptHandler,
  ConceptStorage,
  ConceptManifest,
  ResolvedType,
  ActionSchema,
  VariantSchema,
  InvariantSchema,
  InvariantStep,
  InvariantValue,
} from '../../../runtime/types.js';

// --- Naming helpers ---

function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

function toKebabCase(s: string): string {
  return s.replace(/([A-Z])/g, '-$1').toLowerCase().replace(/^-/, '');
}

function toCamelCase(s: string): string {
  return s.charAt(0).toLowerCase() + s.slice(1);
}

// --- ResolvedType → fp-ts TypeScript mapping ---

function resolvedTypeToNextjs(t: ResolvedType): string {
  switch (t.kind) {
    case 'primitive':
      return primitiveToNextjs(t.primitive);
    case 'param':
      return 'string'; // type parameters are opaque string IDs on wire
    case 'set':
      return `ReadonlySet<${resolvedTypeToNextjs(t.inner)}>`;
    case 'list':
      return `readonly ${resolvedTypeToNextjs(t.inner)}[]`;
    case 'option':
      return `O.Option<${resolvedTypeToNextjs(t.inner)}>`;
    case 'map':
      return `ReadonlyMap<${resolvedTypeToNextjs(t.keyType)}, ${resolvedTypeToNextjs(t.inner)}>`;
    case 'record': {
      const fields = t.fields.map(f => {
        const opt = f.optional ? '?' : '';
        return `readonly ${f.name}${opt}: ${resolvedTypeToNextjs(f.type)}`;
      });
      return `{ ${fields.join('; ')} }`;
    }
  }
}

function primitiveToNextjs(name: string): string {
  switch (name) {
    case 'String':   return 'string';
    case 'Int':      return 'number';
    case 'Float':    return 'number';
    case 'Bool':     return 'boolean';
    case 'Bytes':    return 'Buffer';
    case 'DateTime': return 'Date';
    case 'ID':       return 'string';
    default:         return 'unknown';
  }
}

// --- Import detection ---

function typeNeedsOption(t: ResolvedType): boolean {
  if (t.kind === 'option') return true;
  if (t.kind === 'list' || t.kind === 'set') return typeNeedsOption(t.inner);
  if (t.kind === 'map') return typeNeedsOption(t.keyType) || typeNeedsOption(t.inner);
  if (t.kind === 'record') return t.fields.some(f => typeNeedsOption(f.type));
  return false;
}

function manifestNeedsOption(manifest: ConceptManifest): boolean {
  for (const action of manifest.actions) {
    for (const p of action.params) {
      if (typeNeedsOption(p.type)) return true;
    }
    for (const v of action.variants) {
      for (const f of v.fields) {
        if (typeNeedsOption(f.type)) return true;
      }
    }
  }
  return false;
}

// --- File header ---

function fileHeader(conceptName: string, fileName: string): string {
  return [
    `// ${conceptName} — ${fileName}`,
    `// Generated by NextjsGen. Do not edit manually.`,
    `// Uses fp-ts for purely functional, composable concept implementations.`,
    '',
  ].join('\n');
}

// --- Type Definitions File ---

function generateTypesFile(manifest: ConceptManifest): string {
  const conceptName = manifest.name;
  const lines: string[] = [
    fileHeader(conceptName, 'types.ts'),
  ];

  // fp-ts imports
  const needsOption = manifestNeedsOption(manifest);
  if (needsOption) {
    lines.push(`import * as O from 'fp-ts/Option';`);
    lines.push('');
  }

  // Storage type alias
  lines.push(`// Storage interface for ${conceptName}`);
  lines.push(`export interface ${conceptName}Storage {`);
  lines.push(`  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;`);
  lines.push(`  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;`);
  lines.push(`  readonly delete: (relation: string, key: string) => Promise<boolean>;`);
  lines.push(`  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;`);
  lines.push(`}`);
  lines.push('');

  for (const action of manifest.actions) {
    const inputTypeName = `${conceptName}${capitalize(action.name)}Input`;
    const outputTypeName = `${conceptName}${capitalize(action.name)}Output`;

    // --- Input type (readonly interface) ---
    lines.push(`export interface ${inputTypeName} {`);
    for (const p of action.params) {
      lines.push(`  readonly ${p.name}: ${resolvedTypeToNextjs(p.type)};`);
    }
    lines.push(`}`);
    lines.push('');

    // --- Output type (discriminated union via tagged types) ---
    if (action.variants.length === 1) {
      const v = action.variants[0];
      lines.push(`export interface ${outputTypeName} {`);
      lines.push(`  readonly variant: '${v.tag}';`);
      for (const f of v.fields) {
        lines.push(`  readonly ${f.name}: ${resolvedTypeToNextjs(f.type)};`);
      }
      lines.push(`}`);
    } else {
      // Individual variant interfaces
      for (const v of action.variants) {
        const variantTypeName = `${outputTypeName}${capitalize(v.tag)}`;
        lines.push(`export interface ${variantTypeName} {`);
        lines.push(`  readonly variant: '${v.tag}';`);
        for (const f of v.fields) {
          lines.push(`  readonly ${f.name}: ${resolvedTypeToNextjs(f.type)};`);
        }
        lines.push(`}`);
        lines.push('');
      }

      // Union type
      const variantTypes = action.variants.map(
        v => `${outputTypeName}${capitalize(v.tag)}`
      );
      lines.push(`export type ${outputTypeName} = ${variantTypes.join(' | ')};`);
    }
    lines.push('');
  }

  // Variant constructors (smart constructors for tagged unions)
  lines.push(`// --- Variant constructors ---`);
  lines.push('');
  for (const action of manifest.actions) {
    const outputTypeName = `${conceptName}${capitalize(action.name)}Output`;
    for (const v of action.variants) {
      const constructorName = `${toCamelCase(action.name)}${capitalize(v.tag)}`;
      const fields = v.fields.map(f => `${f.name}: ${resolvedTypeToNextjs(f.type)}`).join(', ');
      const fieldAssignments = v.fields.map(f => f.name).join(', ');

      if (v.fields.length === 0) {
        lines.push(`export const ${constructorName} = (): ${outputTypeName} => ({ variant: '${v.tag}' } as ${outputTypeName});`);
      } else {
        lines.push(`export const ${constructorName} = (${fields}): ${outputTypeName} => ({ variant: '${v.tag}', ${fieldAssignments} } as ${outputTypeName});`);
      }
    }
    lines.push('');
  }

  return lines.join('\n');
}

// --- Action pattern classification ---

type ActionPattern = 'create' | 'get' | 'list' | 'update' | 'delete' | 'check' | 'transform';

function classifyAction(name: string): ActionPattern {
  const lower = name.toLowerCase();
  if (/^(add|create|new|set|register|define|send|insert|put|emit|record|save|store|assign|attach|connect|link|begin|start|open|init|setup|install|import|ingest|capture|publish|enable|activate|grant|allow|subscribe|join|enqueue|push|acquire|mark|write|mount|deploy|apply|configure|schedule|trigger)/.test(lower)) return 'create';
  if (/^(get|fetch|load|read|lookup|resolve|inspect|show|describe|status|current|peek|head|detail|info|metadata|stat)/.test(lower)) return 'get';
  if (/^(list|all|find|search|scan|query|browse|enumerate|filter|match|discover|index|keys|entries|history|recent|stale|graph|manifest|audit)/.test(lower)) return 'list';
  if (/^(update|edit|modify|rename|change|patch|replace|refresh|sync|merge|reorder|move|swap|migrate|promote|demote|reset|clear|flush|rebase|reparent|evolve|toggle|remap|reconfigure|rebuild|recompute|recalculate|compact|prune|finalize|seal|complete|close|revise|annotate|enrich)/.test(lower)) return 'update';
  if (/^(delete|remove|revoke|unset|drop|destroy|erase|purge|unlink|detach|disconnect|unsubscribe|dequeue|release|leave|deactivate|disable|unpublish|unassign|unregister|unmount|clean|retract|reject|deny|archive|expire|invalidate|suspend|ban|block|cancel)/.test(lower)) return 'delete';
  if (/^(check|validate|verify|test|assert|evaluate|compare|diff|can|is|has|exists|contains|satisfies|conforms|compatible|equal|equiv)/.test(lower)) return 'check';
  if (/^(generate|compute|transform|compile|parse|render|convert|build|process|analyze|extract|derive|infer|project|map|reduce|fold|aggregate|summarize|classify|score|plan|route|dispatch|emit|normalize|encode|decode|hash|sign|encrypt|decrypt|compress|decompress|serialize|deserialize|format|tokenize|lex|translate|transpile|optimize|minify|bundle|package|scaffold|stub|synthesize|interpolate|sample|embed|vectorize|cluster)/.test(lower)) return 'transform';
  // For reply-like actions, treat as create (they create a child entity)
  if (/^(reply|respond|answer|comment|react|vote|rate|like|bookmark|favorite|follow|watch|star|pin|flag|report|tag|label|categorize|annotate)/.test(lower)) return 'create';
  return 'create'; // default: treat as a create/store operation
}

function primaryKeyField(action: ActionSchema): string {
  // Find the first param-type field, or fall back to first field name
  for (const p of action.params) {
    if (p.type.kind === 'param') return p.name;
  }
  return action.params[0]?.name ?? 'id';
}

function relationName(conceptName: string): string {
  return conceptName.toLowerCase();
}

// --- Handler File (pure functions with TaskEither) ---

function generateHandlerFile(manifest: ConceptManifest): string {
  const conceptName = manifest.name;
  const relation = relationName(conceptName);
  const needsOption = manifest.actions.some(a => {
    const pattern = classifyAction(a.name);
    return pattern === 'get' || pattern === 'update' || pattern === 'delete' || pattern === 'check';
  });

  const lines: string[] = [
    fileHeader(conceptName, 'handler.ts'),
    `import * as TE from 'fp-ts/TaskEither';`,
    `import * as E from 'fp-ts/Either';`,
  ];
  if (needsOption) {
    lines.push(`import * as O from 'fp-ts/Option';`);
  }
  lines.push(`import { pipe } from 'fp-ts/function';`);
  lines.push('');

  // Import types
  const typeImports: string[] = [`${conceptName}Storage`];
  for (const action of manifest.actions) {
    typeImports.push(`${conceptName}${capitalize(action.name)}Input`);
    typeImports.push(`${conceptName}${capitalize(action.name)}Output`);
  }
  lines.push(`import type {`);
  lines.push(`  ${typeImports.join(',\n  ')},`);
  lines.push(`} from './types.js';`);
  lines.push('');

  // Import variant constructors
  const constructors: string[] = [];
  for (const action of manifest.actions) {
    for (const v of action.variants) {
      constructors.push(`${toCamelCase(action.name)}${capitalize(v.tag)}`);
    }
  }
  lines.push(`import {`);
  lines.push(`  ${constructors.join(',\n  ')},`);
  lines.push(`} from './types.js';`);
  lines.push('');

  // Error type for TaskEither left channel
  lines.push(`export interface ${conceptName}Error {`);
  lines.push(`  readonly code: string;`);
  lines.push(`  readonly message: string;`);
  lines.push(`}`);
  lines.push('');

  // Handler type (record of pure functions)
  lines.push(`export interface ${conceptName}Handler {`);
  for (const action of manifest.actions) {
    const inputType = `${conceptName}${capitalize(action.name)}Input`;
    const outputType = `${conceptName}${capitalize(action.name)}Output`;
    lines.push(`  readonly ${action.name}: (`);
    lines.push(`    input: ${inputType},`);
    lines.push(`    storage: ${conceptName}Storage,`);
    lines.push(`  ) => TE.TaskEither<${conceptName}Error, ${outputType}>;`);
  }
  lines.push(`}`);
  lines.push('');

  // Implementation with real business logic
  lines.push(`// --- Implementation ---`);
  lines.push('');
  lines.push(`export const ${toCamelCase(conceptName)}Handler: ${conceptName}Handler = {`);
  for (let i = 0; i < manifest.actions.length; i++) {
    const action = manifest.actions[i];
    const pattern = classifyAction(action.name);
    const key = primaryKeyField(action);
    const errorType = `${conceptName}Error`;

    lines.push(`  ${action.name}: (input, storage) =>`);

    const hasNotfound = action.variants.some(v => v.tag === 'notfound');
    const hasError = action.variants.some(v => v.tag === 'error');
    const hasInvalid = action.variants.some(v => v.tag === 'invalid');
    const okVariant = action.variants.find(v => v.tag === 'ok');
    const okConstructor = `${toCamelCase(action.name)}${capitalize('ok')}`;
    const notfoundConstructor = hasNotfound ? `${toCamelCase(action.name)}${capitalize('notfound')}` : null;
    const errorConstructor = hasError ? `${toCamelCase(action.name)}${capitalize('error')}` : null;
    const invalidConstructor = hasInvalid ? `${toCamelCase(action.name)}${capitalize('invalid')}` : null;

    switch (pattern) {
      case 'create':
        lines.push(...generateCreateAction(action, conceptName, relation, key, errorType, okConstructor, okVariant, invalidConstructor));
        break;
      case 'get':
        lines.push(...generateGetAction(action, conceptName, relation, key, errorType, okConstructor, okVariant, notfoundConstructor, errorConstructor));
        break;
      case 'list':
        lines.push(...generateListAction(action, conceptName, relation, errorType, okConstructor, okVariant));
        break;
      case 'update':
        lines.push(...generateUpdateAction(action, conceptName, relation, key, errorType, okConstructor, okVariant, notfoundConstructor, errorConstructor));
        break;
      case 'delete':
        lines.push(...generateDeleteAction(action, conceptName, relation, key, errorType, okConstructor, notfoundConstructor, errorConstructor));
        break;
      case 'check':
        lines.push(...generateCheckAction(action, conceptName, relation, key, errorType, okConstructor, okVariant, notfoundConstructor));
        break;
      case 'transform':
        lines.push(...generateTransformAction(action, conceptName, relation, key, errorType, okConstructor, okVariant, errorConstructor));
        break;
    }

    if (i < manifest.actions.length - 1) lines.push('');
  }
  lines.push(`};`);

  return lines.join('\n');
}

// --- Action implementation generators ---

function inputFieldsToRecord(action: ActionSchema): string {
  return action.params.map(p => `${p.name}: input.${p.name}`).join(', ');
}

function okFieldValues(action: ActionSchema, okVariant: VariantSchema | undefined, source: string): string {
  if (!okVariant || okVariant.fields.length === 0) return '';
  return okVariant.fields.map(f => {
    // Match field to input param by name
    const matchingParam = action.params.find(p => p.name === f.name);
    if (matchingParam) return `input.${f.name}`;
    // Match to storage record field
    if (source === 'record') return `(${source} as any).${f.name}`;
    // Match to known default values
    if (f.type.kind === 'primitive') {
      switch (f.type.primitive) {
        case 'Bool': return 'true';
        case 'Int': case 'Float': return '0';
        case 'String': return `input.${action.params[0]?.name ?? 'id'}`;
      }
    }
    if (f.type.kind === 'param') return `input.${action.params[0]?.name ?? 'id'}`;
    if (f.type.kind === 'list') return '[]';
    if (f.type.kind === 'set') return 'new Set()';
    return `input.${action.params[0]?.name ?? 'id'}`;
  }).join(', ');
}

function generateCreateAction(
  action: ActionSchema, conceptName: string, relation: string, key: string,
  errorType: string, okConstructor: string, okVariant: VariantSchema | undefined,
  invalidConstructor: string | null,
): string[] {
  const lines: string[] = [];
  lines.push(`    pipe(`);
  lines.push(`      TE.tryCatch(`);
  lines.push(`        async () => {`);
  lines.push(`          await storage.put('${relation}', input.${key}, { ${inputFieldsToRecord(action)} });`);
  lines.push(`          return ${okConstructor}(${okFieldValues(action, okVariant, 'input')});`);
  lines.push(`        },`);
  lines.push(`        (error): ${errorType} => ({`);
  lines.push(`          code: 'STORAGE_ERROR',`);
  lines.push(`          message: error instanceof Error ? error.message : String(error),`);
  lines.push(`        }),`);
  lines.push(`      ),`);
  lines.push(`    ),`);
  return lines;
}

function generateGetAction(
  action: ActionSchema, conceptName: string, relation: string, key: string,
  errorType: string, okConstructor: string, okVariant: VariantSchema | undefined,
  notfoundConstructor: string | null, errorConstructor: string | null,
): string[] {
  const lines: string[] = [];
  const failConstructor = notfoundConstructor ?? errorConstructor;
  if (failConstructor) {
    lines.push(`    pipe(`);
    lines.push(`      TE.tryCatch(`);
    lines.push(`        () => storage.get('${relation}', input.${key}),`);
    lines.push(`        (error): ${errorType} => ({`);
    lines.push(`          code: 'STORAGE_ERROR',`);
    lines.push(`          message: error instanceof Error ? error.message : String(error),`);
    lines.push(`        }),`);
    lines.push(`      ),`);
    lines.push(`      TE.chain((record) =>`);
    lines.push(`        pipe(`);
    lines.push(`          O.fromNullable(record),`);
    lines.push(`          O.fold(`);
    lines.push(`            () => TE.right(${failConstructor}(\`\${input.${key}} not found\`)),`);
    lines.push(`            (found) => TE.right(${okConstructor}(${okFieldValues(action, okVariant, 'found')})),`);
    lines.push(`          ),`);
    lines.push(`        ),`);
    lines.push(`      ),`);
    lines.push(`    ),`);
  } else {
    lines.push(`    pipe(`);
    lines.push(`      TE.tryCatch(`);
    lines.push(`        async () => {`);
    lines.push(`          const record = await storage.get('${relation}', input.${key});`);
    lines.push(`          return ${okConstructor}(${okFieldValues(action, okVariant, 'record')});`);
    lines.push(`        },`);
    lines.push(`        (error): ${errorType} => ({`);
    lines.push(`          code: 'STORAGE_ERROR',`);
    lines.push(`          message: error instanceof Error ? error.message : String(error),`);
    lines.push(`        }),`);
    lines.push(`      ),`);
    lines.push(`    ),`);
  }
  return lines;
}

function generateListAction(
  action: ActionSchema, conceptName: string, relation: string,
  errorType: string, okConstructor: string, okVariant: VariantSchema | undefined,
): string[] {
  const lines: string[] = [];
  lines.push(`    pipe(`);
  lines.push(`      TE.tryCatch(`);
  lines.push(`        async () => {`);
  lines.push(`          const records = await storage.find('${relation}');`);
  lines.push(`          return ${okConstructor}(${okFieldValues(action, okVariant, 'records')});`);
  lines.push(`        },`);
  lines.push(`        (error): ${errorType} => ({`);
  lines.push(`          code: 'STORAGE_ERROR',`);
  lines.push(`          message: error instanceof Error ? error.message : String(error),`);
  lines.push(`        }),`);
  lines.push(`      ),`);
  lines.push(`    ),`);
  return lines;
}

function generateUpdateAction(
  action: ActionSchema, conceptName: string, relation: string, key: string,
  errorType: string, okConstructor: string, okVariant: VariantSchema | undefined,
  notfoundConstructor: string | null, errorConstructor: string | null,
): string[] {
  const lines: string[] = [];
  const failConstructor = notfoundConstructor ?? errorConstructor;
  if (failConstructor) {
    lines.push(`    pipe(`);
    lines.push(`      TE.tryCatch(`);
    lines.push(`        () => storage.get('${relation}', input.${key}),`);
    lines.push(`        (error): ${errorType} => ({`);
    lines.push(`          code: 'STORAGE_ERROR',`);
    lines.push(`          message: error instanceof Error ? error.message : String(error),`);
    lines.push(`        }),`);
    lines.push(`      ),`);
    lines.push(`      TE.chain((record) =>`);
    lines.push(`        pipe(`);
    lines.push(`          O.fromNullable(record),`);
    lines.push(`          O.fold(`);
    lines.push(`            () => TE.right(${failConstructor}(\`\${input.${key}} not found\`)),`);
    lines.push(`            (existing) =>`);
    lines.push(`              TE.tryCatch(`);
    lines.push(`                async () => {`);
    lines.push(`                  const updated = { ...existing, ${inputFieldsToRecord(action)} };`);
    lines.push(`                  await storage.put('${relation}', input.${key}, updated);`);
    lines.push(`                  return ${okConstructor}(${okFieldValues(action, okVariant, 'updated')});`);
    lines.push(`                },`);
    lines.push(`                (error): ${errorType} => ({`);
    lines.push(`                  code: 'STORAGE_ERROR',`);
    lines.push(`                  message: error instanceof Error ? error.message : String(error),`);
    lines.push(`                }),`);
    lines.push(`              ),`);
    lines.push(`          ),`);
    lines.push(`        ),`);
    lines.push(`      ),`);
    lines.push(`    ),`);
  } else {
    lines.push(`    pipe(`);
    lines.push(`      TE.tryCatch(`);
    lines.push(`        async () => {`);
    lines.push(`          const existing = await storage.get('${relation}', input.${key});`);
    lines.push(`          const updated = { ...existing, ${inputFieldsToRecord(action)} };`);
    lines.push(`          await storage.put('${relation}', input.${key}, updated);`);
    lines.push(`          return ${okConstructor}(${okFieldValues(action, okVariant, 'updated')});`);
    lines.push(`        },`);
    lines.push(`        (error): ${errorType} => ({`);
    lines.push(`          code: 'STORAGE_ERROR',`);
    lines.push(`          message: error instanceof Error ? error.message : String(error),`);
    lines.push(`        }),`);
    lines.push(`      ),`);
    lines.push(`    ),`);
  }
  return lines;
}

function generateDeleteAction(
  action: ActionSchema, conceptName: string, relation: string, key: string,
  errorType: string, okConstructor: string,
  notfoundConstructor: string | null, errorConstructor: string | null,
): string[] {
  const lines: string[] = [];
  const failConstructor = notfoundConstructor ?? errorConstructor;
  if (failConstructor) {
    lines.push(`    pipe(`);
    lines.push(`      TE.tryCatch(`);
    lines.push(`        () => storage.get('${relation}', input.${key}),`);
    lines.push(`        (error): ${errorType} => ({`);
    lines.push(`          code: 'STORAGE_ERROR',`);
    lines.push(`          message: error instanceof Error ? error.message : String(error),`);
    lines.push(`        }),`);
    lines.push(`      ),`);
    lines.push(`      TE.chain((record) =>`);
    lines.push(`        pipe(`);
    lines.push(`          O.fromNullable(record),`);
    lines.push(`          O.fold(`);
    lines.push(`            () => TE.right(${failConstructor}(\`\${input.${key}} not found\`)),`);
    lines.push(`            () =>`);
    lines.push(`              TE.tryCatch(`);
    lines.push(`                async () => {`);
    lines.push(`                  await storage.delete('${relation}', input.${key});`);
    lines.push(`                  return ${okConstructor}();`);
    lines.push(`                },`);
    lines.push(`                (error): ${errorType} => ({`);
    lines.push(`                  code: 'STORAGE_ERROR',`);
    lines.push(`                  message: error instanceof Error ? error.message : String(error),`);
    lines.push(`                }),`);
    lines.push(`              ),`);
    lines.push(`          ),`);
    lines.push(`        ),`);
    lines.push(`      ),`);
    lines.push(`    ),`);
  } else {
    lines.push(`    pipe(`);
    lines.push(`      TE.tryCatch(`);
    lines.push(`        async () => {`);
    lines.push(`          await storage.delete('${relation}', input.${key});`);
    lines.push(`          return ${okConstructor}();`);
    lines.push(`        },`);
    lines.push(`        (error): ${errorType} => ({`);
    lines.push(`          code: 'STORAGE_ERROR',`);
    lines.push(`          message: error instanceof Error ? error.message : String(error),`);
    lines.push(`        }),`);
    lines.push(`      ),`);
    lines.push(`    ),`);
  }
  return lines;
}

function generateCheckAction(
  action: ActionSchema, conceptName: string, relation: string, key: string,
  errorType: string, okConstructor: string, okVariant: VariantSchema | undefined,
  notfoundConstructor: string | null,
): string[] {
  const lines: string[] = [];
  if (notfoundConstructor) {
    lines.push(`    pipe(`);
    lines.push(`      TE.tryCatch(`);
    lines.push(`        () => storage.get('${relation}', input.${key}),`);
    lines.push(`        (error): ${errorType} => ({`);
    lines.push(`          code: 'STORAGE_ERROR',`);
    lines.push(`          message: error instanceof Error ? error.message : String(error),`);
    lines.push(`        }),`);
    lines.push(`      ),`);
    lines.push(`      TE.chain((record) =>`);
    lines.push(`        pipe(`);
    lines.push(`          O.fromNullable(record),`);
    lines.push(`          O.fold(`);
    lines.push(`            () => TE.right(${notfoundConstructor}(\`\${input.${key}} not found\`)),`);
    lines.push(`            (found) => TE.right(${okConstructor}(${okFieldValues(action, okVariant, 'found')})),`);
    lines.push(`          ),`);
    lines.push(`        ),`);
    lines.push(`      ),`);
    lines.push(`    ),`);
  } else {
    lines.push(`    pipe(`);
    lines.push(`      TE.tryCatch(`);
    lines.push(`        async () => {`);
    lines.push(`          const record = await storage.get('${relation}', input.${key});`);
    lines.push(`          return ${okConstructor}(${okFieldValues(action, okVariant, 'record')});`);
    lines.push(`        },`);
    lines.push(`        (error): ${errorType} => ({`);
    lines.push(`          code: 'STORAGE_ERROR',`);
    lines.push(`          message: error instanceof Error ? error.message : String(error),`);
    lines.push(`        }),`);
    lines.push(`      ),`);
    lines.push(`    ),`);
  }
  return lines;
}

function generateTransformAction(
  action: ActionSchema, conceptName: string, relation: string, key: string,
  errorType: string, okConstructor: string, okVariant: VariantSchema | undefined,
  errorConstructor: string | null,
): string[] {
  const lines: string[] = [];
  lines.push(`    pipe(`);
  lines.push(`      TE.tryCatch(`);
  lines.push(`        async () => {`);
  lines.push(`          await storage.put('${relation}', input.${key}, { ${inputFieldsToRecord(action)} });`);
  lines.push(`          return ${okConstructor}(${okFieldValues(action, okVariant, 'input')});`);
  lines.push(`        },`);
  lines.push(`        (error): ${errorType} => ({`);
  lines.push(`          code: 'STORAGE_ERROR',`);
  lines.push(`          message: error instanceof Error ? error.message : String(error),`);
  lines.push(`        }),`);
  lines.push(`      ),`);
  lines.push(`    ),`);
  return lines;
}

// --- Next.js Route Handler Adapter ---

function generateRouteFile(manifest: ConceptManifest): string {
  const conceptName = manifest.name;
  const kebabName = toKebabCase(conceptName);
  const lines: string[] = [
    fileHeader(conceptName, 'route.ts'),
    `// Next.js App Router Route Handler — maps HTTP to concept actions`,
    `// Place at: app/api/${kebabName}/route.ts`,
    '',
    `import { NextRequest, NextResponse } from 'next/server';`,
    `import * as TE from 'fp-ts/TaskEither';`,
    `import * as E from 'fp-ts/Either';`,
    `import { pipe } from 'fp-ts/function';`,
    '',
  ];

  // Import handler and types
  lines.push(`import type { ${conceptName}Handler, ${conceptName}Error } from './handler.js';`);
  lines.push(`import type { ${conceptName}Storage } from './types.js';`);
  lines.push('');

  // Error response helper
  lines.push(`const errorResponse = (error: ${conceptName}Error, status = 422): NextResponse =>`);
  lines.push(`  NextResponse.json({ errors: [{ code: error.code, message: error.message }] }, { status });`);
  lines.push('');

  // Success response helper
  lines.push(`const successResponse = <T>(data: T, status = 200): NextResponse =>`);
  lines.push(`  NextResponse.json(data, { status });`);
  lines.push('');

  // Route handler factory
  lines.push(`export const create${conceptName}Routes = (`);
  lines.push(`  handler: ${conceptName}Handler,`);
  lines.push(`  storage: ${conceptName}Storage,`);
  lines.push(`) => {`);
  lines.push('');

  // Dispatch function
  lines.push(`  const dispatch = async (action: string, input: Record<string, unknown>): Promise<NextResponse> => {`);
  lines.push(`    switch (action) {`);

  for (const action of manifest.actions) {
    lines.push(`      case '${action.name}': {`);
    lines.push(`        const result = await handler.${action.name}(input as any, storage)();`);
    lines.push(`        return pipe(`);
    lines.push(`          result,`);
    lines.push(`          E.fold(`);
    lines.push(`            (error) => errorResponse(error),`);
    lines.push(`            (output) => successResponse(output),`);
    lines.push(`          ),`);
    lines.push(`        );`);
    lines.push(`      }`);
  }

  lines.push(`      default:`);
  lines.push(`        return NextResponse.json(`);
  lines.push(`          { errors: [{ code: 'UNKNOWN_ACTION', message: \`Unknown action: \${action}\` }] },`);
  lines.push(`          { status: 404 },`);
  lines.push(`        );`);
  lines.push(`    }`);
  lines.push(`  };`);
  lines.push('');

  // POST handler (action dispatch)
  lines.push(`  const POST = async (request: NextRequest): Promise<NextResponse> => {`);
  lines.push(`    const body = await request.json() as { action: string; input: Record<string, unknown> };`);
  lines.push(`    return dispatch(body.action, body.input);`);
  lines.push(`  };`);
  lines.push('');

  // GET handler (list/get actions)
  const getActions = manifest.actions.filter(a =>
    a.name.startsWith('get') || a.name.startsWith('list') || a.name.startsWith('find') || a.name === 'all'
  );

  if (getActions.length > 0) {
    lines.push(`  const GET = async (request: NextRequest): Promise<NextResponse> => {`);
    lines.push(`    const { searchParams } = new URL(request.url);`);
    lines.push(`    const action = searchParams.get('action') ?? '${getActions[0].name}';`);
    lines.push(`    const input: Record<string, unknown> = {};`);
    lines.push(`    searchParams.forEach((value, key) => {`);
    lines.push(`      if (key !== 'action') input[key] = value;`);
    lines.push(`    });`);
    lines.push(`    return dispatch(action, input);`);
    lines.push(`  };`);
    lines.push('');
  }

  // Return exported handlers
  const exportedHandlers = ['POST'];
  if (getActions.length > 0) exportedHandlers.push('GET');

  lines.push(`  return { ${exportedHandlers.join(', ')} };`);
  lines.push(`};`);

  return lines.join('\n');
}

// --- Conformance Test File ---

function generateConformanceTestFile(manifest: ConceptManifest): string | null {
  if (manifest.invariants.length === 0) {
    return null;
  }

  const conceptName = manifest.name;
  const lines: string[] = [
    fileHeader(conceptName, 'conformance.test.ts'),
    `import { describe, it, expect } from 'vitest';`,
    `import * as TE from 'fp-ts/TaskEither';`,
    `import * as E from 'fp-ts/Either';`,
    `import { pipe } from 'fp-ts/function';`,
    '',
    `import { ${toCamelCase(conceptName)}Handler } from './handler.js';`,
    `import type { ${conceptName}Storage } from './types.js';`,
    '',
    `// In-memory storage for conformance tests`,
    `const createTestStorage = (): ${conceptName}Storage => {`,
    `  const store = new Map<string, Map<string, Record<string, unknown>>>();`,
    `  return {`,
    `    get: async (relation, key) => store.get(relation)?.get(key) ?? null,`,
    `    put: async (relation, key, value) => {`,
    `      if (!store.has(relation)) store.set(relation, new Map());`,
    `      store.get(relation)!.set(key, value);`,
    `    },`,
    `    delete: async (relation, key) => store.get(relation)?.delete(key) ?? false,`,
    `    find: async (relation) => [...(store.get(relation)?.values() ?? [])],`,
    `  };`,
    `};`,
    '',
  ];

  lines.push(`describe('${conceptName} conformance', () => {`);

  for (let invIdx = 0; invIdx < manifest.invariants.length; invIdx++) {
    const inv = manifest.invariants[invIdx];

    lines.push(`  it('${inv.description.replace(/'/g, "\\'")}', async () => {`);
    lines.push(`    const storage = createTestStorage();`);
    lines.push(`    const handler = ${toCamelCase(conceptName)}Handler;`);
    lines.push('');

    // Free variable declarations
    for (const fv of inv.freeVariables) {
      lines.push(`    const ${fv.name} = '${fv.testValue}';`);
    }
    lines.push('');

    // Setup steps (AFTER clause)
    for (const step of inv.setup) {
      lines.push(generateStepCode(step, conceptName, 'setup'));
    }

    // Assertion steps (THEN clause)
    for (const step of inv.assertions) {
      lines.push(generateStepCode(step, conceptName, 'assert'));
    }

    lines.push(`  });`);
    lines.push('');
  }

  lines.push(`});`);

  return lines.join('\n');
}

function generateStepCode(
  step: InvariantStep,
  conceptName: string,
  phase: 'setup' | 'assert',
): string {
  const lines: string[] = [];

  // Build input object
  const inputFields = step.inputs.map(input => {
    if (input.value.kind === 'literal') {
      const v = input.value.value;
      if (typeof v === 'string') return `      ${input.name}: '${v}',`;
      return `      ${input.name}: ${v},`;
    } else {
      return `      ${input.name}: ${input.value.name},`;
    }
  });

  lines.push(`    // ${phase}: ${step.action} -> ${step.expectedVariant}`);
  lines.push(`    const ${step.action}Result${phase === 'assert' ? 'Assert' : 'Setup'} = await pipe(`);
  lines.push(`      handler.${step.action}({`);
  lines.push(inputFields.join('\n'));
  lines.push(`      }, storage),`);
  lines.push(`      TE.map((output) => {`);
  lines.push(`        expect(output.variant).toBe('${step.expectedVariant}');`);

  // Assert expected output values
  for (const output of step.expectedOutputs) {
    if (output.value.kind === 'literal') {
      const v = output.value.value;
      if (typeof v === 'string') {
        lines.push(`        expect((output as any).${output.name}).toBe('${v}');`);
      } else {
        lines.push(`        expect((output as any).${output.name}).toBe(${v});`);
      }
    } else {
      lines.push(`        expect((output as any).${output.name}).toBe(${output.value.name});`);
    }
  }

  lines.push(`        return output;`);
  lines.push(`      }),`);
  lines.push(`    )();`);
  lines.push(`    expect(E.isRight(${step.action}Result${phase === 'assert' ? 'Assert' : 'Setup'})).toBe(true);`);
  lines.push('');

  return lines.join('\n');
}

// --- Handler Export ---

export const nextjsGenHandler: ConceptHandler = {
  async generate(input, storage) {
    const spec = input.spec as string;
    const manifest = input.manifest as ConceptManifest;

    if (!manifest || !manifest.name) {
      return { variant: 'error', message: 'Invalid manifest: missing concept name' };
    }

    try {
      const lowerName = toKebabCase(manifest.name);

      const files: { path: string; content: string }[] = [
        { path: `${lowerName}/types.ts`, content: generateTypesFile(manifest) },
        { path: `${lowerName}/handler.ts`, content: generateHandlerFile(manifest) },
        { path: `${lowerName}/route.ts`, content: generateRouteFile(manifest) },
      ];

      const conformanceTest = generateConformanceTestFile(manifest);
      if (conformanceTest) {
        files.push({ path: `${lowerName}/conformance.test.ts`, content: conformanceTest });
      }

      return { variant: 'ok', files };
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : String(err);
      return { variant: 'error', message };
    }
  },
};
