# Concept-Oriented Interface Framework (COIF)

## Architecture & Implementation Specification

**Version:** 0.3.0
**Date:** 2026-02-20
**Companion to:** COPF v0.19.0

### Changelog

| Version | Date | Summary |
|---------|------|---------|
| 0.1.0 | 2026-02-19 | Initial specification. 18 concepts across 4 kits. |
| 0.2.0 | 2026-02-19 | Concept Library integration. 4 renames (Token→DesignToken, Component→Widget, Renderer→FrameworkAdapter, Schema→UISchema) to resolve name collisions with library concepts. Replaces library FormBuilder, DisplayMode, ExposedFilter. 16 new cross-system syncs binding COIF to Library Schema, View, Validator, Workflow, EventBus, Notification, ContentParser, Intent. Core pipeline: UISchema → Element → Widget → FrameworkAdapter. |
| 0.3.0 | 2026-02-20 | COPF idiom alignment. Per-framework adapter concepts (ReactAdapter, SolidAdapter, VueAdapter, SvelteAdapter, InkAdapter, VanillaAdapter) mirror COPF's per-language gen pattern. New adapter-pipeline.sync mirrors compiler-pipeline.sync. Progressive customization ladder rewritten from JS APIs to concept DSL. Framework extension model now matches language extension model: concept spec + implementation + pipeline sync rule. |

---

## 1. Overview

COIF is the interface companion to COPF. Where COPF defines **what software does** — concepts with state, actions, and declarative synchronizations — COIF defines **how users interact with it**. COIF is built *on* COPF: every abstraction is a concept, every coordination is a sync, every bundle is a kit. But COIF can also function standalone with any backend that exposes typed operations.

COIF generates working interfaces from concept specs the way Django admin generates UIs from models — zero config gets you a functional interface, progressive customization gets you a beautiful one.

### 1.1 Design Principles

1. **Spec-derived.** Every COPF concept spec contains enough information to generate a default interface — field types map to input widgets, actions map to buttons and forms, state maps to displays. The interface is derived, never invented from scratch.

2. **Headless core.** All component behavior — state machines, accessibility, keyboard navigation, ARIA patterns — lives in framework-agnostic JavaScript. Rendering is a thin adapter layer. A COIF component works in React, Vue, Solid, Svelte, or a terminal without changing its behavioral core.

3. **Signals-native.** Each concept is an independent reactive unit using signals (aligned with TC39 proposal). When one concept's state changes, only UI bound to that concept re-renders. No global store, no cascading updates across unrelated concepts.

4. **Progressive customization.** Five levels, each additive: (0) zero-config auto-generated CRUD, (1) field-level configuration via UI schema, (2) view-level layout customization, (3) component-level replacement via slots, (4) full custom rendering with headless hooks. Most apps never pass level 2.

5. **Beautiful by default.** Design tokens encode a complete visual language — typography, color, spacing, motion, elevation — that produces polished interfaces without custom CSS. The token system is inspired by Material Design 3's reference → system → component hierarchy but is framework-independent.

6. **Concept-composed.** Interfaces compose via synchronizations, not rigid hierarchies. An auth concept's login form and a profile concept's avatar compose through syncs that declare "when login succeeds, show the profile surface" — the same mechanism COPF uses for backend coordination. No Atomic Design taxonomy debates.

7. **Deploy-anywhere.** The same concept interfaces work as a CDN-loaded script tag, a bundled npm package, a React Native component, a terminal UI via Ink, or an edge-rendered page. The deployment target is a configuration choice, not an architectural constraint.

### 1.2 System Anatomy

```
┌────────────────────────────────────────────────────────────────┐
│                     .concept specs                             │
│           (source of truth for data + behavior)                │
└──────────────────────────┬─────────────────────────────────────┘
                           │ inspects
                           ▼
┌────────────────────────────────────────────────────────────────┐
│                  UISchema Concept                              │
│     Reads concept spec → generates UI Schema + defaults        │
│     (field types → widgets, actions → controls, state → views) │
└──────────────────────────┬─────────────────────────────────────┘
                           │ produces
         ┌─────────────────┼─────────────────────┐
         ▼                 ▼                     ▼
  ┌─────────────┐  ┌──────────────┐     ┌──────────────┐
  │   Element   │  │ DesignToken  │     │   Binding    │
  │  (abstract  │  │  (design     │     │ (concept ↔   │
  │ interaction │  │  decisions   │     │  interface   │
  │   units)    │  │  as data)    │     │  mapping)    │
  └──────┬──────┘  └──────┬───────┘     └──────┬───────┘
         │                │                    │
         ▼                ▼                    ▼
  ┌────────────────────────────────────────────────────────┐
  │                   Widget Concept                     │
  │   Headless state machines + connect() props API         │
  │   (behavioral core — no rendering, no framework)        │
  │                                                         │
  │   ┌──────────┐  ┌──────────┐  ┌──────────┐            │
  │   │  Dialog   │  │  Form    │  │  List    │  ...       │
  │   │ machine  │  │ machine  │  │ machine  │            │
  │   └──────────┘  └──────────┘  └──────────┘            │
  └───────────────────────┬────────────────────────────────┘
                          │ connect()
         ┌────────────────┼──────────────────────┐
         ▼                ▼                      ▼
  ┌─────────────┐  ┌─────────────┐      ┌──────────────┐
  │   Adapter   │  │   Adapter   │      │    Adapter   │
  │  (React)    │  │  (Solid)    │      │   (Ink/TUI)  │
  │             │  │             │      │              │
  │  useCoif()  │  │ createCoif()│      │  useCoif()   │
  └──────┬──────┘  └──────┬──────┘      └──────┬───────┘
         │                │                    │
         ▼                ▼                    ▼
  ┌─────────────┐  ┌─────────────┐      ┌──────────────┐
  │  Surface    │  │  Surface    │      │   Surface    │
  │  (browser)  │  │  (browser)  │      │  (terminal)  │
  └─────────────┘  └─────────────┘      └──────────────┘
```

### 1.3 Key Distinctions from COPF

| Aspect | COPF | COIF |
|--------|------|------|
| Primary unit | Concept (state + actions) | Widget (behavior + presentation) |
| Coordination | Syncs (when/where/then) | Syncs (same mechanism) |
| Independence | Concepts never reference each other | Widgets never reference each other's internals |
| Composition | Via syncs only | Via syncs + slots (named insertion points) |
| Storage | Sovereign per-concept | Signals (reactive state per-concept) |
| Wire protocol | Action messages (JSON) | Props API (connect() output) |
| Query | GraphQL / Lite Query | Reactive subscriptions (signals) |

### 1.4 Standalone vs. Coupled Mode

**Standalone mode:** COIF manages its own state using signals. Components receive data through props, events trigger callbacks. No COPF backend required. Works like any headless component library.

```
[Any Backend] → REST/GraphQL → [COIF Widgets] → [FrameworkAdapter] → [UI]
```

**Coupled mode:** COIF binds directly to COPF concepts via the Binding concept. Concept state feeds signals automatically. Action invocations are wired to concept actions through syncs. The full reactive loop: concept state change → signal update → UI re-render → user action → concept action invocation → state change.

```
[COPF Concepts] ←→ [Binding] ←→ [COIF Widgets] → [FrameworkAdapter] → [UI]
```

The switch is a single deployment manifest flag. Widget code doesn't change.

---

## 2. The Specification Language Extensions

COIF extends COPF's `.concept` grammar with an optional `interface` section that declares how a concept's state and actions surface to users. This section is ignored by the COPF backend compiler — it's metadata consumed only by COIF's UISchema concept.

### 2.1 Grammar Extension

```
Section         = PurposeSection
                | StateSection
                | ActionSection
                | InvariantSection
                | CapabilitySection
                | InterfaceSection          -- NEW: COIF extension

InterfaceSection = "interface" "{" InterfaceEntry* "}"

InterfaceEntry  = FieldMapping | ActionMapping | ViewMapping

FieldMapping    = "field" IDENT "{" FieldProp* "}"
FieldProp       = IDENT ":" (STRING_LIT | IDENT | "{" FieldProp* "}") SEP?

ActionMapping   = "action" IDENT "{" ActionProp* "}"
ActionProp      = IDENT ":" (STRING_LIT | IDENT | "{" ActionProp* "}") SEP?

ViewMapping     = "view" IDENT "{" ViewProp* "}"
ViewProp        = IDENT ":" (STRING_LIT | IDENT | "{" ViewProp* "}") SEP?
```

### 2.2 Example: Annotated Concept

```
@version(1)
concept Article [A, U] {

  purpose {
    A publishable piece of content with title, body,
    author attribution, and timestamps.
  }

  state {
    title: A -> String
    body: A -> String
    author: A -> U
    createdAt: A -> DateTime
    updatedAt: A -> DateTime
    published: A -> Bool
  }

  actions {
    action create(article: A, title: String, body: String, author: U) {
      -> ok(article: A) { Create the article with timestamps. }
      -> invalid(message: String) { Validation failed. }
    }
    action update(article: A, title: option String, body: option String) {
      -> ok(article: A) { Update fields, touch updatedAt. }
      -> notfound(message: String) { Article doesn't exist. }
    }
    action publish(article: A) {
      -> ok(article: A) { Set published to true. }
      -> notfound(message: String) { Article doesn't exist. }
    }
    action delete(article: A) {
      -> ok(article: A) { Remove the article. }
      -> notfound(message: String) { Article doesn't exist. }
    }
  }

  interface {
    field title {
      widget: "text-input"
      label: "Title"
      placeholder: "Enter article title..."
      validation: { minLength: "1"; maxLength: "200" }
    }
    field body {
      widget: "rich-text"
      label: "Body"
      placeholder: "Write your article..."
    }
    field published {
      widget: "toggle"
      label: "Published"
    }
    field createdAt {
      widget: "datetime-display"
      label: "Created"
      readOnly: "true"
    }
    action create {
      label: "Create Article"
      icon: "plus"
      variant: "primary"
    }
    action publish {
      label: "Publish"
      icon: "send"
      variant: "accent"
      confirm: "Are you sure you want to publish this article?"
    }
    action delete {
      label: "Delete"
      icon: "trash"
      variant: "danger"
      confirm: "This action cannot be undone."
    }
    view list {
      columns: "title, author, published, updatedAt"
      defaultSort: "updatedAt"
      sortDirection: "desc"
      searchable: "title, body"
    }
    view detail {
      layout: "title, body, published, author, createdAt, updatedAt"
      actions: "update, publish, delete"
    }
    view create {
      fields: "title, body"
      submit: "create"
    }
  }

  invariant {
    after create(article: x, title: "Test", body: "Content", author: u)
      -> ok(article: x)
    then publish(article: x) -> ok(article: x)
  }
}
```

### 2.3 Interface Section Design Notes

The `interface` section is deliberately **flat and declarative** — key-value pairs, not a programming language. This is intentional:

- **LLMs can generate it** from natural language descriptions.
- **Non-developers can read it** — a designer can understand `widget: "rich-text"` and `variant: "primary"`.
- **It's override-friendly** — the UISchema concept generates defaults for every field/action, and the interface section overrides only what needs customization.
- **It's forward-compatible** — new widget types and properties can be added without grammar changes since values are strings parsed by the UISchema concept, not the spec compiler.

Fields not mentioned in the `interface` section get auto-generated defaults based on type mapping rules (see Section 8).

---

## 3. Core Concepts

COIF is implemented as 18 concepts organized into 4 kits. Every concept follows COPF's spec format — sovereign storage, typed actions with return variants, no inter-concept references.

### Concept Overview

**coif-core kit** (foundation — always loaded):

| Concept | Purpose |
|---------|---------|
| DesignToken | Store design decisions as structured, platform-agnostic data |
| Element | Abstract, modality-independent interaction units |
| UISchema | Inspect concept specs → generate UI schemas |
| Binding | Map COPF concept state/actions to interface signals |
| Signal | Reactive state container for concept data |

**coif-component kit** (headless behaviors):

| Concept | Purpose |
|---------|---------|
| Widget | Headless state machine catalog for UI widgets |
| Machine | Finite state machine runtime for component behavior |
| Anatomy | Named parts contract between behavior and rendering |
| Slot | Named insertion points for composition |

**coif-render kit** (framework adapters):

| Concept | Purpose |
|---------|---------|
| FrameworkAdapter | Framework adapter registry and lifecycle |
| Surface | Deployment target (browser DOM, terminal, native) |
| Layout | Spatial arrangement of components on a surface |
| Viewport | Responsive breakpoint and adaptation logic |

**coif-theme kit** (visual design):

| Concept | Purpose |
|---------|---------|
| Theme | Compose tokens into a complete visual language |
| Palette | Color system with semantic roles and accessibility |
| Typography | Type scale, font stacks, and text styles |
| Motion | Animation timing, easing, and transition definitions |
| Elevation | Shadow and depth system |

### 3.1 DesignToken

```
@version(1)
concept DesignToken [T] {

  purpose {
    Store design decisions as structured, platform-agnostic data.
    Tokens are the atomic unit of visual design — a color value,
    a spacing size, a font family. They form a three-tier
    hierarchy: primitive (raw values), semantic (meaning/purpose),
    and component (bound to specific UI elements). Follows the
    W3C Design Tokens Community Group specification (2025.10).
  }

  state {
    name: T -> String
    value: T -> String
    type: T -> String
    tier: T -> String
    description: T -> option String
    reference: T -> option T
    group: T -> option String
    extensions: T -> option String
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action define(token: T, name: String, value: String, type: String, tier: String) {
      -> ok(token: T) {
        Register a new token. Type is one of: color, dimension,
        fontFamily, fontWeight, duration, cubicBezier, shadow,
        border, typography, gradient. Tier is one of: primitive,
        semantic, component.
      }
      -> duplicate(message: String) {
        A token with this name already exists in this group.
      }
    }

    action alias(token: T, name: String, reference: T, tier: String) {
      -> ok(token: T) {
        Create a token that references another token's value.
        The alias resolves at consumption time, enabling theming
        by remapping semantic tokens to different primitives.
      }
      -> notfound(message: String) { The referenced token does not exist. }
      -> cycle(message: String) { The alias would create a circular reference chain. }
    }

    action resolve(token: T) {
      -> ok(token: T, resolvedValue: String) {
        Walk the reference chain and return the final concrete value.
      }
      -> notfound(message: String) { The token does not exist. }
      -> broken(message: String, brokenAt: T) { The reference chain is broken. }
    }

    action update(token: T, value: option String) {
      -> ok(token: T) { Update the token's value or reference target. }
      -> notfound(message: String) { The token does not exist. }
    }

    action remove(token: T) {
      -> ok(token: T) { Delete the token. Aliases pointing here become broken. }
      -> notfound(message: String) { The token does not exist. }
    }

    action export(format: String) {
      -> ok(output: String) {
        Export all tokens. Formats: "dtcg" (W3C JSON), "css"
        (Custom Properties), "swift", "kotlin", "json".
      }
      -> unsupported(message: String) { Format not supported. }
    }
  }

  invariant {
    after define(token: t, name: "blue-500", value: "#3b82f6",
                 type: "color", tier: "primitive") -> ok(token: t)
    then resolve(token: t) -> ok(token: t, resolvedValue: "#3b82f6")
  }
}
```

### 3.2 Element

```
@version(1)
concept Element [E] {

  purpose {
    Abstract, modality-independent interaction units. An Element
    describes WHAT a user can do — select, input, trigger, navigate,
    display — without specifying HOW it renders. Drawn from the
    CAMELEON Reference Framework's Abstract Interaction Objects.
    The same Element renders as a dropdown in GUI, a prompt in CLI,
    an enum in API, or a picker in mobile.
  }

  state {
    kind: E -> String
    label: E -> String
    description: E -> option String
    dataType: E -> String
    required: E -> Bool
    constraints: E -> option String
    children: E -> list E
    parent: E -> option E
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action create(element: E, kind: String, label: String, dataType: String) {
      -> ok(element: E) {
        Create an abstract element. Kind is one of:
        input-text, input-number, input-date, input-bool,
        selection-single, selection-multi, trigger, navigation,
        output-text, output-number, output-date, output-bool,
        group, container, rich-text, file-upload, media-display.
      }
      -> invalid(message: String) { The kind is not recognized. }
    }

    action nest(parent: E, child: E) {
      -> ok(parent: E) { Add a child to a group or container. }
      -> invalid(message: String) { Parent cannot contain children. }
    }

    action setConstraints(element: E, constraints: String) {
      -> ok(element: E) {
        Apply constraints as JSON: min, max, minLength,
        maxLength, pattern, options (for selections).
      }
      -> notfound(message: String) { Element does not exist. }
    }

    action remove(element: E) {
      -> ok(element: E) { Remove element and detach children. }
      -> notfound(message: String) { Element does not exist. }
    }
  }

  invariant {
    after create(element: e, kind: "input-text", label: "Title",
                 dataType: "String") -> ok(element: e)
    then remove(element: e) -> ok(element: e)
  }
}
```

### 3.3 UISchema

```
@version(1)
concept UISchema [S, C] {

  purpose {
    Inspect a COPF concept spec and generate a UI schema — the
    complete description of how that concept should be presented.
    Implements the dual-schema pattern: data schema (from .concept
    spec) is the source, UI schema (generated here) is the
    presentation layer. This is the Metawidget-style inspection
    pipeline: inspect → apply defaults → apply overrides → produce
    element tree.
  }

  state {
    concept: S -> C
    elements: S -> list String
    uiSchema: S -> String
    overrides: S -> option String
    generatedAt: S -> DateTime
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action inspect(schema: S, conceptSpec: String) {
      -> ok(schema: S) {
        Parse the concept spec. Extract state fields, actions, and
        return variants. Apply type-mapping rules (String → input-text,
        Int → input-number, Bool → toggle, etc.). Generate default
        views: list, detail, create, edit. If spec contains an
        interface section, apply overrides on top of defaults.
      }
      -> parseError(message: String) { The concept spec could not be parsed. }
    }

    action override(schema: S, overrides: String) {
      -> ok(schema: S) {
        Apply partial UI schema on top of the generated one.
        Merges at field/action/view level — only specified
        properties are replaced.
      }
      -> notfound(message: String) { No schema exists for this concept. }
      -> invalid(message: String) { Override JSON is malformed. }
    }

    action getSchema(schema: S) {
      -> ok(schema: S, uiSchema: String) { Return current UI schema as JSON. }
      -> notfound(message: String) { No schema exists. }
    }

    action getElements(schema: S) {
      -> ok(elements: String) {
        Return abstract element tree as JSON — intermediate
        representation consumed by Widget concept.
      }
      -> notfound(message: String) { No schema exists. }
    }
  }

  invariant {
    after inspect(schema: s, conceptSpec: "concept Test [T] { state { name: T -> String } actions { action create(t: T, name: String) { -> ok(t: T) { Create it. } } } }")
      -> ok(schema: s)
    then getSchema(schema: s) -> ok(schema: s, uiSchema: _)
  }
}
```

### 3.4 Binding

```
@version(1)
concept Binding [B, C] {

  purpose {
    Bridge between COPF backend concepts and COIF frontend
    signals. In coupled mode, subscribes to concept state changes
    via COPF's action completion stream and pushes updates to
    signals. Routes user-triggered actions back as invocations.
    In standalone mode, wraps a data source (REST, GraphQL,
    static) and presents it through the same signal interface.
  }

  state {
    concept: B -> C
    mode: B -> String
    endpoint: B -> option String
    lastSync: B -> option DateTime
    status: B -> String
    signalMap: B -> String
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action bind(binding: B, concept: C, mode: String) {
      -> ok(binding: B) {
        Create a binding. Mode: "coupled" (direct COPF engine),
        "rest" (REST API), "graphql" (subscription),
        "static" (in-memory). Generates signal map: one signal
        per state field, one command per action.
      }
      -> invalid(message: String) { Mode not recognized or concept unreachable. }
    }

    action sync(binding: B) {
      -> ok(binding: B) { Pull latest state and update signals. }
      -> error(message: String) { Backend unreachable. }
    }

    action invoke(binding: B, action: String, input: String) {
      -> ok(binding: B, result: String) {
        Invoke an action on the bound concept. Routes to
        appropriate backend based on mode. Returns completion.
      }
      -> error(message: String) { Invocation failed. }
    }

    action unbind(binding: B) {
      -> ok(binding: B) { Remove binding, unsubscribe, dispose signals. }
      -> notfound(message: String) { Binding does not exist. }
    }
  }

  invariant {
    after bind(binding: b, concept: c, mode: "static")
      -> ok(binding: b)
    then unbind(binding: b) -> ok(binding: b)
  }
}
```

### 3.5 Signal

```
@version(1)
concept Signal [G] {

  purpose {
    Reactive state container aligned with TC39 Signals proposal.
    A getter/setter pair with automatic dependency tracking. When
    a signal's value changes, all computed signals and effects that
    read from it re-execute — and only those. Each concept binding
    produces one signal per state field. Signals are runtime-only.
  }

  state {
    value: G -> String
    kind: G -> String
    dependencies: G -> set G
    subscribers: G -> set G
    version: G -> Int
  }

  actions {
    action create(signal: G, kind: String, initialValue: String) {
      -> ok(signal: G) {
        Create a signal. Kind: "state" (writable), "computed"
        (read-only derived), "effect" (side-effect on change).
      }
      -> invalid(message: String) { Kind not recognized. }
    }

    action read(signal: G) {
      -> ok(signal: G, value: String, version: Int) {
        Read current value and register caller as dependency.
      }
      -> notfound(message: String) { Signal does not exist. }
    }

    action write(signal: G, value: String) {
      -> ok(signal: G, version: Int) {
        Update value, increment version, notify subscribers.
        Notifications batched within a microtask.
      }
      -> readonly(message: String) { Cannot write to computed signal. }
      -> notfound(message: String) { Signal does not exist. }
    }

    action batch(signals: String) {
      -> ok(count: Int) {
        Update multiple signals atomically. Subscribers notified
        once after all updates, not per-signal.
      }
      -> partial(message: String, succeeded: Int, failed: Int) {
        Some updates failed.
      }
    }

    action dispose(signal: G) {
      -> ok(signal: G) { Remove signal, unsubscribe from dependencies. }
      -> notfound(message: String) { Signal does not exist. }
    }
  }

  invariant {
    after create(signal: g, kind: "state", initialValue: "hello")
      -> ok(signal: g)
    then read(signal: g) -> ok(signal: g, value: "hello", version: _)
  }
}
```

### 3.6 Widget

```
@version(1)
concept Widget [P] {

  purpose {
    Headless state machine catalog. Each component type is a named
    behavioral specification — complete widget logic without rendering.
    Inspired by Zag.js: components are finite state machines that
    produce a props API via connect(), consumable by any framework.
    Standard library: button, input, textarea, select, checkbox,
    radio, toggle, dialog, popover, tooltip, tabs, accordion, menu,
    combobox, datepicker, slider, toast, alert, table, form,
    listview, card, avatar, badge, breadcrumb, pagination, progress,
    skeleton, spinner.
  }

  state {
    name: P -> String
    anatomy: P -> String
    defaultConfig: P -> String
    machineSpec: P -> String
    a11ySpec: P -> String
    category: P -> String
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action register(component: P, name: String, machineSpec: String,
                    anatomy: String, a11ySpec: String) {
      -> ok(component: P) {
        Register a component type. machineSpec: JSON state machine
        (states, transitions, guards, actions). anatomy: named parts.
        a11ySpec: ARIA attributes, keyboard interactions, focus management.
      }
      -> duplicate(message: String) { Already registered. }
    }

    action configure(component: P, config: String) {
      -> ok(component: P) { Set default config (initial machine context). }
      -> notfound(message: String) { Not registered. }
    }

    action get(component: P) {
      -> ok(component: P, machineSpec: String, anatomy: String, a11ySpec: String) {
        Retrieve full specification for instantiation.
      }
      -> notfound(message: String) { Not registered. }
    }

    action list(category: option String) {
      -> ok(components: String) {
        List registered types. Categories: input, display,
        overlay, navigation, feedback, layout, composite.
      }
    }

    action unregister(component: P) {
      -> ok(component: P) { Remove from registry. }
      -> notfound(message: String) { Not registered. }
    }
  }

  invariant {
    after register(component: p, name: "button",
                   machineSpec: "{ \"initial\": \"idle\" }",
                   anatomy: "{ \"parts\": [\"root\"] }",
                   a11ySpec: "{ \"role\": \"button\" }")
      -> ok(component: p)
    then get(component: p) -> ok(component: p, machineSpec: _, anatomy: _, a11ySpec: _)
  }
}
```

### 3.7 Machine

```
@version(1)
concept Machine [M] {

  purpose {
    Finite state machine runtime. Instantiates and executes
    behavioral state machines defined by Widget. A Machine
    instance holds current state, processes events, executes
    guards and actions, and produces output via connect().

    The connect() function transforms machine state into a
    framework-neutral props API. For a dialog in "open" state:
    { getRootProps(), getTriggerProps(), getContentProps(),
      isOpen: true, open(), close() }

    These props are plain objects — no framework dependency.
    Each FrameworkAdapter transforms them into framework bindings.
  }

  state {
    current: M -> String
    context: M -> String
    component: M -> String
    status: M -> String
  }

  actions {
    action spawn(machine: M, component: String, context: String) {
      -> ok(machine: M) {
        Create machine instance from registered component type.
        Initialize with component defaults merged with context.
      }
      -> notfound(message: String) { Widget type not registered. }
    }

    action send(machine: M, event: String) {
      -> ok(machine: M, state: String) {
        Send event to machine. Evaluates transitions from current
        state: checks guards, executes actions, moves to target.
        Events: { "type": "OPEN" } or { "type": "SET_VALUE", "value": "..." }
      }
      -> invalid(message: String) { Event not valid in current state. }
      -> notfound(message: String) { Machine does not exist. }
    }

    action connect(machine: M) {
      -> ok(machine: M, props: String) {
        Produce framework-neutral props API. JSON object where keys
        are anatomy part names and values are prop objects with
        event handlers, ARIA attributes, data attributes, state flags.
      }
      -> notfound(message: String) { Machine does not exist. }
    }

    action destroy(machine: M) {
      -> ok(machine: M) { Tear down, run exit actions, clean up timers. }
      -> notfound(message: String) { Machine does not exist. }
    }
  }

  invariant {
    after spawn(machine: m, component: "dialog",
                context: "{ \"open\": false }")
      -> ok(machine: m)
    then connect(machine: m) -> ok(machine: m, props: _)
  }
}
```

### 3.8 Anatomy

```
@version(1)
concept Anatomy [N] {

  purpose {
    Named parts contract between component behavior and rendering.
    Every headless component declares its anatomy — the named
    elements constituting its structure. A Dialog's anatomy:
    root, trigger, backdrop, positioner, content, title,
    description, closeTrigger. This is the Ark UI/Zag contract:
    behavior and rendering agree on part names, nothing else.
  }

  state {
    component: N -> String
    parts: N -> list String
    slots: N -> list String
    description: N -> option String
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action define(anatomy: N, component: String, parts: String, slots: String) {
      -> ok(anatomy: N) {
        Define anatomy for a component type. Parts: JSON array
        of part names. Slots: JSON array of insertion points.
      }
      -> duplicate(message: String) { Already defined. }
    }

    action getParts(anatomy: N) {
      -> ok(parts: String) { Return ordered part names. }
      -> notfound(message: String) { Not defined. }
    }

    action getSlots(anatomy: N) {
      -> ok(slots: String) { Return available slots. }
      -> notfound(message: String) { Not defined. }
    }

    action extend(anatomy: N, additionalParts: String) {
      -> ok(anatomy: N) { Add parts for component variants. }
      -> notfound(message: String) { Not defined. }
    }
  }

  invariant {
    after define(anatomy: n, component: "dialog",
                 parts: "[\"root\",\"trigger\",\"content\",\"title\"]",
                 slots: "[\"header\",\"body\",\"footer\"]")
      -> ok(anatomy: n)
    then getParts(anatomy: n)
      -> ok(parts: "[\"root\",\"trigger\",\"content\",\"title\"]")
  }
}
```

### 3.9 Slot

```
@version(1)
concept Slot [L] {

  purpose {
    Named insertion points for component composition. Enables the
    compound component pattern without coupling. Replaces Atomic
    Design's rigid hierarchy with flexible, on-demand composition.
    Supports named slots, default slots, and scoped slots.
  }

  state {
    name: L -> String
    component: L -> String
    defaultContent: L -> option String
    scope: L -> option String
    filled: L -> Bool
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action define(slot: L, name: String, component: String) {
      -> ok(slot: L) { Define a slot on a component. }
      -> invalid(message: String) { Anatomy does not include this slot. }
    }

    action fill(slot: L, content: String) {
      -> ok(slot: L) {
        Fill with content: component reference, raw content,
        or scoped render function key.
      }
      -> notfound(message: String) { Slot does not exist. }
    }

    action setDefault(slot: L, defaultContent: String) {
      -> ok(slot: L) { Set fallback content when no fill provided. }
      -> notfound(message: String) { Slot does not exist. }
    }

    action clear(slot: L) {
      -> ok(slot: L) { Remove fill, revert to default. }
      -> notfound(message: String) { Slot does not exist. }
    }
  }

  invariant {
    after define(slot: l, name: "header", component: "card")
      -> ok(slot: l)
    then fill(slot: l, content: "{ \"type\": \"text\", \"value\": \"Hello\" }")
      -> ok(slot: l)
  }
}
```

### 3.10 FrameworkAdapter

```
@version(1)
concept FrameworkAdapter [R] {

  purpose {
    Framework adapter registry and lifecycle management. Tracks which
    framework adapters are available, their status, and mount targets.
    Each registered framework has a corresponding adapter concept
    (ReactAdapter, SolidAdapter, etc.) that handles the actual
    prop normalization — this concept manages the registry only.
    Mirrors COPF's Registry concept: registration, discovery,
    and lifecycle management without domain logic.
  }

  state {
    framework: R -> String
    version: R -> String
    status: R -> String
    normalizer: R -> String
    mountFn: R -> String
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action register(renderer: R, framework: String, version: String,
                    normalizer: String, mountFn: String) {
      -> ok(renderer: R) {
        Register adapter. Framework: "react", "solid", "vue",
        "svelte", "ink", "vanilla", "react-native", "angular".
      }
      -> duplicate(message: String) { Already registered. }
    }

    action normalize(renderer: R, props: String) {
      -> ok(normalized: String) { Transform to framework-specific bindings. }
      -> notfound(message: String) { Not registered. }
    }

    action mount(renderer: R, machine: String, target: String) {
      -> ok(renderer: R) { Create and mount component tree. }
      -> error(message: String) { Mount failed. }
    }

    action unmount(renderer: R, target: String) {
      -> ok(renderer: R) { Unmount and clean up. }
      -> notfound(message: String) { Nothing mounted at target. }
    }
  }

  invariant {
    after register(renderer: r, framework: "react", version: "19",
                   normalizer: "reactNormalizer", mountFn: "reactMount")
      -> ok(renderer: r)
    then normalize(renderer: r, props: "{ \"onClick\": \"handler_1\" }")
      -> ok(normalized: _)
  }
}
```

### 3.10.1 Per-Framework Adapter Concepts

Each supported framework has its own adapter concept that handles prop normalization. This mirrors COPF's per-language gen pattern: just as `TypeScriptGen`, `RustGen`, and `SwiftGen` each consume a `ConceptManifest` to produce language-specific code, each framework adapter concept consumes framework-neutral props (from `Machine/connect`) to produce framework-specific bindings.

Adding a new framework requires creating a new adapter concept + one sync rule in the adapter pipeline — no existing code changes. This is the same extension model as adding a new COPF language target.

**Pattern (same for all framework adapters):**

```
@version(1)
concept <Framework>Adapter [A] {

  purpose {
    Normalize framework-neutral props into <Framework>-specific
    bindings. Transforms COIF's generic event model into
    <Framework> conventions.
  }

  state {
    outputs: A -> String
  }

  actions {
    action normalize(adapter: A, props: String) {
      -> ok(adapter: A, normalized: String) {
        Map framework-neutral props to <Framework> bindings.
      }
      -> error(message: String) {
        Props contain patterns not mappable to <Framework>.
      }
    }
  }

  invariant {
    after normalize(adapter: a,
                    props: "{ \"onclick\": \"handler_1\", \"class\": \"btn\" }")
      -> ok(adapter: a, normalized: _)
  }
}
```

**Shipped adapters:** ReactAdapter, SolidAdapter, VueAdapter, SvelteAdapter, InkAdapter, VanillaAdapter.

### 3.11 Surface

```
@version(1)
concept Surface [F] {

  purpose {
    Deployment target. A Surface represents where the interface
    renders — browser DOM, terminal, native view, API endpoint.
    Handles initialization, capability detection, and lifecycle.
  }

  state {
    kind: F -> String
    capabilities: F -> set String
    status: F -> String
    mountPoint: F -> option String
    config: F -> option String
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action create(surface: F, kind: String, mountPoint: option String) {
      -> ok(surface: F) {
        Create surface. Kind: "browser-dom", "terminal",
        "react-native", "webview", "ssr", "static-html".
        Auto-detects capabilities.
      }
      -> unsupported(message: String) { Kind not supported in this runtime. }
    }

    action attach(surface: F, renderer: String) {
      -> ok(surface: F) { Attach renderer, validate compatibility. }
      -> incompatible(message: String) { FrameworkAdapter incompatible with surface. }
    }

    action resize(surface: F, width: Int, height: Int) {
      -> ok(surface: F) { Report size change, trigger viewport recalc. }
      -> notfound(message: String) { Surface does not exist. }
    }

    action destroy(surface: F) {
      -> ok(surface: F) { Tear down, unmount all renderers. }
      -> notfound(message: String) { Surface does not exist. }
    }
  }

  invariant {
    after create(surface: f, kind: "browser-dom", mountPoint: "#app")
      -> ok(surface: f)
    then destroy(surface: f) -> ok(surface: f)
  }
}
```

### 3.12 Layout

```
@version(1)
concept Layout [Y] {

  purpose {
    Spatial arrangement of components. Describes positioning
    without specifying CSS or terminal coordinates — constraint-based
    descriptions interpreted per-Surface. Layouts compose recursively:
    a page layout contains region layouts containing component layouts.
  }

  state {
    name: Y -> String
    kind: Y -> String
    direction: Y -> option String
    gap: Y -> option String
    columns: Y -> option String
    rows: Y -> option String
    areas: Y -> option String
    children: Y -> list Y
    responsive: Y -> option String
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action create(layout: Y, name: String, kind: String) {
      -> ok(layout: Y) {
        Create layout. Kind: "stack", "grid", "split", "overlay",
        "flow", "sidebar", "center".
      }
      -> invalid(message: String) { Kind not recognized. }
    }

    action configure(layout: Y, config: String) {
      -> ok(layout: Y) {
        Apply config: direction, gap (token ref), columns/rows,
        areas, alignment, padding.
      }
      -> notfound(message: String) { Layout does not exist. }
    }

    action nest(parent: Y, child: Y) {
      -> ok(parent: Y) { Nest layout inside another. }
      -> cycle(message: String) { Would create circular reference. }
    }

    action setResponsive(layout: Y, breakpoints: String) {
      -> ok(layout: Y) {
        Define responsive overrides keyed by breakpoint (sm, md, lg, xl).
      }
      -> notfound(message: String) { Layout does not exist. }
    }

    action remove(layout: Y) {
      -> ok(layout: Y) { Remove and detach children. }
      -> notfound(message: String) { Layout does not exist. }
    }
  }

  invariant {
    after create(layout: y, name: "main", kind: "sidebar")
      -> ok(layout: y)
    then configure(layout: y, config: "{ \"direction\": \"row\", \"gap\": \"space-4\" }")
      -> ok(layout: y)
  }
}
```

### 3.13 Viewport

```
@version(1)
concept Viewport [V] {

  purpose {
    Responsive breakpoint and adaptation. Observes surface dimensions,
    evaluates breakpoint conditions, produces active breakpoints for
    Layout and Widget via signals. Defaults: xs (0-479), sm (480-767),
    md (768-1023), lg (1024-1279), xl (1280+).
  }

  state {
    width: V -> Int
    height: V -> Int
    breakpoint: V -> String
    orientation: V -> String
    customBreakpoints: V -> option String
  }

  actions {
    action observe(viewport: V, width: Int, height: Int) {
      -> ok(viewport: V, breakpoint: String, orientation: String) {
        Report dimensions, return active breakpoint and orientation.
      }
    }

    action setBreakpoints(viewport: V, breakpoints: String) {
      -> ok(viewport: V) { Override defaults. }
      -> invalid(message: String) { Values must be ascending positive integers. }
    }

    action getBreakpoint(viewport: V) {
      -> ok(viewport: V, breakpoint: String, width: Int, height: Int) {
        Return current breakpoint and dimensions.
      }
      -> notfound(message: String) { Viewport not initialized. }
    }
  }

  invariant {
    after observe(viewport: v, width: 1024, height: 768)
      -> ok(viewport: v, breakpoint: "lg", orientation: "landscape")
    then getBreakpoint(viewport: v)
      -> ok(viewport: v, breakpoint: "lg", width: 1024, height: 768)
  }
}
```

### 3.14 Theme

```
@version(1)
concept Theme [H] {

  purpose {
    Compose tokens into a complete visual language. A Theme is a
    named collection of token overrides: "dark" remaps color-background
    from white to gray-900. Themes are layered: base + variants.
    Multiple variants can be active (dark + compact + high-contrast).
    Conflicts resolve by specificity then activation order.
  }

  state {
    name: H -> String
    base: H -> option H
    overrides: H -> String
    active: H -> Bool
    priority: H -> Int
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action create(theme: H, name: String, overrides: String) {
      -> ok(theme: H) { Create theme with token overrides JSON. }
      -> duplicate(message: String) { Already exists. }
    }

    action extend(theme: H, base: H, overrides: String) {
      -> ok(theme: H) { Create theme extending a base. }
      -> notfound(message: String) { Base does not exist. }
    }

    action activate(theme: H, priority: Int) {
      -> ok(theme: H) { Activate — overrides take effect immediately. }
      -> notfound(message: String) { Does not exist. }
    }

    action deactivate(theme: H) {
      -> ok(theme: H) { Deactivate — values revert. }
      -> notfound(message: String) { Does not exist. }
    }

    action resolve(theme: H) {
      -> ok(tokens: String) {
        Return fully resolved token map: all base + overrides,
        aliases resolved to final values.
      }
      -> notfound(message: String) { Does not exist. }
    }
  }

  invariant {
    after create(theme: h, name: "dark",
                 overrides: "{ \"color-bg\": \"#1a1a1a\" }")
      -> ok(theme: h)
    then activate(theme: h, priority: 1) -> ok(theme: h)
    and resolve(theme: h) -> ok(tokens: _)
  }
}
```

### 3.15 Palette

```
@version(1)
concept Palette [C] {

  purpose {
    Color system with semantic roles and WCAG accessibility enforcement.
    Generates complete 50-950 color scales from seed colors using
    perceptual color space (OKLCH). Every color pair validated against
    WCAG 2.1: AA (4.5:1 normal, 3:1 large) and AAA (7:1 normal).
  }

  state {
    name: C -> String
    hue: C -> Float
    scale: C -> String
    role: C -> option String
    contrastRatio: C -> option Float
  }

  actions {
    action generate(palette: C, name: String, seed: String) {
      -> ok(palette: C, scale: String) {
        Generate 50-950 color scale from seed using OKLCH.
      }
      -> invalid(message: String) { Not a valid color. }
    }

    action assignRole(palette: C, role: String) {
      -> ok(palette: C) {
        Assign semantic role: primary, secondary, accent, success,
        warning, error, neutral, surface. Auto-generates semantic tokens.
      }
      -> notfound(message: String) { Palette does not exist. }
    }

    action checkContrast(foreground: C, background: C) {
      -> ok(ratio: Float, passesAA: Bool, passesAAA: Bool) {
        Calculate contrast ratio and report WCAG compliance.
      }
      -> notfound(message: String) { Color not found. }
    }
  }

  invariant {
    after generate(palette: c, name: "blue", seed: "#3b82f6")
      -> ok(palette: c, scale: _)
    then assignRole(palette: c, role: "primary") -> ok(palette: c)
  }
}
```

### 3.16 Typography

```
@version(1)
concept Typography [X] {

  purpose {
    Type scale, font stacks, and text styles. Generates harmonious
    type scale from modular ratio (default: major third, 1.25).
    Composes scale sizes with font stacks and weights into named
    presets: heading-1, body, caption, label, code.
  }

  state {
    name: X -> String
    kind: X -> String
    value: X -> String
    scale: X -> option String
  }

  actions {
    action defineScale(typography: X, baseSize: Float, ratio: Float, steps: Int) {
      -> ok(typography: X, scale: String) {
        Generate type scale: { "xs": 12, "sm": 14, "base": 16, ... }
      }
      -> invalid(message: String) { Base must be positive, ratio > 1. }
    }

    action defineFontStack(typography: X, name: String, fonts: String, category: String) {
      -> ok(typography: X) { Register font stack. Category: serif, sans-serif, monospace, display. }
      -> duplicate(message: String) { Already exists. }
    }

    action defineStyle(typography: X, name: String, config: String) {
      -> ok(typography: X) {
        Create named text style: { "scale": "xl", "fontStack": "heading",
        "weight": 700, "lineHeight": 1.2, "letterSpacing": "-0.02em" }
      }
      -> invalid(message: String) { Referenced scale or fontStack not found. }
    }
  }

  invariant {
    after defineScale(typography: x, baseSize: 16, ratio: 1.25, steps: 6)
      -> ok(typography: x, scale: _)
    then defineStyle(typography: x, name: "heading-1",
                     config: "{ \"scale\": \"3xl\", \"weight\": 700 }")
      -> ok(typography: x)
  }
}
```

### 3.17 Motion

```
@version(1)
concept Motion [O] {

  purpose {
    Animation timing, easing, and transitions. All values are
    named, referenceable, and overridable via themes. Respects
    prefers-reduced-motion: all durations collapse to 0ms.
  }

  state {
    name: O -> String
    kind: O -> String
    value: O -> String
    reducedMotion: O -> option String
  }

  actions {
    action defineDuration(motion: O, name: String, ms: Int) {
      -> ok(motion: O) {
        Named duration. Standard: instant (0), fast (100),
        normal (200), slow (300), slower (500).
      }
      -> invalid(message: String) { Must be non-negative. }
    }

    action defineEasing(motion: O, name: String, value: String) {
      -> ok(motion: O) { Named easing curve (CSS cubic-bezier or keyword). }
      -> invalid(message: String) { Invalid easing value. }
    }

    action defineTransition(motion: O, name: String, config: String) {
      -> ok(motion: O) {
        Named transition preset: { "property": "opacity",
        "duration": "normal", "easing": "ease-out" }
      }
      -> invalid(message: String) { Referenced duration or easing not found. }
    }
  }

  invariant {
    after defineDuration(motion: o, name: "normal", ms: 200) -> ok(motion: o)
    then defineEasing(motion: o2, name: "ease-out",
                      value: "cubic-bezier(0, 0, 0.2, 1)") -> ok(motion: o2)
  }
}
```

### 3.18 Elevation

```
@version(1)
concept Elevation [W] {

  purpose {
    Shadow and depth system. Numbered scale (0-5):
    0 = flat, 1 = raised, 2 = floating, 3 = overlay,
    4 = modal, 5 = top. Each level uses multi-layer shadows.
    Adapts to theme: light uses gray shadows, dark uses
    darker shadows or ambient glow.
  }

  state {
    level: W -> Int
    shadow: W -> String
    color: W -> option String
  }

  actions {
    action define(elevation: W, level: Int, shadow: String) {
      -> ok(elevation: W) {
        Define shadow for elevation level. Shadow: JSON array
        of layers: [{ "y": 2, "blur": 4, "color": "rgba(0,0,0,0.1)" }]
      }
      -> invalid(message: String) { Level must be 0-5. }
    }

    action get(elevation: W) {
      -> ok(elevation: W, shadow: String) { Return shadow definition. }
      -> notfound(message: String) { Not defined for this level. }
    }

    action generateScale(baseColor: String) {
      -> ok(shadows: String) {
        Auto-generate all 6 levels from base shadow color.
      }
      -> invalid(message: String) { Invalid color. }
    }
  }

  invariant {
    after define(elevation: w, level: 2,
                 shadow: "[{ \"y\": 4, \"blur\": 8, \"color\": \"rgba(0,0,0,0.12)\" }]")
      -> ok(elevation: w)
    then get(elevation: w) -> ok(elevation: w, shadow: _)
  }
}
```

---

## 4. Core Synchronizations

COIF syncs coordinate concepts using COPF's when/where/then mechanism.

### 4.1 coif-core syncs

```
sync InspectAndGenerate [eager]
when {
  Binding/bind: [ concept: ?concept ]
    => [ binding: ?binding ]
}
then {
  UISchema/inspect: [ schema: ?binding; conceptSpec: ?concept ]
}
```

*When a binding is created, auto-generate UI schema from concept spec.*

```
sync UISchemaToElements [eager]
when {
  UISchema/inspect: [ schema: ?schema ]
    => [ schema: ?schema ]
}
then {
  UISchema/getElements: [ schema: ?schema ]
}
```

*When a schema is generated, extract abstract element tree.*

```
sync BindingStateSync [eager]
when {
  Signal/write: [ signal: ?signal; value: ?value ]
    => [ signal: ?signal; version: ?version ]
}
where {
  Binding: { ?binding signalMap: ?map }
  filter(contains(?map, ?signal))
}
then {
  Binding/sync: [ binding: ?binding ]
}
```

*When a signal is written (user input), sync back to bound concept.*

```
sync ConceptStateToSignal [eager]
when {
  Binding/sync: [ binding: ?binding ]
    => [ binding: ?binding ]
}
where {
  Binding: { ?binding signalMap: ?map }
}
then {
  Signal/batch: [ signals: ?map ]
}
```

*When binding syncs from backend, batch-update all mapped signals.*

### 4.2 coif-component syncs

```
sync ElementToMachine [eager]
when {
  UISchema/getElements: []
    => [ elements: ?elements ]
}
then {
  Widget/list: [ category: ?_ ]
}
```

*When elements are extracted, query component registry for appropriate machines.*

```
sync SpawnMachineForElement [eager]
when {
  Widget/get: [ widget: ?comp ]
    => [ widget: ?comp; machineSpec: ?spec;
         anatomy: ?anatomy; a11ySpec: ?a11y ]
}
then {
  Machine/spawn: [ machine: ?comp; widget: ?comp;
                   context: "{ \"autoGenerated\": true }" ]
}
```

*When a component spec is retrieved, spawn a machine instance.*

```
sync MachineToFrameworkAdapter [eager]
when {
  Machine/connect: [ machine: ?machine ]
    => [ machine: ?machine; props: ?props ]
}
where {
  FrameworkAdapter: { ?adapter status: "active" }
}
then {
  FrameworkAdapter/normalize: [ adapter: ?adapter; props: ?props ]
}
```

*When a machine produces props, send to active renderer for normalization. The adapter-pipeline sync (§4.3.1) then routes to the appropriate per-framework adapter concept.*

```
sync DestroyMachineOnUnbind [eager]
when {
  Binding/unbind: [ binding: ?binding ]
    => [ binding: ?binding ]
}
where {
  Machine: { ?machine component: ?binding }
}
then {
  Machine/destroy: [ machine: ?machine ]
}
```

*When a binding is removed, destroy all associated machines.*

### 4.3 coif-render syncs

```
sync AttachAdapterToSurface [eager]
when {
  FrameworkAdapter/register: [ adapter: ?adapter ]
    => [ adapter: ?adapter ]
}
where {
  Surface: { ?surface status: "ready" }
}
then {
  Surface/attach: [ surface: ?surface; adapter: ?adapter ]
}
```

*When a renderer registers, attach to any ready surface.*

#### 4.3.1 Adapter Pipeline

The adapter pipeline routes framework-neutral props to the correct per-framework adapter concept. This mirrors COPF's `compiler-pipeline.sync` — each framework gets its own sync rule, and adding a new framework means adding one rule.

```
# When props are produced, normalize for React
sync NormalizeReact [eager]
when {
  Machine/connect: [ machine: ?machine ]
    => [ machine: ?machine; props: ?props ]
}
where {
  FrameworkAdapter: { ?adapter framework: "react"; status: "active" }
}
then {
  ReactAdapter/normalize: [ adapter: ?adapter; props: ?props ]
}

# When props are produced, normalize for Solid
sync NormalizeSolid [eager]
when {
  Machine/connect: [ machine: ?machine ]
    => [ machine: ?machine; props: ?props ]
}
where {
  FrameworkAdapter: { ?adapter framework: "solid"; status: "active" }
}
then {
  SolidAdapter/normalize: [ adapter: ?adapter; props: ?props ]
}
```

*Each framework adapter gets its own sync rule. Compare: `syncs/framework/compiler-pipeline.sync` in COPF, where each language gen gets its own sync.*

```
sync ResizeTriggersViewport [eager]
when {
  Surface/resize: [ surface: ?surface; width: ?w; height: ?h ]
    => [ surface: ?surface ]
}
then {
  Viewport/observe: [ viewport: ?surface; width: ?w; height: ?h ]
}
```

*Surface resize → viewport breakpoint recalculation.*

```
sync ViewportTriggersLayout [eager]
when {
  Viewport/observe: [ viewport: ?vp ]
    => [ viewport: ?vp; breakpoint: ?bp ]
}
where {
  Layout: { ?layout responsive: ?rules }
  filter(contains(?rules, ?bp))
}
then {
  Layout/configure: [ layout: ?layout; config: ?rules ]
}
```

*Breakpoint change → reconfigure responsive layouts.*

### 4.4 coif-theme syncs

```
sync ThemeActivateTokens [eager]
when {
  Theme/activate: [ theme: ?theme ]
    => [ theme: ?theme ]
}
then {
  Theme/resolve: [ theme: ?theme ]
}
```

*Theme activated → resolve all tokens.*

```
sync ThemeTokensToSignals [eager]
when {
  Theme/resolve: [ theme: ?theme ]
    => [ tokens: ?tokens ]
}
then {
  Signal/batch: [ signals: ?tokens ]
}
```

*Resolved tokens → batch-update token signals for live theming.*

```
sync PaletteToTokens [eager]
when {
  Palette/generate: [ palette: ?p ]
    => [ palette: ?p; scale: ?scale ]
}
then {
  DesignToken/define: [ token: ?p; name: ?p; value: ?scale;
                  type: "color"; tier: "primitive" ]
}
```

*Palette color scale → register as primitive tokens.*

```
sync ContrastWarning [eager]
when {
  Palette/assignRole: [ palette: ?p; role: ?role ]
    => [ palette: ?p ]
}
where {
  Palette: { ?bg role: "surface" }
}
then {
  Palette/checkContrast: [ foreground: ?p; background: ?bg ]
}
```

*Role assignment → auto-check accessibility contrast.*

---

## 5. Kit Manifests

### 5.1 coif-core

```yaml
kit:
  name: coif-core
  version: 0.1.0
  description: >
    Foundation concepts for COIF: tokens, elements, schemas,
    bindings, and signals. Required by all other COIF kits.

concepts:
  DesignToken:
    spec: ./design-token.concept
    params: { T: { as: token-ref } }
  Element:
    spec: ./element.concept
    params: { E: { as: element-ref } }
  UISchema:
    spec: ./ui-schema.concept
    params: { S: { as: schema-ref }, C: { as: concept-ref } }
  Binding:
    spec: ./binding.concept
    params: { B: { as: binding-ref }, C: { as: concept-ref } }
  Signal:
    spec: ./signal.concept
    params: { G: { as: signal-ref } }

syncs:
  required:
    - path: ./syncs/inspect-and-generate.sync
    - path: ./syncs/concept-state-to-signal.sync
    - path: ./syncs/binding-state-sync.sync
  recommended:
    - path: ./syncs/schema-to-elements.sync
      name: UISchemaToElements
```

### 5.2 coif-component

```yaml
kit:
  name: coif-component
  version: 0.1.0
  description: >
    Headless component state machines, anatomies, and slot composition.
  dependencies:
    - coif-core: ">=0.1.0"

concepts:
  Widget:
    spec: ./widget.concept
    params: { P: { as: widget-ref } }
  Machine:
    spec: ./machine.concept
    params: { M: { as: machine-ref } }
  Anatomy:
    spec: ./anatomy.concept
    params: { N: { as: anatomy-ref } }
  Slot:
    spec: ./slot.concept
    params: { L: { as: slot-ref } }

syncs:
  required:
    - path: ./syncs/destroy-machine-on-unbind.sync
  recommended:
    - path: ./syncs/element-to-machine.sync
      name: ElementToMachine
    - path: ./syncs/spawn-machine-for-element.sync
      name: SpawnMachineForElement
    - path: ./syncs/machine-to-adapter.sync
      name: MachineToFrameworkAdapter
```

### 5.3 coif-render

```yaml
kit:
  name: coif-render
  version: 0.1.0
  description: >
    Framework adapters, surfaces, layouts, and viewports.
  dependencies:
    - coif-core: ">=0.1.0"
    - coif-component: ">=0.1.0"

concepts:
  FrameworkAdapter:
    spec: ./framework-adapter.concept
    params: { R: { as: adapter-ref } }
  # Per-framework adapter concepts — mirrors COPF's per-language gen pattern.
  # Adding a new framework: create <framework>-adapter.concept + one sync rule.
  ReactAdapter:
    spec: ./react-adapter.concept
    params: { A: { as: adapter-ref } }
  SolidAdapter:
    spec: ./solid-adapter.concept
    params: { A: { as: adapter-ref } }
  VueAdapter:
    spec: ./vue-adapter.concept
    params: { A: { as: adapter-ref } }
  SvelteAdapter:
    spec: ./svelte-adapter.concept
    params: { A: { as: adapter-ref } }
  InkAdapter:
    spec: ./ink-adapter.concept
    params: { A: { as: adapter-ref } }
  VanillaAdapter:
    spec: ./vanilla-adapter.concept
    params: { A: { as: adapter-ref } }
  Surface:
    spec: ./surface.concept
    params: { F: { as: surface-ref } }
  Layout:
    spec: ./layout.concept
    params: { Y: { as: layout-ref } }
  Viewport:
    spec: ./viewport.concept
    params: { V: { as: viewport-ref } }

syncs:
  required:
    - path: ./syncs/attach-adapter-to-surface.sync
    - path: ./syncs/adapter-pipeline.sync
      name: AdapterPipeline
      description: >
        Per-framework normalization syncs. Mirrors COPF's
        compiler-pipeline.sync — one sync rule per framework.
  recommended:
    - path: ./syncs/resize-triggers-viewport.sync
      name: ResizeTriggersViewport
    - path: ./syncs/viewport-triggers-layout.sync
      name: ViewportTriggersLayout

infrastructure:
  adapters:
    - name: react
      concept: ReactAdapter
      description: React 18+ with hooks (useCoif, useSignal, useMachine)
    - name: solid
      concept: SolidAdapter
      description: Solid.js with reactive primitives
    - name: vue
      concept: VueAdapter
      description: Vue 3 Composition API
    - name: svelte
      concept: SvelteAdapter
      description: Svelte 5 with runes
    - name: ink
      concept: InkAdapter
      description: Ink (React for terminal)
    - name: vanilla
      concept: VanillaAdapter
      description: Framework-free DOM APIs
```

### 5.4 coif-theme

```yaml
kit:
  name: coif-theme
  version: 0.1.0
  description: >
    Visual design: themes, palettes, typography, motion, elevation.
  dependencies:
    - coif-core: ">=0.1.0"

concepts:
  Theme:
    spec: ./theme.concept
    params: { H: { as: theme-ref } }
  Palette:
    spec: ./palette.concept
    params: { C: { as: palette-ref } }
  Typography:
    spec: ./typography.concept
    params: { X: { as: typography-ref } }
  Motion:
    spec: ./motion.concept
    params: { O: { as: motion-ref } }
  Elevation:
    spec: ./elevation.concept
    params: { W: { as: elevation-ref } }

syncs:
  required:
    - path: ./syncs/theme-activate-tokens.sync
    - path: ./syncs/theme-tokens-to-signals.sync
  recommended:
    - path: ./syncs/palette-to-tokens.sync
      name: PaletteToTokens
    - path: ./syncs/contrast-warning.sync
      name: ContrastWarning

themes:
  - name: light
    path: ./themes/light.json
  - name: dark
    path: ./themes/dark.json
  - name: high-contrast
    path: ./themes/high-contrast.json
```

---

## 6. Concept Library Integration

COIF integrates with the COPF Concept Library (v0.4.0, 54 concepts across 15 kits) via syncs that bridge domain concepts to interface concerns. This section defines the cross-system syncs that connect library kits to COIF kits.

### 7.1 Name Collision Resolutions

Four COIF concepts were renamed in v0.2.0 to avoid collisions with library concepts that share names but serve different purposes:

| COIF v0.1.0 | COIF v0.2.0 | Library Concept (unchanged) | Why different |
|---|---|---|---|
| Token | **DesignToken** | Token (@copf/computation) | COIF: W3C visual design data. Library: Drupal-style `[node:author:mail]` text placeholders. |
| Component | **Widget** | Component (@copf/layout) | COIF: Headless state machines for UI behavior. Library: Pluggable content units placed in layout regions (Drupal Block). |
| Renderer | **FrameworkAdapter** | Renderer (@copf/presentation) | COIF: React/Solid/Vue adapter (~200 LOC). Library: Content-to-render-tree pipeline with caching and BigPipe streaming. |
| Schema | **UISchema** | Schema (@copf/classification) | COIF: Inspect specs → generate UI schema. Library: Named field sets (type-as-mixin) and runtime concept coordination hub. |

### 7.2 Library Concepts Superseded by COIF

Three library concepts are replaced when COIF is available. Their domain-level intent survives as syncs that delegate to COIF:

**FormBuilder** → UISchema + Machine(form). COIF's type-mapping rules + form state machine + progressive customization ladder does everything FormBuilder does, but headless and framework-agnostic. FormBuilder's `widgetRegistry` migrates to Widget/register. Its `buildForm` becomes UISchema/inspect + Machine/spawn("form"). Its `processSubmission` becomes Binding/invoke.

**DisplayMode** → UISchema overrides + Theme. Named presentation profiles ("teaser", "full", "compact") become named UISchema override presets. Field formatter configurations become Widget configurations. The concept survives as a naming convenience — users still think in modes — but implementation delegates to COIF.

**ExposedFilter** → Widget + Binding syncs. Each exposed filter is a Widget/Machine instance bound to a Query parameter signal. User interacts with Widget → Signal/write → Binding syncs to Query → Query re-executes → results update. The standalone concept is unnecessary.

### 7.3 Library Concepts Partially Absorbed

**Control** (Automation kit): UI behavior (buttons, sliders, toggles binding to data and triggering actions) is Widget + Binding. Control's `interact` action becomes Machine/send. Control's `embed` becomes a sync that places a Widget inside a ContentNode. Domain-level action triggering retained in the library.

**Graph** (Data Organization): Visualization (layout algorithms, position state, rendering, filtering) moves to Widget("graph"). Data derivation (nodes + edges computed from Backlinks) stays in the library. Graph retains `nodes`, `edges`, `getNeighbors`. COIF absorbs `computeLayout`, `filterNodes`, position state.

### 7.4 Cross-System Syncs

These syncs wire library domain concepts to COIF interface concepts. They belong to a new **coif-integration** kit that requires both COIF kits and the relevant library kits.

#### Library Schema → UISchema (core integration)

When a library Schema is defined, COIF auto-generates a complete UI for it.

```
sync SchemaDefDrivesUI [eager]
  purpose: "Auto-generate interface when a concept schema is defined"
when {
  Schema/defineSchema: [ name: ?name; fields: ?fields ]
    => [ schema: ?schemaId ]
}
then {
  UISchema/inspect: [ schema: ?schemaId; conceptSpec: ?fields ]
}

sync SchemaApplyDrivesBinding [eager]
  purpose: "Create data binding when a schema is applied to a node"
when {
  Schema/applyTo: [ nodeId: ?node ]
    => [ schema: ?schemaId ]
}
then {
  Binding/bind: [ concept: ?node; mode: "coupled" ]
}
```

Schema gains a new association type: `uiSchema: UISchemaID | null`.

#### Intent → UISchema enrichment

Intent's purpose and description generate better labels and placeholders.

```
sync IntentEnrichesUI [eager]
  purpose: "Use concept purpose to enhance generated interface labels"
when {
  Intent/define: [ targetId: ?target; purpose: ?purpose ]
    => [ intent: ?intentId ]
}
where {
  UISchema: { ?uiSchema concept: ?target }
}
then {
  UISchema/override: [ schema: ?uiSchema;
    overrides: "{ \"description\": ?purpose }" ]
}
```

#### Library View → COIF Layout + UISchema

Library View is the configuration/intent layer; COIF implements the rendering.

```
sync ViewDrivesLayout [eager]
  purpose: "Map View layout type to COIF spatial arrangement"
when {
  View/create: [ dataSource: ?ds; layout: ?layoutType ]
    => [ view: ?viewId ]
}
then {
  Layout/create: [ name: ?viewId; kind: ?layoutType ]
  UISchema/inspect: [ schema: ?viewId; conceptSpec: ?ds ]
}

sync ViewFieldsDriveUISchema [eager]
  purpose: "Reflect visible field changes in UI schema overrides"
when {
  View/setVisibleFields: [ view: ?viewId; fieldIds: ?fields ]
    => [ view: ?viewId ]
}
then {
  UISchema/override: [ schema: ?viewId; overrides: ?fields ]
}

sync ViewEmbedCreatesInlineSurface [eager]
  purpose: "Embed a View inside a ContentNode as an inline COIF surface"
when {
  View/embed: [ targetNodeId: ?node ]
    => [ view: ?viewId ]
}
then {
  Surface/create: [ surface: ?viewId; kind: "browser-dom";
    mountPoint: ?node ]
}
```

#### Validator → Machine(form) validation

COIF's form machine delegates constraint checking to the library Validator.

```
sync FormValidatesViaValidator [eager]
  purpose: "Delegate form submission validation to library Validator"
when {
  Machine/send: [ machine: ?form; event: "{ \"type\": \"SUBMIT\" }" ]
    => [ machine: ?form; state: "validating" ]
}
where {
  Binding: { ?binding signalMap: ?map }
  filter(contains(?map, ?form))
}
then {
  Validator/validate: [ nodeId: ?form; formData: ?map ]
}

sync ValidationResultToForm [eager]
  purpose: "Route validation results back to form machine"
when {
  Validator/validate: []
    => [ result: ?result ]
}
then {
  Machine/send: [ machine: ?form;
    event: "{ \"type\": \"VALIDATION_RESULT\", \"result\": ?result }" ]
}
```

#### Workflow → Signal (status state)

Workflow state transitions update COIF signals for live status display.

```
sync WorkflowStateToSignal [eager]
  purpose: "Reflect workflow state changes in UI signals"
when {
  Workflow/transition: [ entityId: ?entity; targetState: ?state ]
    => [ entityId: ?entity ]
}
then {
  Signal/write: [ signal: ?entity; value: ?state ]
}
```

#### EventBus → Signal (event stream)

Domain events update COIF signals subscribed to those event types.

```
sync EventBusFeedsSignals [eager]
  purpose: "Route domain events to subscribed UI signals"
when {
  EventBus/dispatch: [ event: ?event ]
    => [ eventType: ?type; payload: ?payload ]
}
where {
  Signal: { ?signal kind: "state" }
  filter(subscribedTo(?signal, ?type))
}
then {
  Signal/write: [ signal: ?signal; value: ?payload ]
}
```

#### Notification → Machine(toast)

Notifications render as toast widgets.

```
sync NotificationToToast [eager]
  purpose: "Display notifications as toast UI widgets"
when {
  Notification/send: [ userId: ?user; message: ?msg ]
    => [ notification: ?notif ]
}
then {
  Machine/spawn: [ machine: ?notif; widget: "toast";
    context: "{ \"message\": ?msg, \"variant\": \"info\" }" ]
}
```

#### ContentParser → Widget(rich-text)

Parsed content feeds rich-text widgets with interactive inline elements.

```
sync ParsedContentToRichText [eager]
  purpose: "Feed parsed AST to rich-text widget for interactive rendering"
when {
  ContentParser/parse: [ content: ?content; formatId: ?fmt ]
    => [ ast: ?ast; extractedMetadata: ?meta ]
}
then {
  Signal/write: [ signal: ?content; value: ?ast ]
}
```

#### Library Renderer → FrameworkAdapter

The library's content-to-render-tree pipeline feeds into COIF's framework adapter.

```
sync RendererFeedsAdapter [eager]
  purpose: "Route rendered content tree through framework adapter"
when {
  Renderer/render: [ element: ?el ]
    => [ renderTree: ?tree ]
}
where {
  FrameworkAdapter: { ?adapter status: "active" }
}
then {
  FrameworkAdapter/normalize: [ adapter: ?adapter; props: ?tree ]
}
```

#### Library Component → Widget (layout component rendering)

Library layout components (Drupal Blocks) render through COIF widgets.

```
sync LayoutComponentRendersViaWidget [eager]
  purpose: "Render layout components through COIF widget state machines"
when {
  Component/render: [ component: ?comp; context: ?ctx ]
    => [ component: ?comp ]
}
where {
  Widget: { ?widget name: ?comp }
}
then {
  Machine/spawn: [ machine: ?comp; widget: ?widget; context: ?ctx ]
}
```

### 7.5 coif-integration Kit Manifest

```yaml
kit:
  name: coif-integration
  version: 0.1.0
  description: >
    Syncs that bridge COPF Concept Library domain concepts to COIF interface
    concepts. Requires both COIF kits and the relevant library kits to be active.
  dependencies:
    - coif-core: ">=0.2.0"
    - coif-component: ">=0.2.0"
    - coif-render: ">=0.2.0"
    - coif-theme: ">=0.2.0"
  uses:
    "@copf/classification":
      concepts: [Schema]
    "@copf/foundation":
      concepts: [ContentParser, Intent]
    "@copf/presentation":
      concepts: [View, Renderer]
    "@copf/infrastructure":
      concepts: [EventBus, Validator]
    "@copf/automation":
      concepts: [Workflow, Control]
    "@copf/layout":
      concepts: [Component]
    "@copf/notification":
      concepts: [Notification]

concepts: []  # No new concepts — this kit is syncs-only

syncs:
  required:
    - path: ./syncs/schema-def-drives-ui.sync
      name: SchemaDefDrivesUI
    - path: ./syncs/schema-apply-drives-binding.sync
      name: SchemaApplyDrivesBinding
  recommended:
    - path: ./syncs/intent-enriches-ui.sync
      name: IntentEnrichesUI
    - path: ./syncs/view-drives-layout.sync
      name: ViewDrivesLayout
    - path: ./syncs/view-fields-drive-uischema.sync
      name: ViewFieldsDriveUISchema
    - path: ./syncs/view-embed-creates-surface.sync
      name: ViewEmbedCreatesInlineSurface
    - path: ./syncs/form-validates-via-validator.sync
      name: FormValidatesViaValidator
    - path: ./syncs/validation-result-to-form.sync
      name: ValidationResultToForm
    - path: ./syncs/workflow-state-to-signal.sync
      name: WorkflowStateToSignal
    - path: ./syncs/eventbus-feeds-signals.sync
      name: EventBusFeedsSignals
    - path: ./syncs/notification-to-toast.sync
      name: NotificationToToast
    - path: ./syncs/parsed-content-to-richtext.sync
      name: ParsedContentToRichText
    - path: ./syncs/renderer-feeds-adapter.sync
      name: RendererFeedsAdapter
    - path: ./syncs/layout-component-via-widget.sync
      name: LayoutComponentRendersViaWidget
```

### 7.6 Updated Concept Counts

| System | Before | After | Change |
|---|---|---|---|
| Concept Library | 54 concepts, 15 kits | 51 concepts, 14 kits | -3 (FormBuilder, DisplayMode, ExposedFilter removed) |
| COIF | 18 concepts, 4 kits | 18 concepts, 4 kits + 1 integration kit | 4 renames, 0 added/removed |
| Combined unique | — | 69 concepts, 19 kits | Zero overlap after renames |

The Presentation kit shrinks from 4 concepts (View, DisplayMode, FormBuilder, Renderer) to 2 (View, Renderer). It gains `uses` references to COIF kits.

---

## 7. Deployment Architecture

### 7.1 Deployment Manifest Extension

COIF extends COPF's `app.deploy.yaml`:

```yaml
app:
  name: my-app
  version: 1.0.0

kits:
  - name: coif-core
  - name: coif-component
  - name: coif-render
  - name: coif-theme

interface:
  renderer: react

  surface:
    kind: browser-dom
    mountPoint: "#app"

  theme:
    base: light
    variants: [dark, high-contrast]
    defaultVariant: light
    respectSystemPreference: true

  deploy:
    mode: bundled
    options:
      bundled:
        target: esm
        treeshake: true
        minify: true
      cdn:
        url: "https://cdn.example.com/coif/v0.1.0/"
        globalName: "COIF"
      ssr:
        framework: next
        streaming: true
      native:
        platforms: [ios, android]
      edge:
        runtime: cloudflare-worker
        hydration: partial

  customization:
    level: 2
```

### 7.2 Deployment Modes

| Mode | Output | Use Case | Size |
|------|--------|----------|------|
| **bundled** | ESM/CJS modules | npm install for React/Vue/etc | ~15KB core |
| **cdn** | UMD script + CSS | Script tag, prototyping | ~45KB gzipped |
| **ssr** | HTML + hydration | SEO, fast initial load | Framework-dependent |
| **native** | React Native components | Mobile apps | ~25KB core |
| **edge** | Worker-compatible bundle | Cloudflare/Vercel edge | ~20KB |

### 7.3 Framework Adapter Pattern

Adding a framework adapter to COIF mirrors adding a language target to COPF. Both follow the same three-step process:

| Step | COPF (add language) | COIF (add framework) |
|------|---------------------|----------------------|
| 1. Concept spec | `specs/framework/<lang>-gen.concept` | `kits/coif-render/<framework>-adapter.concept` |
| 2. Implementation | `implementations/typescript/framework/<lang>-gen.impl.ts` | `generated/concept-interface/typescript/<framework>adapter.impl.ts` |
| 3. Pipeline sync | Add sync rule in `compiler-pipeline.sync` | Add sync rule in `adapter-pipeline.sync` |

**Step 1 — Concept spec** (copy an existing adapter, change name + purpose):

```
@version(1)
concept AngularAdapter [A] {

  purpose {
    Normalize framework-neutral props into Angular-specific bindings.
    Transforms COIF's generic event model into Angular conventions:
    (event) output bindings, [property] input bindings, NgZone
    change detection integration.
  }

  state {
    outputs: A -> String
  }

  actions {
    action normalize(adapter: A, props: String) {
      -> ok(adapter: A, normalized: String) {
        Map framework-neutral props to Angular bindings.
      }
      -> error(message: String) {
        Props contain patterns not mappable to Angular.
      }
    }
  }

  invariant {
    after normalize(adapter: a,
                    props: "{ \"onclick\": \"handler_1\", \"class\": \"btn\" }")
      -> ok(adapter: a, normalized: _)
  }
}
```

**Step 2 — Implementation** follows the standard COPF handler pattern:

```
import type { ConceptHandler } from '../../../kernel/src/types.js';

export const angularAdapterHandler: ConceptHandler = {
  async normalize(input, storage) {
    // ... Angular-specific prop normalization
    return { variant: 'ok', adapter: input.adapter, normalized };
  },
};
```

**Step 3 — Pipeline sync** (one rule in `adapter-pipeline.sync`):

```
sync NormalizeAngular [eager]
when {
  Machine/connect: [ machine: ?machine ]
    => [ machine: ?machine; props: ?props ]
}
where {
  FrameworkAdapter: { ?adapter framework: "angular"; status: "active" }
}
then {
  AngularAdapter/normalize: [ adapter: ?adapter; props: ?props ]
}
```

No existing code changes. The engine evaluates all pipeline syncs — only the one whose `where` clause matches the active framework fires. Compare `syncs/framework/compiler-pipeline.sync` in COPF.

---

## 8. Progressive Customization Ladder

Every level uses the same mechanism COPF uses: `.concept` specs, syncs, and concept actions. No framework-specific API surfaces until Level 4, where framework-native rendering code is unavoidable.

### Level 0: Zero Config (deployment manifest only)

No code, no configuration. Deploy a concept with COIF kits and the engine auto-generates the full interface via the sync pipeline.

```yaml
# app.deploy.yaml — just list the concept and COIF kits
app:
  name: my-app

kits:
  - name: coif-core
  - name: coif-component
  - name: coif-render
  - name: coif-theme

concepts:
  - spec: ./article.concept

interface:
  renderer: react
  surface:
    kind: browser-dom
    mountPoint: "#app"
```

*The engine fires: Binding/bind → UISchema/inspect → elements → Widget/get → Machine/spawn → Machine/connect → ReactAdapter/normalize. Complete CRUD interface with zero custom code.*

### Level 1: Field-Level (interface section in .concept spec)

Add an `interface` section to the concept spec — flat, declarative key-value pairs. No JavaScript.

```
concept Article [A, U] {

  state {
    title: A -> String
    body: A -> String
    published: A -> Bool
    createdAt: A -> DateTime
  }

  actions { ... }

  interface {
    field title {
      widget: "text-input"
      placeholder: "Enter article title..."
      validation: { minLength: "1"; maxLength: "200" }
    }
    field body {
      widget: "rich-text"
      label: "Body"
    }
    field createdAt {
      widget: "datetime-display"
      readOnly: "true"
    }
  }
}
```

*UISchema/inspect reads the `interface` section and overrides defaults. The pipeline runs the same way — just with customized widget selections.*

### Level 2: View-Level (interface section view mappings)

Add `view` entries to the `interface` section for layout customization.

```
  interface {
    field title { ... }
    field body { ... }

    view list {
      columns: "title, author, published, updatedAt"
      defaultSort: "updatedAt"
      sortDirection: "desc"
      searchable: "title, body"
    }
    view detail {
      layout: "sidebar"
      sections: "content: title, body; meta: author, published, createdAt"
      actions: "update, publish, delete"
    }
    view create {
      fields: "title, body"
      submit: "create"
    }
  }
```

*Still flat DSL, still no framework code. The UISchema concept generates element trees for each view, which the Widget and Layout concepts render.*

### Level 3: Widget-Level (Slot concept + syncs)

Replace specific parts of generated UI using the Slot concept and syncs. No framework-specific API — composition via concept actions.

```
# Fill the form body slot with a custom rich-text editor widget
sync CustomArticleEditor [eager]
when {
  Machine/spawn: [ machine: ?m; widget: "form" ]
    => ok(machine: ?m)
}
where {
  Slot: { ?slot name: "body"; component: "form" }
}
then {
  Slot/fill: [ slot: ?slot;
    content: "{ \"widget\": \"custom-rich-text\", \"config\": { \"toolbar\": \"full\" } }" ]
}

# Fill the list row slot with a custom card layout
sync CustomArticleRow [eager]
when {
  Machine/spawn: [ machine: ?m; widget: "listview" ]
    => ok(machine: ?m)
}
where {
  Slot: { ?slot name: "row"; component: "listview" }
}
then {
  Slot/fill: [ slot: ?slot;
    content: "{ \"widget\": \"article-card\", \"anatomy\": \"hero-image, title, excerpt\" }" ]
}
```

*Composition through syncs — the same coordination mechanism COPF uses everywhere.*

### Level 4: Full Custom (direct concept invocations)

For fully custom rendering, invoke Machine and Binding concept actions directly. This is the only level where framework-specific code appears — and it's the implementation of a per-framework adapter concept, following the standard COPF handler pattern.

```
# The concept actions powering the custom UI:
Binding/bind:   [ concept: "urn:app/Article"; mode: "coupled" ]
Machine/spawn:  [ machine: "form-001"; widget: "form";
                  context: "{ \"fields\": [\"title\", \"body\"] }" ]
Machine/connect: [ machine: "form-001" ]
  => ok(machine: "form-001"; props: { ... })
Binding/invoke: [ binding: "b-001"; action: "create";
                  input: "{ \"title\": \"...\", \"body\": \"...\" }" ]
```

*The framework adapter concept (ReactAdapter, SolidAdapter, etc.) transforms these props into framework-native code. The adapter implementation is the only place where framework-specific code lives — ~200 LOC following the standard COPF handler pattern.*

---

## 9. Type-Mapping Rules

UISchema concept uses these to generate default UI from COPF types:

| COPF Type | Element Kind | Default Widget |
|-----------|-------------|----------------|
| `String` | input-text | text-input |
| `Int` | input-number | number-input (step=1) |
| `Float` | input-number | number-input (step=0.01) |
| `Bool` | input-bool | toggle |
| `DateTime` | input-date | datetime-picker |
| `Bytes` | file-upload | file-input |
| `ID` | output-text | text-display (read-only) |
| `option T` | *same as T* | *same*, required=false |
| `set T` | selection-multi | multi-select / checkbox-group |
| `list T` | group (repeating) | repeating-field-group |
| `T -> T` (relation) | selection-single | select / combobox |
| `{ fields }` (record) | group | fieldset |

For list views, field types map to column behaviors:

| COPF Type | Column Behavior |
|-----------|----------------|
| `String` | Text, searchable, sortable |
| `Int/Float` | Numeric, sortable, right-aligned |
| `Bool` | Badge/icon (✓/✗), filterable |
| `DateTime` | Relative time, sortable |
| `ID` | Hidden by default |
| `set T` | Count badge, expandable |

---

## 10. Bootstrapping Plan

COIF is built on COPF from the first line of code. Every stage uses `.concept` specs, `.sync` files, and the COPF engine — no hand-wired coordination that gets "replaced later." COPF's own bootstrap (kernel → self-hosting) provides the engine; COIF layers concepts and syncs on top of it.

This means COIF requires a working COPF engine (Stage 3+ of COPF's bootstrap) as a prerequisite. COIF is a COPF application, not a parallel system.

### Stage 0: Foundation Concepts + Syncs

Deploy the coif-core kit's 5 concepts (DesignToken, Element, UISchema, Binding, Signal) as COPF `.concept` specs with TypeScript implementations. Deploy the 4 coif-core syncs (InspectAndGenerate, SchemaToElements, BindingStateSync, ConceptStateToSignal) as `.sync` files loaded by the COPF engine.

All coordination runs through the engine from day one. When a Binding/bind completion arrives, the engine evaluates InspectAndGenerate and fires UISchema/inspect — no application code orchestrates this.

**Acceptance tests (generated from invariants + sync integration tests):**
- Binding/bind → engine fires InspectAndGenerate → UISchema/inspect produces valid UI schema
- UISchema/inspect completion → engine fires SchemaToElements → element tree extracted
- Signal/write → engine fires BindingStateSync → Binding/sync propagates to backend
- Binding/sync completion → engine fires ConceptStateToSignal → Signal/batch updates all mapped signals
- DesignToken alias chains resolve correctly across define → alias → resolve

### Stage 1: Widget Kit

Deploy coif-component's 4 concepts (Component, Machine, Anatomy, Slot) and 4 syncs (ElementToMachine, SpawnMachineForElement, MachineToFrameworkAdapter, DestroyMachineOnUnbind). Register the initial 10 component state machines (button, input, textarea, select, checkbox, toggle, dialog, tabs, form, toast) via Widget/register actions.

The pipeline now runs end-to-end via syncs: a Binding/bind triggers schema inspection, which triggers element extraction, which triggers component selection, which triggers machine spawning — all through the engine's sync evaluation loop.

**Acceptance tests:**
- Full pipeline: Binding/bind → ... → Machine/spawn produces running machines for each element
- Machine/connect returns valid props for each of the 10 component types
- Machine/send transitions states correctly (dialog open/close, form submit/reset)
- Binding/unbind → engine fires DestroyMachineOnUnbind → all machines cleaned up

### Stage 2: Render Kit + React Adapter

Deploy coif-render's concepts: FrameworkAdapter (registry), ReactAdapter (first per-framework adapter), Surface, Layout, Viewport. Deploy syncs: AttachAdapterToSurface, adapter-pipeline (NormalizeReact rule), ResizeTriggersViewport, ViewportTriggersLayout.

The ReactAdapter concept normalizes Machine/connect props into React bindings — following the same concept + implementation + sync pattern as COPF's TypeScriptGen. The adapter-pipeline.sync routes props to ReactAdapter/normalize when the active framework is "react", just as compiler-pipeline.sync routes manifests to TypeScriptGen/generate.

**Acceptance tests:**
- FrameworkAdapter/register → engine fires AttachAdapterToSurface → renderer connected to surface
- Machine/connect → engine fires NormalizeReact (adapter-pipeline) → ReactAdapter/normalize produces React bindings
- Surface/resize → engine fires ResizeTriggersViewport → Viewport/observe → breakpoint signal updated
- Viewport breakpoint change → engine fires ViewportTriggersLayout → layouts reconfigured
- Full pipeline: concept spec → UISchema → elements → Widget → Machine → ReactAdapter → rendered UI

### Stage 3: Theme Kit

Deploy coif-theme's 5 concepts (Theme, Palette, Typography, Motion, Elevation) and 4 syncs (ThemeActivateTokens, ThemeTokensToSignals, PaletteToTokens, ContrastWarning). Create default light and dark themes via Theme/create actions. Generate default palettes via Palette/generate.

All theme changes propagate through the same engine: Theme/activate → engine fires ThemeActivateTokens → Theme/resolve → engine fires ThemeTokensToSignals → Signal/batch → UI re-renders. No special theming runtime — it's concepts and syncs all the way down.

**Acceptance tests:**
- Theme/activate → engine cascade → all token-dependent signals updated → UI reflects new theme
- Palette/generate → engine fires PaletteToTokens → colors registered as primitive tokens
- Palette/assignRole → engine fires ContrastWarning → Palette/checkContrast validates accessibility
- prefers-reduced-motion → Motion durations resolve to 0ms

### Stage 4: Additional Framework Adapters

Deploy SolidAdapter, VueAdapter, SvelteAdapter, InkAdapter, VanillaAdapter concepts with implementations. Add their sync rules to adapter-pipeline.sync. Each follows the same pattern as ReactAdapter — a concept spec (~35 LOC), an implementation (~200 LOC), and one sync rule (~10 LOC). This mirrors how COPF adds language targets: RustGen, SwiftGen, and SolidityGen each followed the TypeScriptGen pattern.

**Acceptance tests:**
- Same concept spec + same core syncs → working interfaces in React, Solid, Vue, Svelte, Ink
- Adapter switch: FrameworkAdapter/register with different framework → engine evaluates adapter-pipeline → correct per-framework adapter fires
- Ink adapter produces terminal UI from the same Machine/connect output that React uses
- Adding a new adapter (e.g. AngularAdapter) requires zero changes to existing code — only new concept + impl + sync rule

### Stage 5: CDN, SSR, Native, and Edge Deployment

Extend the deployment manifest to support all 5 modes. The COPF engine runs differently per target — in-process for bundled/CDN, server-side for SSR, on-device for native, request-scoped for edge — but the concepts and syncs are identical. Deploy targets are COPF runtime configurations (§8 of COPF spec), not COIF-specific code.

**Acceptance tests:**
- CDN mode: single `<script>` tag loads COIF runtime + engine + concepts, zero-config deploy manifest produces working UI
- SSR mode: server renders HTML from Machine/connect output, client hydrates with ReactAdapter
- Native mode: ReactNativeAdapter renders same component tree on iOS/Android
- Edge mode: Cloudflare Worker runs COPF engine with lite-query concepts, returns rendered HTML

---

## 11. Resolved Design Questions

| Question | Resolution |
|----------|-----------|
| CLI/API/SDK first-class in COIF? | No. COIF focuses on GUI. CLI/API/SDK via COPF code generators. |
| Atomic Design hierarchy? | No. Flat, concept-driven. Compose via slots and syncs. |
| Full SDUI or configuration-driven? | Configuration-driven. Concepts provide data/behavior; clients own rendering. |
| Signals or observables? | Signals (TC39 aligned) for UI state. Observable subscriptions for concept event streams only. |
| W3C DTCG compliance? | Yes. DesignToken concept follows 2025.10 spec. |
| Headless pattern? | Zag.js model: state machines → connect() → props API. Same pattern, no dependency. |

---

## 12. Design Philosophy: Beauty by Default

COIF's theme system is foundational, not an afterthought. The default themes produce interfaces that feel crafted, not generated:

**Intentional spacing.** 8px base grid, 4px half-step. Every gap references a spacing token — generous whitespace makes auto-generated interfaces feel calm.

**Typographic hierarchy.** 1.25 ratio (major third): 12, 14, 16, 20, 25, 31, 39. Heading weight 600 (semi-bold) — enough contrast without heaviness. Line heights calculated per-size.

**Color with meaning.** 11 shades per hue via OKLCH. Semantic colors: 3 variants each (default, hover, active). Every pairing WCAG AA compliant. Neutral palette with slight warm tint.

**Subtle motion.** Enter: 200ms ease-out. Exit: 150ms ease-in. Hover: 100ms. Nothing exceeds 500ms. Respects prefers-reduced-motion.

**Considered elevation.** Multi-layer shadows for realism. Dark mode: rgba(0,0,0,0.3) vs light mode's rgba(0,0,0,0.1). Elevation 0 is a 1px border, not "no shadow."

The result: a zero-config deployment manifest with `spec: ./article.concept` produces an interface that looks intentionally designed — this is the standard every token and default serves.
