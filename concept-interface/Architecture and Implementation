# Concept-Oriented Interface Framework (COIF)

## Architecture & Implementation Specification

**Version:** 0.3.0
**Date:** 2026-02-19
**Companion to:** COPF v0.19.0

### Changelog

| Version | Date | Summary |
|---------|------|---------|
| 0.1.0 | 2026-02-19 | Initial specification. 18 concepts across 4 kits. |
| 0.2.0 | 2026-02-19 | Concept Library integration. 4 renames (Token→DesignToken, Component→Widget, Renderer→FrameworkAdapter, Schema→UISchema) to resolve name collisions with library concepts. Replaces library FormBuilder, DisplayMode, ExposedFilter. 16 new cross-system syncs binding COIF to Library Schema, View, Validator, Workflow, EventBus, Notification, ContentParser, Intent. Core pipeline: UISchema → Element → Widget → FrameworkAdapter. |
| 0.3.0 | 2026-02-19 | Infrastructure audit + cross-platform rework. New coif-app kit with 5 concepts: Navigator (abstract navigation replacing browser-only Route), Host (widget tree lifecycle orchestrator — implements `coif.auto()`), Transport (network communication for Binding — follows ContentNode/ContentStorage separation pattern), Shell (platform-agnostic app composition with semantic zone roles), PlatformAdapter (thin platform-specific mapping ~100-200 LOC each). Extended Surface with mount/unmount actions, FrameworkAdapter with render action. 23 concepts across 5 kits. |

---

## 1. Overview

COIF is the interface companion to COPF. Where COPF defines **what software does** — concepts with state, actions, and declarative synchronizations — COIF defines **how users interact with it**. COIF is built *on* COPF: every abstraction is a concept, every coordination is a sync, every bundle is a kit. But COIF can also function standalone with any backend that exposes typed operations.

COIF generates working interfaces from concept specs the way Django admin generates UIs from models — zero config gets you a functional interface, progressive customization gets you a beautiful one.

### 1.1 Design Principles

1. **Spec-derived.** Every COPF concept spec contains enough information to generate a default interface — field types map to input widgets, actions map to buttons and forms, state maps to displays. The interface is derived, never invented from scratch.

2. **Headless core.** All component behavior — state machines, accessibility, keyboard navigation, ARIA patterns — lives in framework-agnostic JavaScript. Rendering is a thin adapter layer. A COIF component works in React, Vue, Solid, Svelte, or a terminal without changing its behavioral core.

3. **Signals-native.** Each concept is an independent reactive unit using signals (aligned with TC39 proposal). When one concept's state changes, only UI bound to that concept re-renders. No global store, no cascading updates across unrelated concepts.

4. **Progressive customization.** Five levels, each additive: (0) zero-config auto-generated CRUD, (1) field-level configuration via UI schema, (2) view-level layout customization, (3) component-level replacement via slots, (4) full custom rendering with headless hooks. Most apps never pass level 2.

5. **Beautiful by default.** Design tokens encode a complete visual language — typography, color, spacing, motion, elevation — that produces polished interfaces without custom CSS. The token system is inspired by Material Design 3's reference → system → component hierarchy but is framework-independent.

6. **Concept-composed.** Interfaces compose via synchronizations, not rigid hierarchies. An auth concept's login form and a profile concept's avatar compose through syncs that declare "when login succeeds, show the profile surface" — the same mechanism COPF uses for backend coordination. No Atomic Design taxonomy debates.

7. **Deploy-anywhere.** The same concept interfaces work as a CDN-loaded script tag, a bundled npm package, a React Native component, a terminal UI via Ink, or an edge-rendered page. The deployment target is a configuration choice, not an architectural constraint.

### 1.2 System Anatomy

```
                        ┌──────────────────────────┐
                        │     .concept specs        │
                        │  (source of truth for     │
                        │   data + behavior)        │
                        └────────────┬─────────────┘
                                     │ inspects
                                     ▼
                        ┌──────────────────────────┐
                        │    UISchema Concept       │
                        │  spec → UI Schema +       │
                        │  defaults + type mapping  │
                        └────────────┬─────────────┘
                                     │ produces
              ┌──────────────────────┼────────────────────┐
              ▼                      ▼                    ▼
       ┌─────────────┐     ┌──────────────┐     ┌──────────────┐
       │   Element   │     │ DesignToken  │     │   Binding    │
       │  (abstract  │     │  (design     │     │ (concept ↔   │
       │ interaction │     │  decisions   │     │  interface   │
       │   units)    │     │  as data)    │     │  mapping)    │
       └──────┬──────┘     └──────┬───────┘     └──────┬───────┘
              │                   │                    │
              ▼                   ▼                    ▼
       ┌─────────────────────────────────────────────────────────┐
       │                    Widget Concept                        │
       │    Headless state machines + connect() props API         │
       │    (behavioral core — no rendering, no framework)        │
       │    ┌──────────┐  ┌──────────┐  ┌──────────┐            │
       │    │  Dialog   │  │   Form   │  │   List   │  ...       │
       │    │ machine   │  │ machine  │  │ machine  │            │
       │    └──────────┘  └──────────┘  └──────────┘            │
       └────────────────────────┬────────────────────────────────┘
                                │ connect()
┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─│─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─┐
  coif-app orchestration        │
│                               ▼                                │
  ┌─────────┐  ┌────────┐  ┌────────┐  ┌──────────────────┐
│ │Navigator│→ │  Host  │→ │Binding │→ │    Transport     │    │
  │(destina-│  │(life-  │  │(data   │  │(REST/GraphQL/WS) │
│ │ tions + │  │ cycle  │  │ sync)  │  │(auth, retry,     │    │
  │ guards) │  │ owner) │  │        │  │ cache, offline)  │
│ └────┬────┘  └────┬───┘  └────────┘  └──────────────────┘    │
       │            │
│      ▼            ▼                                            │
  ┌─────────┐  ┌─────────────────────────────────────┐
│ │  Shell  │  │ FrameworkAdapter  (React/Solid/Vue)  │          │
  │(zones + │  │  normalize() + render()              │
│ │overlays)│  └───────────────┬─────────────────────┘          │
  └────┬────┘                  │
│      │                       ▼                                 │
       │            ┌──────────────────┐
│      │            │     Surface      │                         │
       │            │  mount/unmount   │
│      ▼            └──────────────────┘                         │
  ┌──────────────────┐         │
│ │ PlatformAdapter  │         │                                 │
  │(browser/mobile/  │         ▼
│ │ watch/desktop/   │  ┌──────────────┐                         │
  │ terminal)        │  │    Pixels    │
│ └──────────────────┘  └──────────────┘                         │
└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─┘
```

**Full runtime path:** `Shell/initialize` → `Navigator/go` → `Host/mount` → `Binding/bind` → `Transport/fetch` → `UISchema/inspect` → `Widget/get` → `Machine/spawn` → `Machine/connect` → `FrameworkAdapter/render` → `Surface/mount` → pixels on screen.

### 1.3 Key Distinctions from COPF

| Aspect | COPF | COIF |
|--------|------|------|
| Primary unit | Concept (state + actions) | Widget (behavior + presentation) |
| Coordination | Syncs (when/where/then) | Syncs (same mechanism) |
| Independence | Concepts never reference each other | Widgets never reference each other's internals |
| Composition | Via syncs only | Via syncs + slots (named insertion points) |
| Storage | Sovereign per-concept | Signals (reactive state per-concept) |
| Wire protocol | Action messages (JSON) | Props API (connect() output) |
| Query | GraphQL / Lite Query | Reactive subscriptions (signals) |

### 1.4 Standalone vs. Coupled Mode

**Standalone mode:** COIF manages its own state using signals. Transport handles REST/GraphQL communication to any backend. No COPF engine required. Works like any headless component library with a network layer.

```
[Any Backend] → Transport (REST/GraphQL) → [Binding] → [COIF Widgets] → [FrameworkAdapter] → [Surface] → [UI]
                    ▲                                                         │
                    └──── PlatformAdapter maps to browser/mobile/watch/etc ───┘
```

**Coupled mode:** COIF binds directly to COPF concepts via the Binding concept in `"coupled"` mode. Concept state feeds signals automatically. Action invocations are wired to concept actions through syncs. Transport is bypassed — Binding communicates directly with the COPF engine.

```
[COPF Engine] ←→ [Binding (coupled)] ←→ [COIF Widgets] → [FrameworkAdapter] → [Surface] → [UI]
                                                                │
                                    PlatformAdapter maps to platform ─────────┘
```

The switch is a single Binding mode flag. Widget code, Navigator destinations, Shell zones, and PlatformAdapter mappings don't change.

---

## 2. The Specification Language Extensions

COIF extends COPF's `.concept` grammar with an optional `interface` section that declares how a concept's state and actions surface to users. This section is ignored by the COPF backend compiler — it's metadata consumed only by COIF's UISchema concept.

### 2.1 Grammar Extension

```
Section         = PurposeSection
                | StateSection
                | ActionSection
                | InvariantSection
                | CapabilitySection
                | InterfaceSection          -- NEW: COIF extension

InterfaceSection = "interface" "{" InterfaceEntry* "}"

InterfaceEntry  = FieldMapping | ActionMapping | ViewMapping

FieldMapping    = "field" IDENT "{" FieldProp* "}"
FieldProp       = IDENT ":" (STRING_LIT | IDENT | "{" FieldProp* "}") SEP?

ActionMapping   = "action" IDENT "{" ActionProp* "}"
ActionProp      = IDENT ":" (STRING_LIT | IDENT | "{" ActionProp* "}") SEP?

ViewMapping     = "view" IDENT "{" ViewProp* "}"
ViewProp        = IDENT ":" (STRING_LIT | IDENT | "{" ViewProp* "}") SEP?
```

### 2.2 Example: Annotated Concept

```
@version(1)
concept Article [A, U] {

  purpose {
    A publishable piece of content with title, body,
    author attribution, and timestamps.
  }

  state {
    title: A -> String
    body: A -> String
    author: A -> U
    createdAt: A -> DateTime
    updatedAt: A -> DateTime
    published: A -> Bool
  }

  actions {
    action create(article: A, title: String, body: String, author: U) {
      -> ok(article: A) { Create the article with timestamps. }
      -> invalid(message: String) { Validation failed. }
    }
    action update(article: A, title: option String, body: option String) {
      -> ok(article: A) { Update fields, touch updatedAt. }
      -> notfound(message: String) { Article doesn't exist. }
    }
    action publish(article: A) {
      -> ok(article: A) { Set published to true. }
      -> notfound(message: String) { Article doesn't exist. }
    }
    action delete(article: A) {
      -> ok(article: A) { Remove the article. }
      -> notfound(message: String) { Article doesn't exist. }
    }
  }

  interface {
    field title {
      widget: "text-input"
      label: "Title"
      placeholder: "Enter article title..."
      validation: { minLength: "1"; maxLength: "200" }
    }
    field body {
      widget: "rich-text"
      label: "Body"
      placeholder: "Write your article..."
    }
    field published {
      widget: "toggle"
      label: "Published"
    }
    field createdAt {
      widget: "datetime-display"
      label: "Created"
      readOnly: "true"
    }
    action create {
      label: "Create Article"
      icon: "plus"
      variant: "primary"
    }
    action publish {
      label: "Publish"
      icon: "send"
      variant: "accent"
      confirm: "Are you sure you want to publish this article?"
    }
    action delete {
      label: "Delete"
      icon: "trash"
      variant: "danger"
      confirm: "This action cannot be undone."
    }
    view list {
      columns: "title, author, published, updatedAt"
      defaultSort: "updatedAt"
      sortDirection: "desc"
      searchable: "title, body"
    }
    view detail {
      layout: "title, body, published, author, createdAt, updatedAt"
      actions: "update, publish, delete"
    }
    view create {
      fields: "title, body"
      submit: "create"
    }
  }

  invariant {
    after create(article: x, title: "Test", body: "Content", author: u)
      -> ok(article: x)
    then publish(article: x) -> ok(article: x)
  }
}
```

### 2.3 Interface Section Design Notes

The `interface` section is deliberately **flat and declarative** — key-value pairs, not a programming language. This is intentional:

- **LLMs can generate it** from natural language descriptions.
- **Non-developers can read it** — a designer can understand `widget: "rich-text"` and `variant: "primary"`.
- **It's override-friendly** — the UISchema concept generates defaults for every field/action, and the interface section overrides only what needs customization.
- **It's forward-compatible** — new widget types and properties can be added without grammar changes since values are strings parsed by the UISchema concept, not the spec compiler.

Fields not mentioned in the `interface` section get auto-generated defaults based on type mapping rules (see Section 8).

---

## 3. Core Concepts

COIF is implemented as 23 concepts organized into 5 kits. Every concept follows COPF's spec format — sovereign storage, typed actions with return variants, no inter-concept references.

### Concept Overview

**coif-core kit** (foundation — always loaded):

| Concept | Purpose |
|---------|---------|
| DesignToken | Store design decisions as structured, platform-agnostic data |
| Element | Abstract, modality-independent interaction units |
| UISchema | Inspect concept specs → generate UI schemas |
| Binding | Map COPF concept state/actions to interface signals |
| Signal | Reactive state container for concept data |

**coif-component kit** (headless behaviors):

| Concept | Purpose |
|---------|---------|
| Widget | Headless state machine catalog for UI widgets |
| Machine | Finite state machine runtime for component behavior |
| Anatomy | Named parts contract between behavior and rendering |
| Slot | Named insertion points for composition |

**coif-render kit** (framework adapters):

| Concept | Purpose |
|---------|---------|
| FrameworkAdapter | Framework adapter registry, lifecycle, and rendering |
| Surface | Deployment target with mount/unmount lifecycle |
| Layout | Spatial arrangement of components on a surface |
| Viewport | Responsive breakpoint and adaptation logic |

**coif-theme kit** (visual design):

| Concept | Purpose |
|---------|---------|
| Theme | Compose tokens into a complete visual language |
| Palette | Color system with semantic roles and accessibility |
| Typography | Type scale, font stacks, and text styles |
| Motion | Animation timing, easing, and transition definitions |
| Elevation | Shadow and depth system |

**coif-app kit** (application orchestration):

| Concept | Purpose |
|---------|---------|
| Navigator | Abstract navigation between destinations, platform-agnostic |
| Host | Widget tree lifecycle orchestrator — implements `coif.auto()` |
| Transport | Network communication for Binding data synchronization |
| Shell | Root app composition with semantic zone roles |
| PlatformAdapter | Thin platform-specific mapping (~100-200 LOC each) |

### 3.1 DesignToken

```
@version(1)
concept DesignToken [T] {

  purpose {
    Store design decisions as structured, platform-agnostic data.
    Tokens are the atomic unit of visual design — a color value,
    a spacing size, a font family. They form a three-tier
    hierarchy: primitive (raw values), semantic (meaning/purpose),
    and component (bound to specific UI elements). Follows the
    W3C Design Tokens Community Group specification (2025.10).
  }

  state {
    name: T -> String
    value: T -> String
    type: T -> String
    tier: T -> String
    description: T -> option String
    reference: T -> option T
    group: T -> option String
    extensions: T -> option String
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action define(token: T, name: String, value: String, type: String, tier: String) {
      -> ok(token: T) {
        Register a new token. Type is one of: color, dimension,
        fontFamily, fontWeight, duration, cubicBezier, shadow,
        border, typography, gradient. Tier is one of: primitive,
        semantic, component.
      }
      -> duplicate(message: String) {
        A token with this name already exists in this group.
      }
    }

    action alias(token: T, name: String, reference: T, tier: String) {
      -> ok(token: T) {
        Create a token that references another token's value.
        The alias resolves at consumption time, enabling theming
        by remapping semantic tokens to different primitives.
      }
      -> notfound(message: String) { The referenced token does not exist. }
      -> cycle(message: String) { The alias would create a circular reference chain. }
    }

    action resolve(token: T) {
      -> ok(token: T, resolvedValue: String) {
        Walk the reference chain and return the final concrete value.
      }
      -> notfound(message: String) { The token does not exist. }
      -> broken(message: String, brokenAt: T) { The reference chain is broken. }
    }

    action update(token: T, value: option String) {
      -> ok(token: T) { Update the token's value or reference target. }
      -> notfound(message: String) { The token does not exist. }
    }

    action remove(token: T) {
      -> ok(token: T) { Delete the token. Aliases pointing here become broken. }
      -> notfound(message: String) { The token does not exist. }
    }

    action export(format: String) {
      -> ok(output: String) {
        Export all tokens. Formats: "dtcg" (W3C JSON), "css"
        (Custom Properties), "swift", "kotlin", "json".
      }
      -> unsupported(message: String) { Format not supported. }
    }
  }

  invariant {
    after define(token: t, name: "blue-500", value: "#3b82f6",
                 type: "color", tier: "primitive") -> ok(token: t)
    then resolve(token: t) -> ok(token: t, resolvedValue: "#3b82f6")
  }
}
```

### 3.2 Element

```
@version(1)
concept Element [E] {

  purpose {
    Abstract, modality-independent interaction units. An Element
    describes WHAT a user can do — select, input, trigger, navigate,
    display — without specifying HOW it renders. Drawn from the
    CAMELEON Reference Framework's Abstract Interaction Objects.
    The same Element renders as a dropdown in GUI, a prompt in CLI,
    an enum in API, or a picker in mobile.
  }

  state {
    kind: E -> String
    label: E -> String
    description: E -> option String
    dataType: E -> String
    required: E -> Bool
    constraints: E -> option String
    children: E -> list E
    parent: E -> option E
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action create(element: E, kind: String, label: String, dataType: String) {
      -> ok(element: E) {
        Create an abstract element. Kind is one of:
        input-text, input-number, input-date, input-bool,
        selection-single, selection-multi, trigger, navigation,
        output-text, output-number, output-date, output-bool,
        group, container, rich-text, file-upload, media-display.
      }
      -> invalid(message: String) { The kind is not recognized. }
    }

    action nest(parent: E, child: E) {
      -> ok(parent: E) { Add a child to a group or container. }
      -> invalid(message: String) { Parent cannot contain children. }
    }

    action setConstraints(element: E, constraints: String) {
      -> ok(element: E) {
        Apply constraints as JSON: min, max, minLength,
        maxLength, pattern, options (for selections).
      }
      -> notfound(message: String) { Element does not exist. }
    }

    action remove(element: E) {
      -> ok(element: E) { Remove element and detach children. }
      -> notfound(message: String) { Element does not exist. }
    }
  }

  invariant {
    after create(element: e, kind: "input-text", label: "Title",
                 dataType: "String") -> ok(element: e)
    then remove(element: e) -> ok(element: e)
  }
}
```

### 3.3 UISchema

```
@version(1)
concept UISchema [S, C] {

  purpose {
    Inspect a COPF concept spec and generate a UI schema — the
    complete description of how that concept should be presented.
    Implements the dual-schema pattern: data schema (from .concept
    spec) is the source, UI schema (generated here) is the
    presentation layer. This is the Metawidget-style inspection
    pipeline: inspect → apply defaults → apply overrides → produce
    element tree.
  }

  state {
    concept: S -> C
    elements: S -> list String
    uiSchema: S -> String
    overrides: S -> option String
    generatedAt: S -> DateTime
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action inspect(schema: S, conceptSpec: String) {
      -> ok(schema: S) {
        Parse the concept spec. Extract state fields, actions, and
        return variants. Apply type-mapping rules (String → input-text,
        Int → input-number, Bool → toggle, etc.). Generate default
        views: list, detail, create, edit. If spec contains an
        interface section, apply overrides on top of defaults.
      }
      -> parseError(message: String) { The concept spec could not be parsed. }
    }

    action override(schema: S, overrides: String) {
      -> ok(schema: S) {
        Apply partial UI schema on top of the generated one.
        Merges at field/action/view level — only specified
        properties are replaced.
      }
      -> notfound(message: String) { No schema exists for this concept. }
      -> invalid(message: String) { Override JSON is malformed. }
    }

    action getSchema(schema: S) {
      -> ok(schema: S, uiSchema: String) { Return current UI schema as JSON. }
      -> notfound(message: String) { No schema exists. }
    }

    action getElements(schema: S) {
      -> ok(elements: String) {
        Return abstract element tree as JSON — intermediate
        representation consumed by Widget concept.
      }
      -> notfound(message: String) { No schema exists. }
    }
  }

  invariant {
    after inspect(schema: s, conceptSpec: "concept Test [T] { state { name: T -> String } actions { action create(t: T, name: String) { -> ok(t: T) { Create it. } } } }")
      -> ok(schema: s)
    then getSchema(schema: s) -> ok(schema: s, uiSchema: _)
  }
}
```

### 3.4 Binding

```
@version(1)
concept Binding [B, C] {

  purpose {
    Bridge between COPF backend concepts and COIF frontend
    signals. In coupled mode, subscribes to concept state changes
    via COPF's action completion stream and pushes updates to
    signals. Routes user-triggered actions back as invocations.
    In standalone mode, wraps a data source (REST, GraphQL,
    static) and presents it through the same signal interface.
  }

  state {
    concept: B -> C
    mode: B -> String
    endpoint: B -> option String
    lastSync: B -> option DateTime
    status: B -> String
    signalMap: B -> String
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action bind(binding: B, concept: C, mode: String) {
      -> ok(binding: B) {
        Create a binding. Mode: "coupled" (direct COPF engine),
        "rest" (REST API), "graphql" (subscription),
        "static" (in-memory). Generates signal map: one signal
        per state field, one command per action.
      }
      -> invalid(message: String) { Mode not recognized or concept unreachable. }
    }

    action sync(binding: B) {
      -> ok(binding: B) { Pull latest state and update signals. }
      -> error(message: String) { Backend unreachable. }
    }

    action invoke(binding: B, action: String, input: String) {
      -> ok(binding: B, result: String) {
        Invoke an action on the bound concept. Routes to
        appropriate backend based on mode. Returns completion.
      }
      -> error(message: String) { Invocation failed. }
    }

    action unbind(binding: B) {
      -> ok(binding: B) { Remove binding, unsubscribe, dispose signals. }
      -> notfound(message: String) { Binding does not exist. }
    }
  }

  invariant {
    after bind(binding: b, concept: c, mode: "static")
      -> ok(binding: b)
    then unbind(binding: b) -> ok(binding: b)
  }
}
```

### 3.5 Signal

```
@version(1)
concept Signal [G] {

  purpose {
    Reactive state container aligned with TC39 Signals proposal.
    A getter/setter pair with automatic dependency tracking. When
    a signal's value changes, all computed signals and effects that
    read from it re-execute — and only those. Each concept binding
    produces one signal per state field. Signals are runtime-only.
  }

  state {
    value: G -> String
    kind: G -> String
    dependencies: G -> set G
    subscribers: G -> set G
    version: G -> Int
  }

  actions {
    action create(signal: G, kind: String, initialValue: String) {
      -> ok(signal: G) {
        Create a signal. Kind: "state" (writable), "computed"
        (read-only derived), "effect" (side-effect on change).
      }
      -> invalid(message: String) { Kind not recognized. }
    }

    action read(signal: G) {
      -> ok(signal: G, value: String, version: Int) {
        Read current value and register caller as dependency.
      }
      -> notfound(message: String) { Signal does not exist. }
    }

    action write(signal: G, value: String) {
      -> ok(signal: G, version: Int) {
        Update value, increment version, notify subscribers.
        Notifications batched within a microtask.
      }
      -> readonly(message: String) { Cannot write to computed signal. }
      -> notfound(message: String) { Signal does not exist. }
    }

    action batch(signals: String) {
      -> ok(count: Int) {
        Update multiple signals atomically. Subscribers notified
        once after all updates, not per-signal.
      }
      -> partial(message: String, succeeded: Int, failed: Int) {
        Some updates failed.
      }
    }

    action dispose(signal: G) {
      -> ok(signal: G) { Remove signal, unsubscribe from dependencies. }
      -> notfound(message: String) { Signal does not exist. }
    }
  }

  invariant {
    after create(signal: g, kind: "state", initialValue: "hello")
      -> ok(signal: g)
    then read(signal: g) -> ok(signal: g, value: "hello", version: _)
  }
}
```

### 3.6 Widget

```
@version(1)
concept Widget [P] {

  purpose {
    Headless state machine catalog. Each component type is a named
    behavioral specification — complete widget logic without rendering.
    Inspired by Zag.js: components are finite state machines that
    produce a props API via connect(), consumable by any framework.
    Standard library: button, input, textarea, select, checkbox,
    radio, toggle, dialog, popover, tooltip, tabs, accordion, menu,
    combobox, datepicker, slider, toast, alert, table, form,
    listview, card, avatar, badge, breadcrumb, pagination, progress,
    skeleton, spinner.
  }

  state {
    name: P -> String
    anatomy: P -> String
    defaultConfig: P -> String
    machineSpec: P -> String
    a11ySpec: P -> String
    category: P -> String
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action register(component: P, name: String, machineSpec: String,
                    anatomy: String, a11ySpec: String) {
      -> ok(component: P) {
        Register a component type. machineSpec: JSON state machine
        (states, transitions, guards, actions). anatomy: named parts.
        a11ySpec: ARIA attributes, keyboard interactions, focus management.
      }
      -> duplicate(message: String) { Already registered. }
    }

    action configure(component: P, config: String) {
      -> ok(component: P) { Set default config (initial machine context). }
      -> notfound(message: String) { Not registered. }
    }

    action get(component: P) {
      -> ok(component: P, machineSpec: String, anatomy: String, a11ySpec: String) {
        Retrieve full specification for instantiation.
      }
      -> notfound(message: String) { Not registered. }
    }

    action list(category: option String) {
      -> ok(components: String) {
        List registered types. Categories: input, display,
        overlay, navigation, feedback, layout, composite.
      }
    }

    action unregister(component: P) {
      -> ok(component: P) { Remove from registry. }
      -> notfound(message: String) { Not registered. }
    }
  }

  invariant {
    after register(component: p, name: "button",
                   machineSpec: "{ \"initial\": \"idle\" }",
                   anatomy: "{ \"parts\": [\"root\"] }",
                   a11ySpec: "{ \"role\": \"button\" }")
      -> ok(component: p)
    then get(component: p) -> ok(component: p, machineSpec: _, anatomy: _, a11ySpec: _)
  }
}
```

### 3.7 Machine

```
@version(1)
concept Machine [M] {

  purpose {
    Finite state machine runtime. Instantiates and executes
    behavioral state machines defined by Widget. A Machine
    instance holds current state, processes events, executes
    guards and actions, and produces output via connect().

    The connect() function transforms machine state into a
    framework-neutral props API. For a dialog in "open" state:
    { getRootProps(), getTriggerProps(), getContentProps(),
      isOpen: true, open(), close() }

    These props are plain objects — no framework dependency.
    Each FrameworkAdapter transforms them into framework bindings.
  }

  state {
    current: M -> String
    context: M -> String
    component: M -> String
    status: M -> String
  }

  actions {
    action spawn(machine: M, component: String, context: String) {
      -> ok(machine: M) {
        Create machine instance from registered component type.
        Initialize with component defaults merged with context.
      }
      -> notfound(message: String) { Widget type not registered. }
    }

    action send(machine: M, event: String) {
      -> ok(machine: M, state: String) {
        Send event to machine. Evaluates transitions from current
        state: checks guards, executes actions, moves to target.
        Events: { "type": "OPEN" } or { "type": "SET_VALUE", "value": "..." }
      }
      -> invalid(message: String) { Event not valid in current state. }
      -> notfound(message: String) { Machine does not exist. }
    }

    action connect(machine: M) {
      -> ok(machine: M, props: String) {
        Produce framework-neutral props API. JSON object where keys
        are anatomy part names and values are prop objects with
        event handlers, ARIA attributes, data attributes, state flags.
      }
      -> notfound(message: String) { Machine does not exist. }
    }

    action destroy(machine: M) {
      -> ok(machine: M) { Tear down, run exit actions, clean up timers. }
      -> notfound(message: String) { Machine does not exist. }
    }
  }

  invariant {
    after spawn(machine: m, component: "dialog",
                context: "{ \"open\": false }")
      -> ok(machine: m)
    then connect(machine: m) -> ok(machine: m, props: _)
  }
}
```

### 3.8 Anatomy

```
@version(1)
concept Anatomy [N] {

  purpose {
    Named parts contract between component behavior and rendering.
    Every headless component declares its anatomy — the named
    elements constituting its structure. A Dialog's anatomy:
    root, trigger, backdrop, positioner, content, title,
    description, closeTrigger. This is the Ark UI/Zag contract:
    behavior and rendering agree on part names, nothing else.
  }

  state {
    component: N -> String
    parts: N -> list String
    slots: N -> list String
    description: N -> option String
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action define(anatomy: N, component: String, parts: String, slots: String) {
      -> ok(anatomy: N) {
        Define anatomy for a component type. Parts: JSON array
        of part names. Slots: JSON array of insertion points.
      }
      -> duplicate(message: String) { Already defined. }
    }

    action getParts(anatomy: N) {
      -> ok(parts: String) { Return ordered part names. }
      -> notfound(message: String) { Not defined. }
    }

    action getSlots(anatomy: N) {
      -> ok(slots: String) { Return available slots. }
      -> notfound(message: String) { Not defined. }
    }

    action extend(anatomy: N, additionalParts: String) {
      -> ok(anatomy: N) { Add parts for component variants. }
      -> notfound(message: String) { Not defined. }
    }
  }

  invariant {
    after define(anatomy: n, component: "dialog",
                 parts: "[\"root\",\"trigger\",\"content\",\"title\"]",
                 slots: "[\"header\",\"body\",\"footer\"]")
      -> ok(anatomy: n)
    then getParts(anatomy: n)
      -> ok(parts: "[\"root\",\"trigger\",\"content\",\"title\"]")
  }
}
```

### 3.9 Slot

```
@version(1)
concept Slot [L] {

  purpose {
    Named insertion points for component composition. Enables the
    compound component pattern without coupling. Replaces Atomic
    Design's rigid hierarchy with flexible, on-demand composition.
    Supports named slots, default slots, and scoped slots.
  }

  state {
    name: L -> String
    component: L -> String
    defaultContent: L -> option String
    scope: L -> option String
    filled: L -> Bool
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action define(slot: L, name: String, component: String) {
      -> ok(slot: L) { Define a slot on a component. }
      -> invalid(message: String) { Anatomy does not include this slot. }
    }

    action fill(slot: L, content: String) {
      -> ok(slot: L) {
        Fill with content: component reference, raw content,
        or scoped render function key.
      }
      -> notfound(message: String) { Slot does not exist. }
    }

    action setDefault(slot: L, defaultContent: String) {
      -> ok(slot: L) { Set fallback content when no fill provided. }
      -> notfound(message: String) { Slot does not exist. }
    }

    action clear(slot: L) {
      -> ok(slot: L) { Remove fill, revert to default. }
      -> notfound(message: String) { Slot does not exist. }
    }
  }

  invariant {
    after define(slot: l, name: "header", component: "card")
      -> ok(slot: l)
    then fill(slot: l, content: "{ \"type\": \"text\", \"value\": \"Hello\" }")
      -> ok(slot: l)
  }
}
```

### 3.10 FrameworkAdapter

```
@version(1)
concept FrameworkAdapter [R] {

  purpose {
    Framework adapter registry. Translates Machine connect() output
    into framework-specific bindings. Implements normalizeProps()
    — the thin layer between COIF's generic event model and
    framework conventions (React SyntheticEvent, Solid native
    events, Vue v-on). Each adapter is ~200 LOC.
  }

  state {
    framework: R -> String
    version: R -> String
    status: R -> String
    normalizer: R -> String
    mountFn: R -> String
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action register(renderer: R, framework: String, version: String,
                    normalizer: String, mountFn: String) {
      -> ok(renderer: R) {
        Register adapter. Framework: "react", "solid", "vue",
        "svelte", "ink", "vanilla", "react-native", "angular".
      }
      -> duplicate(message: String) { Already registered. }
    }

    action normalize(renderer: R, props: String) {
      -> ok(normalized: String) { Transform to framework-specific bindings. }
      -> notfound(message: String) { Not registered. }
    }

    action mount(renderer: R, machine: String, target: String) {
      -> ok(renderer: R) { Create and mount a single machine's component. }
      -> error(message: String) { Mount failed. }
    }

    action render(renderer: R, tree: String, target: String) {
      -> ok(renderer: R) {
        Render a complete component tree to a target. Takes a tree
        of machine props (collected from a Host's machine set),
        composes them into a framework-specific component hierarchy,
        and calls the framework's root mount function:
        - React: ReactDOM.createRoot(target).render(tree)
        - Solid: render(() => tree, target)
        - Ink: render(tree)
        - React Native: AppRegistry.registerComponent
        Used by Host after collecting all spawned machines.
      }
      -> error(message: String) { Render failed. }
    }

    action unmount(renderer: R, target: String) {
      -> ok(renderer: R) { Unmount and clean up. }
      -> notfound(message: String) { Nothing mounted at target. }
    }
  }

  invariant {
    after register(renderer: r, framework: "react", version: "19",
                   normalizer: "reactNormalizer", mountFn: "reactMount")
      -> ok(renderer: r)
    then normalize(renderer: r, props: "{ \"onClick\": \"handler_1\" }")
      -> ok(normalized: _)
  }
}
```

### 3.11 Surface

```
@version(1)
concept Surface [F] {

  purpose {
    Deployment target. A Surface represents where the interface
    renders — browser DOM, terminal, native view, API endpoint.
    Handles initialization, capability detection, and lifecycle.
  }

  state {
    kind: F -> String
    capabilities: F -> set String
    status: F -> String
    mountPoint: F -> option String
    config: F -> option String
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action create(surface: F, kind: String, mountPoint: option String) {
      -> ok(surface: F) {
        Create surface. Kind: "browser-dom", "terminal",
        "react-native", "webview", "ssr", "static-html".
        Auto-detects capabilities.
      }
      -> unsupported(message: String) { Kind not supported in this runtime. }
    }

    action attach(surface: F, renderer: String) {
      -> ok(surface: F) { Attach renderer, validate compatibility. }
      -> incompatible(message: String) { FrameworkAdapter incompatible with surface. }
    }

    action resize(surface: F, width: Int, height: Int) {
      -> ok(surface: F) { Report size change, trigger viewport recalc. }
      -> notfound(message: String) { Surface does not exist. }
    }

    action mount(surface: F, tree: String, zone: option String) {
      -> ok(surface: F) {
        Render a component tree to the surface. If zone specified,
        mount into that sub-region. Calls the attached FrameworkAdapter's
        render function (e.g., ReactDOM.createRoot().render() for
        browser-dom, Ink render() for terminal).
      }
      -> error(message: String) { No adapter attached or mount target missing. }
      -> notfound(message: String) { Surface does not exist. }
    }

    action unmount(surface: F, zone: option String) {
      -> ok(surface: F) {
        Unmount component tree from surface or zone. Calls
        framework-specific cleanup. If no zone, unmounts root.
      }
      -> notfound(message: String) { Nothing mounted in zone. }
    }

    action destroy(surface: F) {
      -> ok(surface: F) { Tear down, unmount all renderers. }
      -> notfound(message: String) { Surface does not exist. }
    }
  }

  invariant {
    after create(surface: f, kind: "browser-dom", mountPoint: "#app")
      -> ok(surface: f)
    then destroy(surface: f) -> ok(surface: f)
  }
}
```

### 3.12 Layout

```
@version(1)
concept Layout [Y] {

  purpose {
    Spatial arrangement of components. Describes positioning
    without specifying CSS or terminal coordinates — constraint-based
    descriptions interpreted per-Surface. Layouts compose recursively:
    a page layout contains region layouts containing component layouts.
  }

  state {
    name: Y -> String
    kind: Y -> String
    direction: Y -> option String
    gap: Y -> option String
    columns: Y -> option String
    rows: Y -> option String
    areas: Y -> option String
    children: Y -> list Y
    responsive: Y -> option String
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action create(layout: Y, name: String, kind: String) {
      -> ok(layout: Y) {
        Create layout. Kind: "stack", "grid", "split", "overlay",
        "flow", "sidebar", "center".
      }
      -> invalid(message: String) { Kind not recognized. }
    }

    action configure(layout: Y, config: String) {
      -> ok(layout: Y) {
        Apply config: direction, gap (token ref), columns/rows,
        areas, alignment, padding.
      }
      -> notfound(message: String) { Layout does not exist. }
    }

    action nest(parent: Y, child: Y) {
      -> ok(parent: Y) { Nest layout inside another. }
      -> cycle(message: String) { Would create circular reference. }
    }

    action setResponsive(layout: Y, breakpoints: String) {
      -> ok(layout: Y) {
        Define responsive overrides keyed by breakpoint (sm, md, lg, xl).
      }
      -> notfound(message: String) { Layout does not exist. }
    }

    action remove(layout: Y) {
      -> ok(layout: Y) { Remove and detach children. }
      -> notfound(message: String) { Layout does not exist. }
    }
  }

  invariant {
    after create(layout: y, name: "main", kind: "sidebar")
      -> ok(layout: y)
    then configure(layout: y, config: "{ \"direction\": \"row\", \"gap\": \"space-4\" }")
      -> ok(layout: y)
  }
}
```

### 3.13 Viewport

```
@version(1)
concept Viewport [V] {

  purpose {
    Responsive breakpoint and adaptation. Observes surface dimensions,
    evaluates breakpoint conditions, produces active breakpoints for
    Layout and Widget via signals. Defaults: xs (0-479), sm (480-767),
    md (768-1023), lg (1024-1279), xl (1280+).
  }

  state {
    width: V -> Int
    height: V -> Int
    breakpoint: V -> String
    orientation: V -> String
    customBreakpoints: V -> option String
  }

  actions {
    action observe(viewport: V, width: Int, height: Int) {
      -> ok(viewport: V, breakpoint: String, orientation: String) {
        Report dimensions, return active breakpoint and orientation.
      }
    }

    action setBreakpoints(viewport: V, breakpoints: String) {
      -> ok(viewport: V) { Override defaults. }
      -> invalid(message: String) { Values must be ascending positive integers. }
    }

    action getBreakpoint(viewport: V) {
      -> ok(viewport: V, breakpoint: String, width: Int, height: Int) {
        Return current breakpoint and dimensions.
      }
      -> notfound(message: String) { Viewport not initialized. }
    }
  }

  invariant {
    after observe(viewport: v, width: 1024, height: 768)
      -> ok(viewport: v, breakpoint: "lg", orientation: "landscape")
    then getBreakpoint(viewport: v)
      -> ok(viewport: v, breakpoint: "lg", width: 1024, height: 768)
  }
}
```

### 3.14 Theme

```
@version(1)
concept Theme [H] {

  purpose {
    Compose tokens into a complete visual language. A Theme is a
    named collection of token overrides: "dark" remaps color-background
    from white to gray-900. Themes are layered: base + variants.
    Multiple variants can be active (dark + compact + high-contrast).
    Conflicts resolve by specificity then activation order.
  }

  state {
    name: H -> String
    base: H -> option H
    overrides: H -> String
    active: H -> Bool
    priority: H -> Int
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action create(theme: H, name: String, overrides: String) {
      -> ok(theme: H) { Create theme with token overrides JSON. }
      -> duplicate(message: String) { Already exists. }
    }

    action extend(theme: H, base: H, overrides: String) {
      -> ok(theme: H) { Create theme extending a base. }
      -> notfound(message: String) { Base does not exist. }
    }

    action activate(theme: H, priority: Int) {
      -> ok(theme: H) { Activate — overrides take effect immediately. }
      -> notfound(message: String) { Does not exist. }
    }

    action deactivate(theme: H) {
      -> ok(theme: H) { Deactivate — values revert. }
      -> notfound(message: String) { Does not exist. }
    }

    action resolve(theme: H) {
      -> ok(tokens: String) {
        Return fully resolved token map: all base + overrides,
        aliases resolved to final values.
      }
      -> notfound(message: String) { Does not exist. }
    }
  }

  invariant {
    after create(theme: h, name: "dark",
                 overrides: "{ \"color-bg\": \"#1a1a1a\" }")
      -> ok(theme: h)
    then activate(theme: h, priority: 1) -> ok(theme: h)
    and resolve(theme: h) -> ok(tokens: _)
  }
}
```

### 3.15 Palette

```
@version(1)
concept Palette [C] {

  purpose {
    Color system with semantic roles and WCAG accessibility enforcement.
    Generates complete 50-950 color scales from seed colors using
    perceptual color space (OKLCH). Every color pair validated against
    WCAG 2.1: AA (4.5:1 normal, 3:1 large) and AAA (7:1 normal).
  }

  state {
    name: C -> String
    hue: C -> Float
    scale: C -> String
    role: C -> option String
    contrastRatio: C -> option Float
  }

  actions {
    action generate(palette: C, name: String, seed: String) {
      -> ok(palette: C, scale: String) {
        Generate 50-950 color scale from seed using OKLCH.
      }
      -> invalid(message: String) { Not a valid color. }
    }

    action assignRole(palette: C, role: String) {
      -> ok(palette: C) {
        Assign semantic role: primary, secondary, accent, success,
        warning, error, neutral, surface. Auto-generates semantic tokens.
      }
      -> notfound(message: String) { Palette does not exist. }
    }

    action checkContrast(foreground: C, background: C) {
      -> ok(ratio: Float, passesAA: Bool, passesAAA: Bool) {
        Calculate contrast ratio and report WCAG compliance.
      }
      -> notfound(message: String) { Color not found. }
    }
  }

  invariant {
    after generate(palette: c, name: "blue", seed: "#3b82f6")
      -> ok(palette: c, scale: _)
    then assignRole(palette: c, role: "primary") -> ok(palette: c)
  }
}
```

### 3.16 Typography

```
@version(1)
concept Typography [X] {

  purpose {
    Type scale, font stacks, and text styles. Generates harmonious
    type scale from modular ratio (default: major third, 1.25).
    Composes scale sizes with font stacks and weights into named
    presets: heading-1, body, caption, label, code.
  }

  state {
    name: X -> String
    kind: X -> String
    value: X -> String
    scale: X -> option String
  }

  actions {
    action defineScale(typography: X, baseSize: Float, ratio: Float, steps: Int) {
      -> ok(typography: X, scale: String) {
        Generate type scale: { "xs": 12, "sm": 14, "base": 16, ... }
      }
      -> invalid(message: String) { Base must be positive, ratio > 1. }
    }

    action defineFontStack(typography: X, name: String, fonts: String, category: String) {
      -> ok(typography: X) { Register font stack. Category: serif, sans-serif, monospace, display. }
      -> duplicate(message: String) { Already exists. }
    }

    action defineStyle(typography: X, name: String, config: String) {
      -> ok(typography: X) {
        Create named text style: { "scale": "xl", "fontStack": "heading",
        "weight": 700, "lineHeight": 1.2, "letterSpacing": "-0.02em" }
      }
      -> invalid(message: String) { Referenced scale or fontStack not found. }
    }
  }

  invariant {
    after defineScale(typography: x, baseSize: 16, ratio: 1.25, steps: 6)
      -> ok(typography: x, scale: _)
    then defineStyle(typography: x, name: "heading-1",
                     config: "{ \"scale\": \"3xl\", \"weight\": 700 }")
      -> ok(typography: x)
  }
}
```

### 3.17 Motion

```
@version(1)
concept Motion [O] {

  purpose {
    Animation timing, easing, and transitions. All values are
    named, referenceable, and overridable via themes. Respects
    prefers-reduced-motion: all durations collapse to 0ms.
  }

  state {
    name: O -> String
    kind: O -> String
    value: O -> String
    reducedMotion: O -> option String
  }

  actions {
    action defineDuration(motion: O, name: String, ms: Int) {
      -> ok(motion: O) {
        Named duration. Standard: instant (0), fast (100),
        normal (200), slow (300), slower (500).
      }
      -> invalid(message: String) { Must be non-negative. }
    }

    action defineEasing(motion: O, name: String, value: String) {
      -> ok(motion: O) { Named easing curve (CSS cubic-bezier or keyword). }
      -> invalid(message: String) { Invalid easing value. }
    }

    action defineTransition(motion: O, name: String, config: String) {
      -> ok(motion: O) {
        Named transition preset: { "property": "opacity",
        "duration": "normal", "easing": "ease-out" }
      }
      -> invalid(message: String) { Referenced duration or easing not found. }
    }
  }

  invariant {
    after defineDuration(motion: o, name: "normal", ms: 200) -> ok(motion: o)
    then defineEasing(motion: o2, name: "ease-out",
                      value: "cubic-bezier(0, 0, 0.2, 1)") -> ok(motion: o2)
  }
}
```

### 3.18 Elevation

```
@version(1)
concept Elevation [W] {

  purpose {
    Shadow and depth system. Numbered scale (0-5):
    0 = flat, 1 = raised, 2 = floating, 3 = overlay,
    4 = modal, 5 = top. Each level uses multi-layer shadows.
    Adapts to theme: light uses gray shadows, dark uses
    darker shadows or ambient glow.
  }

  state {
    level: W -> Int
    shadow: W -> String
    color: W -> option String
  }

  actions {
    action define(elevation: W, level: Int, shadow: String) {
      -> ok(elevation: W) {
        Define shadow for elevation level. Shadow: JSON array
        of layers: [{ "y": 2, "blur": 4, "color": "rgba(0,0,0,0.1)" }]
      }
      -> invalid(message: String) { Level must be 0-5. }
    }

    action get(elevation: W) {
      -> ok(elevation: W, shadow: String) { Return shadow definition. }
      -> notfound(message: String) { Not defined for this level. }
    }

    action generateScale(baseColor: String) {
      -> ok(shadows: String) {
        Auto-generate all 6 levels from base shadow color.
      }
      -> invalid(message: String) { Invalid color. }
    }
  }

  invariant {
    after define(elevation: w, level: 2,
                 shadow: "[{ \"y\": 4, \"blur\": 8, \"color\": \"rgba(0,0,0,0.12)\" }]")
      -> ok(elevation: w)
    then get(elevation: w) -> ok(elevation: w, shadow: _)
  }
}
```

### 3.19 Navigator

```
@version(1)
concept Navigator [N] {

  purpose {
    Abstract navigation between destinations. A destination is a
    named configuration: { concept, view, params }. Transitions
    move between destinations with optional guards, animations,
    and history tracking.

    Navigator knows nothing about URLs, screen stacks, or tabs.
    Platform adapters translate Navigator state to platform
    primitives: browser history, React Navigation stacks,
    WatchOS page lists, terminal screen buffers.

    Destinations carry platform hints in meta (urlPattern,
    stackBehavior, tabGroup, windowConfig) consumed by adapters
    but ignored by Navigator itself.
  }

  state {
    destinations: N -> String      # Registered destination map JSON
    current: N -> option String    # Current destination ID
    params: N -> String            # Extracted params JSON
    history: N -> list String      # Destination history stack
    guards: N -> String            # Transition guards JSON
    graph: N -> String             # Allowed transitions (adjacency list or "*")
    depth: N -> Int                # Current stack depth (for nested nav)
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action register(nav: N, destination: String, config: String) {
      -> ok(nav: N) {
        Register a destination. Config:
        { id, concept, view, paramsSchema, guard, meta }.
        Meta carries platform hints consumed by PlatformAdapter:
        { urlPattern: "/articles/:id", stackBehavior: "push",
          tabGroup: "content", windowConfig: { ... } }.
      }
      -> conflict(message: String) { Destination ID already registered. }
    }

    action go(nav: N, destination: String, params: String) {
      -> ok(nav: N, resolved: String) {
        Navigate to destination. Evaluates guards on current
        destination (can-leave?) and target (can-enter?).
        Pushes to history. Returns resolved config with params.
      }
      -> blocked(message: String) { Guard prevented transition. }
      -> notfound(message: String) { Destination not registered. }
    }

    action back(nav: N) {
      -> ok(nav: N) { Pop history, go to previous destination. }
      -> empty(message: String) { History stack empty. }
    }

    action forward(nav: N) {
      -> ok(nav: N) { Navigate forward in history. }
      -> empty(message: String) { No forward history. }
    }

    action replace(nav: N, destination: String, params: String) {
      -> ok(nav: N) { Replace current without pushing history. }
      -> notfound(message: String) { Destination not registered. }
    }

    action reset(nav: N, destination: String, params: String) {
      -> ok(nav: N) {
        Clear history and navigate. Used for auth redirects,
        deep link handling, "start over" flows.
      }
      -> notfound(message: String) { Destination not registered. }
    }

    action addGuard(nav: N, guard: String) {
      -> ok(nav: N) {
        Add navigation guard. Evaluated before leaving current
        destination. Returns { allow, reason, action }.
      }
      -> invalid(message: String) { Guard spec invalid. }
    }

    action removeGuard(nav: N, guard: String) {
      -> ok(nav: N) { Remove a guard. }
      -> notfound(message: String) { Guard not found. }
    }

    action canGo(nav: N, destination: String) {
      -> ok(nav: N, allowed: String) {
        Check if transition is allowed without performing it.
        Returns { allowed: bool, reason: string }.
      }
      -> notfound(message: String) { Destination not registered. }
    }
  }

  invariant {
    after register(nav: n, destination: "detail",
      config: "{ \"concept\": \"Article\", \"view\": \"detail\" }")
      -> ok(nav: n)
    then go(nav: n, destination: "detail", params: "{ \"id\": 123 }")
      -> ok(nav: n, resolved: _)
  }
}
```

### 3.20 Host

```
@version(1)
concept Host [W] {

  purpose {
    Orchestrate the full lifecycle of rendering a concept instance
    as a widget tree. Host is the missing integration layer — it
    triggers Binding/bind (starting the sync cascade through UISchema,
    Elements, Widgets, Machines, FrameworkAdapter), owns the resulting
    set of machines as a unit, and manages the async lifecycle:
    loading → hydrating → interactive → unmounting.

    Host IS the `coif.auto()` implementation. One Host per route,
    one per embedded view, one per modal. The progressive
    customization API (Levels 0-4) maps to Host configurations.
  }

  state {
    concept: W -> String           # Bound concept URN
    view: W -> String              # View configuration JSON
    zone: W -> option String       # Shell zone to render into
    status: W -> String            # "created" | "loading" | "hydrating" | "interactive" | "error" | "unmounted"
    binding: W -> option String    # Binding ref created by this Host
    machines: W -> set String      # Machine refs owned by this Host
    errorInfo: W -> option String  # Error details if status is "error"
    config: W -> String            # Full config JSON (customization levels 0-3)
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action mount(host: W, config: String) {
      -> ok(host: W) {
        Begin the rendering lifecycle:
        1. Parse config → extract concept URN, view, customizations
        2. Binding/bind → triggers UISchema cascade (via syncs)
        3. Transport/fetch → data arrives → Signal/batch
        4. Collect spawned Machine refs into machines set
        5. FrameworkAdapter/render → Surface/mount to zone
        6. Status: created → loading → hydrating → interactive
      }
      -> error(message: String) { Concept not found, binding or transport failed. }
    }

    action unmount(host: W) {
      -> ok(host: W) {
        Clean teardown:
        1. Machine/destroy for each owned machine
        2. Binding/unbind
        3. Surface/unmount from zone
        4. Status → unmounted
      }
      -> notfound(message: String) { Host does not exist. }
    }

    action refresh(host: W) {
      -> ok(host: W) {
        Re-fetch data via Transport, update signals.
        Machines re-render via signal subscriptions.
      }
      -> error(message: String) { Transport or binding error. }
    }

    action setError(host: W, errorInfo: String) {
      -> ok(host: W) {
        Transition to error state. Renders error boundary widget.
      }
      -> notfound(message: String) { Host does not exist. }
    }

    action updateConfig(host: W, config: String) {
      -> ok(host: W) {
        Hot-update configuration (visible fields, layout)
        without full unmount/remount. Applies UISchema/override
        and re-renders affected machines.
      }
      -> notfound(message: String) { Host does not exist. }
    }
  }

  invariant {
    after mount(host: w,
      config: "{ \"concept\": \"urn:app/Article\", \"view\": \"list\" }")
      -> ok(host: w)
    then unmount(host: w) -> ok(host: w)
  }
}
```

### 3.21 Transport

```
@version(1)
concept Transport [P] {

  purpose {
    Network communication for concept data synchronization.
    Pluggable backends: REST, GraphQL, WebSocket, gRPC, local.
    Handles request construction, auth injection, response parsing,
    error classification, retry logic, request deduplication,
    optimistic updates, and offline queueing.

    Transport is to Binding as ContentStorage is to ContentNode —
    the communication mechanism abstracted from the data model.
    All transports work identically across platforms (browser,
    mobile, watch, desktop, terminal).
  }

  state {
    transports: P -> String        # Transport config registry JSON
    baseUrl: P -> option String    # Base URL for relative endpoints
    headers: P -> String           # Default headers JSON (auth, content-type)
    status: P -> String            # "idle" | "requesting" | "error" | "offline"
    retryPolicy: P -> String       # Retry config JSON
    cache: P -> String             # Response cache (deduplication, TTL)
    pendingQueue: P -> list String # Offline queue for when network unavailable
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action configure(transport: P, config: String) {
      -> ok(transport: P) {
        Set up transport. Config: { type: "rest" | "graphql" |
        "websocket" | "local", baseUrl, defaultHeaders,
        retryPolicy, cacheTTL }.
      }
      -> invalid(message: String) { Config invalid. }
    }

    action fetch(transport: P, request: String) {
      -> ok(transport: P, response: String) {
        Execute a read request. Checks response cache first.
        On miss, executes network request. Parses response,
        maps to concept field structure. Returns JSON with
        data + pagination metadata.
      }
      -> error(transport: P, status: Int, message: String) {
        Request failed. Status: HTTP code (0 for network error).
        Retries per policy before returning error.
      }
      -> offline(transport: P) { Network unavailable; request queued. }
    }

    action mutate(transport: P, request: String) {
      -> ok(transport: P, response: String) {
        Execute a write request (create, update, delete).
        Supports optimistic updates: returns predicted response
        immediately, reconciles when server responds.
      }
      -> error(transport: P, status: Int, message: String) { Mutation failed. }
      -> conflict(transport: P, serverState: String) {
        Optimistic update conflicted with server state.
      }
      -> offline(transport: P) { Mutation queued for when online. }
    }

    action subscribe(transport: P, channel: String) {
      -> ok(transport: P, subscription: String) {
        Open persistent connection (WebSocket, SSE, polling).
        Delivers updates via Signal/write when messages arrive.
      }
      -> unsupported(message: String) { Transport doesn't support subscriptions. }
      -> error(message: String) { Connection failed. }
    }

    action unsubscribe(transport: P, subscription: String) {
      -> ok(transport: P) { Close subscription channel. }
      -> notfound(message: String) { Subscription not found. }
    }

    action setAuth(transport: P, auth: String) {
      -> ok(transport: P) {
        Update auth credentials (bearer token, API key, cookie).
        Applied to all subsequent requests. Triggers re-auth
        when token expires.
      }
      -> invalid(message: String) { Auth config invalid. }
    }

    action flushQueue(transport: P) {
      -> ok(transport: P, results: String) {
        Replay queued offline mutations now that network available.
        Returns results for each queued request.
      }
      -> error(message: String) { Some queued requests failed. }
    }
  }

  invariant {
    after configure(transport: t,
      config: "{ \"type\": \"rest\", \"baseUrl\": \"http://localhost\" }")
      -> ok(transport: t)
    then fetch(transport: t,
      request: "{ \"method\": \"GET\", \"path\": \"/health\" }")
      -> ok(transport: t, response: _)
  }
}
```

### 3.22 Shell

```
@version(1)
concept Shell [A] {

  purpose {
    Root application composition. Defines named zones with semantic
    roles (navigated, persistent, transient) and manages overlays
    (modals, toasts, drawers). Platform-agnostic — PlatformAdapter
    maps abstract zones to platform conventions:

    Browser: navigated → main content, persistent → sidebar/header
    Mobile: navigated → stack screen, persistent → bottom tab bar
    Watch: navigated → full screen (only one zone)
    Desktop: navigated → main window, persistent → panels
    Terminal: navigated → main buffer, persistent → status line

    Shell is the root Host container — it mounts to Surface
    directly and contains all other Hosts.
  }

  state {
    zones: A -> String             # Zone definitions JSON
    zoneHosts: A -> String         # Current Host per zone
    globalState: A -> String       # "initializing" | "ready" | "locked" | "error"
    overlays: A -> list String     # Active overlay stack
    platform: A -> String          # Detected platform hint
    config: A -> String            # Shell config JSON
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action initialize(shell: A, config: String) {
      -> ok(shell: A) {
        Set up shell. Config defines zones with semantic roles:
        [
          { name: "primary", role: "navigated", defaultHost: ... },
          { name: "sidebar", role: "persistent", defaultHost: ... }
        ]
        Creates Surface, attaches FrameworkAdapter, mounts root layout.
      }
      -> error(message: String) { Initialization failed. }
    }

    action assignHost(shell: A, zone: String, host: String) {
      -> ok(shell: A) {
        Mount a Host in a zone. If role is "navigated", unmount
        the previous Host. If "persistent", reject if occupied.
      }
      -> notfound(message: String) { Zone not defined. }
      -> occupied(message: String) { Persistent zone already has a Host. }
    }

    action removeHost(shell: A, zone: String) {
      -> ok(shell: A) { Unmount Host from zone. }
      -> notfound(message: String) { Zone empty or not defined. }
    }

    action pushOverlay(shell: A, overlay: String, host: String) {
      -> ok(shell: A) {
        Push overlay Host onto stack. Renders above all zones.
        Platform adapter decides rendering: browser portal,
        mobile modal sheet, watch alert, terminal floating box.
      }
      -> error(message: String) { Overlay failed. }
    }

    action popOverlay(shell: A) {
      -> ok(shell: A, overlay: String) { Pop top overlay. }
      -> empty(message: String) { No overlays active. }
    }

    action setGlobalState(shell: A, state: String) {
      -> ok(shell: A) {
        App-level state. "locked" shows auth gate (login page,
        biometric prompt, passcode — per platform). "error"
        shows error boundary.
      }
      -> invalid(message: String) { Unknown state. }
    }

    action destroy(shell: A) {
      -> ok(shell: A) { Unmount all Hosts, destroy Surface. }
      -> notfound(message: String) { Shell does not exist. }
    }
  }

  invariant {
    after initialize(shell: s,
      config: "{ \"zones\": [{ \"name\": \"primary\", \"role\": \"navigated\" }] }")
      -> ok(shell: s)
    then destroy(shell: s) -> ok(shell: s)
  }
}
```

### 3.23 PlatformAdapter

```
@version(1)
concept PlatformAdapter [D] {

  purpose {
    Platform-specific translation layer. Maps Navigator transitions
    and Shell zone assignments to platform primitives. Each adapter
    is thin (~100-200 LOC), following the same pattern as
    FrameworkAdapter (which maps Machine props to framework bindings).

    Platform adapters:
    - Browser (~150 LOC): URL ↔ pushState, popstate listener,
      deep link parsing, sidebar/main layout
    - Mobile (~200 LOC): React Navigation stack/tab/drawer,
      hardware back button, deep link config
    - Watch (~100 LOC): WK page list, crown interaction,
      single-focus screen, auto-save
    - Desktop (~200 LOC): multi-window management, menubar,
      Cmd+[ back navigation
    - Terminal (~80 LOC): screen switching, escape=back,
      no URL or history persistence
  }

  state {
    platform: D -> String          # "browser" | "mobile" | "watch" | "desktop" | "terminal"
    capabilities: D -> set String  # "url-bar", "back-gesture", "haptic", "multi-window", etc.
    config: D -> String            # Platform-specific config JSON
    status: D -> String            # "registered" | "active" | "error"
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action register(adapter: D, platform: String, config: String) {
      -> ok(adapter: D) {
        Register platform adapter. Auto-detects capabilities
        from runtime environment if not specified.
      }
      -> conflict(message: String) { Adapter already registered. }
    }

    action mapNavigation(adapter: D, transition: String) {
      -> ok(adapter: D) {
        Translate Navigator transition to platform action.
        Browser: pushState. Mobile: navigation.push.
        Watch: WK push. Desktop: focus window. Terminal: clear+render.
      }
      -> unsupported(message: String) { Transition not supported on platform. }
    }

    action mapZone(adapter: D, zone: String, role: String) {
      -> ok(adapter: D, platformZone: String) {
        Map abstract Shell zone to platform convention.
        Returns platform-specific zone configuration.
        Mobile: persistent → bottom tab bar.
        Watch: only "primary" mapped, others silently skipped.
      }
      -> unmapped(message: String) { Role has no platform equivalent. }
    }

    action mapOverlay(adapter: D, overlay: String) {
      -> ok(adapter: D) {
        Translate overlay to platform presentation.
        Browser: portal div. Mobile: modal sheet.
        Watch: haptic + alert. Terminal: floating box.
      }
      -> unsupported(message: String) { Overlays not supported. }
    }

    action handlePlatformEvent(adapter: D, event: String) {
      -> ok(adapter: D, action: String) {
        Translate platform-native events to Navigator/Shell actions.
        Browser: popstate → Navigator/back.
        Mobile: hardware back → Navigator/back.
        Watch: crown press → Navigator/back.
        Desktop: window close → Navigator cleanup.
      }
      -> ignored(message: String) { Event not relevant. }
    }
  }

  invariant {
    after register(adapter: d, platform: "browser", config: "{}")
      -> ok(adapter: d)
    then mapNavigation(adapter: d,
      transition: "{ \"type\": \"push\", \"destination\": \"test\" }")
      -> ok(adapter: d)
  }
}
```

---

## 4. Core Synchronizations

COIF syncs coordinate concepts using COPF's when/where/then mechanism.

### 4.1 coif-core syncs

```
sync InspectAndGenerate [eager]
when {
  Binding/bind: [ concept: ?concept ]
    => [ binding: ?binding ]
}
then {
  UISchema/inspect: [ schema: ?binding; conceptSpec: ?concept ]
}
```

*When a binding is created, auto-generate UI schema from concept spec.*

```
sync UISchemaToElements [eager]
when {
  UISchema/inspect: [ schema: ?schema ]
    => [ schema: ?schema ]
}
then {
  UISchema/getElements: [ schema: ?schema ]
}
```

*When a schema is generated, extract abstract element tree.*

```
sync BindingStateSync [eager]
when {
  Signal/write: [ signal: ?signal; value: ?value ]
    => [ signal: ?signal; version: ?version ]
}
where {
  Binding: { ?binding signalMap: ?map }
  filter(contains(?map, ?signal))
}
then {
  Binding/sync: [ binding: ?binding ]
}
```

*When a signal is written (user input), sync back to bound concept.*

```
sync ConceptStateToSignal [eager]
when {
  Binding/sync: [ binding: ?binding ]
    => [ binding: ?binding ]
}
where {
  Binding: { ?binding signalMap: ?map }
}
then {
  Signal/batch: [ signals: ?map ]
}
```

*When binding syncs from backend, batch-update all mapped signals.*

### 4.2 coif-component syncs

```
sync ElementToMachine [eager]
when {
  UISchema/getElements: []
    => [ elements: ?elements ]
}
then {
  Widget/list: [ category: ?_ ]
}
```

*When elements are extracted, query component registry for appropriate machines.*

```
sync SpawnMachineForElement [eager]
when {
  Widget/get: [ widget: ?comp ]
    => [ widget: ?comp; machineSpec: ?spec;
         anatomy: ?anatomy; a11ySpec: ?a11y ]
}
then {
  Machine/spawn: [ machine: ?comp; widget: ?comp;
                   context: "{ \"autoGenerated\": true }" ]
}
```

*When a component spec is retrieved, spawn a machine instance.*

```
sync MachineToFrameworkAdapter [eager]
when {
  Machine/connect: [ machine: ?machine ]
    => [ machine: ?machine; props: ?props ]
}
where {
  FrameworkAdapter: { ?adapter status: "active" }
}
then {
  FrameworkAdapter/normalize: [ adapter: ?adapter; props: ?props ]
}
```

*When a machine produces props, send to active renderer for normalization.*

```
sync DestroyMachineOnUnbind [eager]
when {
  Binding/unbind: [ binding: ?binding ]
    => [ binding: ?binding ]
}
where {
  Machine: { ?machine component: ?binding }
}
then {
  Machine/destroy: [ machine: ?machine ]
}
```

*When a binding is removed, destroy all associated machines.*

### 4.3 coif-render syncs

```
sync AttachAdapterToSurface [eager]
when {
  FrameworkAdapter/register: [ adapter: ?adapter ]
    => [ adapter: ?adapter ]
}
where {
  Surface: { ?surface status: "ready" }
}
then {
  Surface/attach: [ surface: ?surface; adapter: ?adapter ]
}
```

*When a renderer registers, attach to any ready surface.*

```
sync ResizeTriggersViewport [eager]
when {
  Surface/resize: [ surface: ?surface; width: ?w; height: ?h ]
    => [ surface: ?surface ]
}
then {
  Viewport/observe: [ viewport: ?surface; width: ?w; height: ?h ]
}
```

*Surface resize → viewport breakpoint recalculation.*

```
sync ViewportTriggersLayout [eager]
when {
  Viewport/observe: [ viewport: ?vp ]
    => [ viewport: ?vp; breakpoint: ?bp ]
}
where {
  Layout: { ?layout responsive: ?rules }
  filter(contains(?rules, ?bp))
}
then {
  Layout/configure: [ layout: ?layout; config: ?rules ]
}
```

*Breakpoint change → reconfigure responsive layouts.*

### 4.4 coif-theme syncs

```
sync ThemeActivateTokens [eager]
when {
  Theme/activate: [ theme: ?theme ]
    => [ theme: ?theme ]
}
then {
  Theme/resolve: [ theme: ?theme ]
}
```

*Theme activated → resolve all tokens.*

```
sync ThemeTokensToSignals [eager]
when {
  Theme/resolve: [ theme: ?theme ]
    => [ tokens: ?tokens ]
}
then {
  Signal/batch: [ signals: ?tokens ]
}
```

*Resolved tokens → batch-update token signals for live theming.*

```
sync PaletteToTokens [eager]
when {
  Palette/generate: [ palette: ?p ]
    => [ palette: ?p; scale: ?scale ]
}
then {
  DesignToken/define: [ token: ?p; name: ?p; value: ?scale;
                  type: "color"; tier: "primitive" ]
}
```

*Palette color scale → register as primitive tokens.*

```
sync ContrastWarning [eager]
when {
  Palette/assignRole: [ palette: ?p; role: ?role ]
    => [ palette: ?p ]
}
where {
  Palette: { ?bg role: "surface" }
}
then {
  Palette/checkContrast: [ foreground: ?p; background: ?bg ]
}
```

*Role assignment → auto-check accessibility contrast.*

### 4.5 coif-app syncs

```
sync NavigatorGoMountsHost [eager]
  purpose: "When navigator resolves a destination, mount the Host"
when {
  Navigator/go: [ nav: ?nav; destination: ?dest ]
    => [ nav: ?nav; resolved: ?config ]
}
then {
  Host/mount: [ host: ?nav; config: ?config ]
}
```

*Navigation resolves destination → Host begins rendering lifecycle.*

```
sync NavigatorGoUnmountsPrevious [eager]
  purpose: "Unmount previous Host when navigating away"
when {
  Navigator/go: [ nav: ?nav ]
    => [ nav: ?nav ]
}
where {
  Host: { ?host status: "interactive"; zone: "primary" }
}
then {
  Host/unmount: [ host: ?host ]
}
```

*Navigation triggers cleanup of previous view.*

```
sync HostMountCreatesBinding [eager]
  purpose: "When Host mounts, create Binding for the concept"
when {
  Host/mount: [ host: ?host; config: ?config ]
    => [ host: ?host ]
}
then {
  Binding/bind: [ binding: ?host; concept: ?config;
                  mode: "coupled" ]
}
```

*Host mount triggers the full existing cascade: Binding/bind → InspectAndGenerate → UISchema/inspect → UISchemaToElements → Widget/get → SpawnMachineForElement → Machine/spawn → MachineToFrameworkAdapter.*

```
sync HostTracksMachines [eager]
  purpose: "Register spawned machines with their owning Host"
when {
  Machine/spawn: [ machine: ?machine ]
    => [ machine: ?machine ]
}
where {
  Host: { ?host status: "hydrating" }
}
then {
  Host/updateConfig: [ host: ?host;
    config: "{ \"addMachine\": \"?machine\" }" ]
}
```

*Machines register with the Host that caused their spawn.*

```
sync HostUnmountCleansUp [eager]
  purpose: "Destroy all machines and unbind when Host unmounts"
when {
  Host/unmount: [ host: ?host ]
    => [ host: ?host ]
}
where {
  Host: { ?host machines: ?machines; binding: ?binding }
}
then {
  Machine/destroy: [ machine: ?machines ]
  Binding/unbind: [ binding: ?binding ]
}
```

*Host unmount cascades cleanup to all owned resources.*

```
sync BindingSyncViaTransport [eager]
  purpose: "Route non-coupled Binding syncs through Transport"
when {
  Binding/sync: [ binding: ?binding ]
    => [ binding: ?binding ]
}
where {
  Binding: { ?binding mode: ?mode; endpoint: ?endpoint }
  Transport: { ?transport status: ?_ }
  filter(?mode != "coupled")
}
then {
  Transport/fetch: [ transport: ?transport;
    request: "{ \"method\": \"GET\", \"path\": \"?endpoint\" }" ]
}
```

*REST/GraphQL bindings delegate to Transport for network execution.*

```
sync TransportResponseToSignals [eager]
  purpose: "Route transport responses to concept signals"
when {
  Transport/fetch: [ transport: ?transport ]
    => [ transport: ?transport; response: ?data ]
}
where {
  Binding: { ?binding endpoint: ?_ }
}
then {
  Signal/batch: [ signals: ?data ]
}
```

*Transport responses flow back through signals to update UI.*

```
sync BindingInvokeViaMutate [eager]
  purpose: "Route concept action invocations through Transport"
when {
  Binding/invoke: [ binding: ?binding; action: ?action; input: ?input ]
    => []
}
where {
  Binding: { ?binding mode: ?mode; endpoint: ?endpoint }
  Transport: { ?transport status: ?_ }
  filter(?mode != "coupled")
}
then {
  Transport/mutate: [ transport: ?transport;
    request: "{ \"method\": \"POST\", \"path\": \"?endpoint\",
               \"body\": \"?input\" }" ]
}
```

*User actions (form submit, button click) flow through Transport.*

```
sync NavigatorToPlatform [eager]
  purpose: "Route navigation transitions through platform adapter"
when {
  Navigator/go: [ nav: ?nav; destination: ?dest ]
    => [ nav: ?nav; resolved: ?config ]
}
where {
  PlatformAdapter: { ?adapter status: "active" }
}
then {
  PlatformAdapter/mapNavigation: [ adapter: ?adapter;
    transition: "{ \"type\": \"push\", \"destination\": \"?dest\",
                  \"config\": ?config }" ]
}
```

*Navigator transitions are translated to platform-native actions.*

```
sync NavigatorBackToPlatform [eager]
  purpose: "Route back navigation through platform adapter"
when {
  Navigator/back: [ nav: ?nav ]
    => [ nav: ?nav ]
}
where {
  PlatformAdapter: { ?adapter status: "active" }
}
then {
  PlatformAdapter/mapNavigation: [ adapter: ?adapter;
    transition: "{ \"type\": \"pop\" }" ]
}
```

*Back navigation on any platform.*

```
sync PlatformEventToNavigator [eager]
  purpose: "Route platform events back to Navigator"
when {
  PlatformAdapter/handlePlatformEvent: [ adapter: ?adapter; event: ?event ]
    => [ adapter: ?adapter; action: ?action ]
}
then {
  Navigator/back: [ nav: ?adapter ]
}
```

*Browser popstate, mobile hardware back, watch crown press → Navigator/back.*

```
sync ShellInitCreatesRootSurface [eager]
  purpose: "On initialization, create the root Surface and Layout"
when {
  Shell/initialize: [ shell: ?shell; config: ?config ]
    => [ shell: ?shell ]
}
then {
  Surface/create: [ surface: ?shell; kind: "browser-dom";
    mountPoint: "#app" ]
  Layout/create: [ name: ?shell; kind: ?config ]
}
```

*Shell initialization bootstraps the rendering stack.*

```
sync ShellZoneToPlatform [eager]
  purpose: "Map shell zones through platform adapter"
when {
  Shell/initialize: [ shell: ?shell; config: ?config ]
    => [ shell: ?shell ]
}
where {
  PlatformAdapter: { ?adapter status: "active" }
}
then {
  PlatformAdapter/mapZone: [ adapter: ?adapter;
    zone: ?config; role: ?config ]
}
```

*Abstract zone roles → platform conventions (sidebar, tab bar, panels).*

```
sync ShellOverlayToPlatform [eager]
  purpose: "Route overlay pushes through platform adapter"
when {
  Shell/pushOverlay: [ shell: ?shell; overlay: ?overlay; host: ?host ]
    => [ shell: ?shell ]
}
where {
  PlatformAdapter: { ?adapter status: "active" }
}
then {
  PlatformAdapter/mapOverlay: [ adapter: ?adapter; overlay: ?overlay ]
}
```

*Overlays → browser portals, mobile modal sheets, watch alerts, terminal floating boxes.*

```
sync NavigatorGoAssignsHostToShell [eager]
  purpose: "Assign the mounted Host to the Shell's primary zone"
when {
  Host/mount: [ host: ?host; config: ?config ]
    => [ host: ?host ]
}
where {
  Shell: { ?shell zones: ?zones }
}
then {
  Shell/assignHost: [ shell: ?shell; zone: "primary"; host: ?host ]
}
```

*Mounted Hosts are assigned to the appropriate Shell zone.*

---

## 5. Kit Manifests

### 5.1 coif-core

```yaml
kit:
  name: coif-core
  version: 0.1.0
  description: >
    Foundation concepts for COIF: tokens, elements, schemas,
    bindings, and signals. Required by all other COIF kits.

concepts:
  DesignToken:
    spec: ./design-token.concept
    params: { T: { as: token-ref } }
  Element:
    spec: ./element.concept
    params: { E: { as: element-ref } }
  UISchema:
    spec: ./ui-schema.concept
    params: { S: { as: schema-ref }, C: { as: concept-ref } }
  Binding:
    spec: ./binding.concept
    params: { B: { as: binding-ref }, C: { as: concept-ref } }
  Signal:
    spec: ./signal.concept
    params: { G: { as: signal-ref } }

syncs:
  required:
    - path: ./syncs/inspect-and-generate.sync
    - path: ./syncs/concept-state-to-signal.sync
    - path: ./syncs/binding-state-sync.sync
  recommended:
    - path: ./syncs/schema-to-elements.sync
      name: UISchemaToElements
```

### 5.2 coif-component

```yaml
kit:
  name: coif-component
  version: 0.1.0
  description: >
    Headless component state machines, anatomies, and slot composition.
  dependencies:
    - coif-core: ">=0.1.0"

concepts:
  Widget:
    spec: ./widget.concept
    params: { P: { as: widget-ref } }
  Machine:
    spec: ./machine.concept
    params: { M: { as: machine-ref } }
  Anatomy:
    spec: ./anatomy.concept
    params: { N: { as: anatomy-ref } }
  Slot:
    spec: ./slot.concept
    params: { L: { as: slot-ref } }

syncs:
  required:
    - path: ./syncs/destroy-machine-on-unbind.sync
  recommended:
    - path: ./syncs/element-to-machine.sync
      name: ElementToMachine
    - path: ./syncs/spawn-machine-for-element.sync
      name: SpawnMachineForElement
    - path: ./syncs/machine-to-adapter.sync
      name: MachineToFrameworkAdapter
```

### 5.3 coif-render

```yaml
kit:
  name: coif-render
  version: 0.2.0
  description: >
    Framework adapters, surfaces, layouts, and viewports.
    v0.2.0: Surface gains mount/unmount, FrameworkAdapter gains render.
  dependencies:
    - coif-core: ">=0.1.0"
    - coif-component: ">=0.1.0"

concepts:
  FrameworkAdapter:
    spec: ./framework-adapter.concept
    params: { R: { as: adapter-ref } }
  Surface:
    spec: ./surface.concept
    params: { F: { as: surface-ref } }
  Layout:
    spec: ./layout.concept
    params: { Y: { as: layout-ref } }
  Viewport:
    spec: ./viewport.concept
    params: { V: { as: viewport-ref } }

syncs:
  required:
    - path: ./syncs/attach-adapter-to-surface.sync
  recommended:
    - path: ./syncs/resize-triggers-viewport.sync
      name: ResizeTriggersViewport
    - path: ./syncs/viewport-triggers-layout.sync
      name: ViewportTriggersLayout

infrastructure:
  adapters:
    - name: react
      path: ./adapters/react/
      description: React 18+ with hooks (useCoif, useSignal, useMachine)
    - name: solid
      path: ./adapters/solid/
      description: Solid.js with reactive primitives
    - name: vue
      path: ./adapters/vue/
      description: Vue 3 Composition API
    - name: svelte
      path: ./adapters/svelte/
      description: Svelte 5 with runes
    - name: ink
      path: ./adapters/ink/
      description: Ink (React for terminal)
    - name: vanilla
      path: ./adapters/vanilla/
      description: Framework-free DOM APIs
```

### 5.4 coif-theme

```yaml
kit:
  name: coif-theme
  version: 0.1.0
  description: >
    Visual design: themes, palettes, typography, motion, elevation.
  dependencies:
    - coif-core: ">=0.1.0"

concepts:
  Theme:
    spec: ./theme.concept
    params: { H: { as: theme-ref } }
  Palette:
    spec: ./palette.concept
    params: { C: { as: palette-ref } }
  Typography:
    spec: ./typography.concept
    params: { X: { as: typography-ref } }
  Motion:
    spec: ./motion.concept
    params: { O: { as: motion-ref } }
  Elevation:
    spec: ./elevation.concept
    params: { W: { as: elevation-ref } }

syncs:
  required:
    - path: ./syncs/theme-activate-tokens.sync
    - path: ./syncs/theme-tokens-to-signals.sync
  recommended:
    - path: ./syncs/palette-to-tokens.sync
      name: PaletteToTokens
    - path: ./syncs/contrast-warning.sync
      name: ContrastWarning

themes:
  - name: light
    path: ./themes/light.json
  - name: dark
    path: ./themes/dark.json
  - name: high-contrast
    path: ./themes/high-contrast.json
```

### 5.5 coif-app

```yaml
kit:
  name: coif-app
  version: 0.1.0
  description: >
    Application orchestration: navigation, lifecycle management,
    network transport, platform composition. All concepts are
    platform-agnostic; PlatformAdapter handles platform specifics.
  dependencies:
    - coif-core: ">=0.2.0"
    - coif-component: ">=0.2.0"
    - coif-render: ">=0.2.0"

concepts:
  Navigator:
    spec: ./navigator.concept
    params: { N: { as: navigator-ref } }
  Host:
    spec: ./host.concept
    params: { W: { as: host-ref } }
  Transport:
    spec: ./transport.concept
    params: { P: { as: transport-ref } }
  Shell:
    spec: ./shell.concept
    params: { A: { as: shell-ref } }
  PlatformAdapter:
    spec: ./platform-adapter.concept
    params: { D: { as: platform-adapter-ref } }

syncs:
  required:
    - path: ./syncs/host-mount-creates-binding.sync
      name: HostMountCreatesBinding
    - path: ./syncs/host-unmount-cleans-up.sync
      name: HostUnmountCleansUp
    - path: ./syncs/binding-sync-via-transport.sync
      name: BindingSyncViaTransport
    - path: ./syncs/transport-response-to-signals.sync
      name: TransportResponseToSignals
  recommended:
    - path: ./syncs/navigator-go-mounts-host.sync
      name: NavigatorGoMountsHost
    - path: ./syncs/navigator-go-unmounts-previous.sync
      name: NavigatorGoUnmountsPrevious
    - path: ./syncs/host-tracks-machines.sync
      name: HostTracksMachines
    - path: ./syncs/binding-invoke-via-mutate.sync
      name: BindingInvokeViaMutate
    - path: ./syncs/navigator-to-platform.sync
      name: NavigatorToPlatform
    - path: ./syncs/navigator-back-to-platform.sync
      name: NavigatorBackToPlatform
    - path: ./syncs/platform-event-to-navigator.sync
      name: PlatformEventToNavigator
    - path: ./syncs/shell-init-creates-root-surface.sync
      name: ShellInitCreatesRootSurface
    - path: ./syncs/shell-zone-to-platform.sync
      name: ShellZoneToPlatform
    - path: ./syncs/shell-overlay-to-platform.sync
      name: ShellOverlayToPlatform
    - path: ./syncs/navigator-go-assigns-host-to-shell.sync
      name: NavigatorGoAssignsHostToShell
```

---

## 6. Concept Library Integration

COIF integrates with the COPF Concept Library (v0.4.0, 54 concepts across 15 kits) via syncs that bridge domain concepts to interface concerns. This section defines the cross-system syncs that connect library kits to COIF kits.

### 6.1 Name Collision Resolutions

Four COIF concepts were renamed in v0.2.0 to avoid collisions with library concepts that share names but serve different purposes:

| COIF v0.1.0 | COIF v0.2.0 | Library Concept (unchanged) | Why different |
|---|---|---|---|
| Token | **DesignToken** | Token (@copf/computation) | COIF: W3C visual design data. Library: Drupal-style `[node:author:mail]` text placeholders. |
| Component | **Widget** | Component (@copf/layout) | COIF: Headless state machines for UI behavior. Library: Pluggable content units placed in layout regions (Drupal Block). |
| Renderer | **FrameworkAdapter** | Renderer (@copf/presentation) | COIF: React/Solid/Vue adapter (~200 LOC). Library: Content-to-render-tree pipeline with caching and BigPipe streaming. |
| Schema | **UISchema** | Schema (@copf/classification) | COIF: Inspect specs → generate UI schema. Library: Named field sets (type-as-mixin) and runtime concept coordination hub. |

### 6.2 Library Concepts Superseded by COIF

Three library concepts are replaced when COIF is available. Their domain-level intent survives as syncs that delegate to COIF:

**FormBuilder** → UISchema + Machine(form). COIF's type-mapping rules + form state machine + progressive customization ladder does everything FormBuilder does, but headless and framework-agnostic. FormBuilder's `widgetRegistry` migrates to Widget/register. Its `buildForm` becomes UISchema/inspect + Machine/spawn("form"). Its `processSubmission` becomes Binding/invoke.

**DisplayMode** → UISchema overrides + Theme. Named presentation profiles ("teaser", "full", "compact") become named UISchema override presets. Field formatter configurations become Widget configurations. The concept survives as a naming convenience — users still think in modes — but implementation delegates to COIF.

**ExposedFilter** → Widget + Binding syncs. Each exposed filter is a Widget/Machine instance bound to a Query parameter signal. User interacts with Widget → Signal/write → Binding syncs to Query → Query re-executes → results update. The standalone concept is unnecessary.

### 6.3 Library Concepts Partially Absorbed

**Control** (Automation kit): UI behavior (buttons, sliders, toggles binding to data and triggering actions) is Widget + Binding. Control's `interact` action becomes Machine/send. Control's `embed` becomes a sync that places a Widget inside a ContentNode. Domain-level action triggering retained in the library.

**Graph** (Data Organization): Visualization (layout algorithms, position state, rendering, filtering) moves to Widget("graph"). Data derivation (nodes + edges computed from Backlinks) stays in the library. Graph retains `nodes`, `edges`, `getNeighbors`. COIF absorbs `computeLayout`, `filterNodes`, position state.

### 6.4 Cross-System Syncs

These syncs wire library domain concepts to COIF interface concepts. They belong to a new **coif-integration** kit that requires both COIF kits and the relevant library kits.

#### Library Schema → UISchema (core integration)

When a library Schema is defined, COIF auto-generates a complete UI for it.

```
sync SchemaDefDrivesUI [eager]
  purpose: "Auto-generate interface when a concept schema is defined"
when {
  Schema/defineSchema: [ name: ?name; fields: ?fields ]
    => [ schema: ?schemaId ]
}
then {
  UISchema/inspect: [ schema: ?schemaId; conceptSpec: ?fields ]
}

sync SchemaApplyDrivesBinding [eager]
  purpose: "Create data binding when a schema is applied to a node"
when {
  Schema/applyTo: [ nodeId: ?node ]
    => [ schema: ?schemaId ]
}
then {
  Binding/bind: [ concept: ?node; mode: "coupled" ]
}
```

Schema gains a new association type: `uiSchema: UISchemaID | null`.

#### Intent → UISchema enrichment

Intent's purpose and description generate better labels and placeholders.

```
sync IntentEnrichesUI [eager]
  purpose: "Use concept purpose to enhance generated interface labels"
when {
  Intent/define: [ targetId: ?target; purpose: ?purpose ]
    => [ intent: ?intentId ]
}
where {
  UISchema: { ?uiSchema concept: ?target }
}
then {
  UISchema/override: [ schema: ?uiSchema;
    overrides: "{ \"description\": ?purpose }" ]
}
```

#### Library View → COIF Layout + UISchema

Library View is the configuration/intent layer; COIF implements the rendering.

```
sync ViewDrivesLayout [eager]
  purpose: "Map View layout type to COIF spatial arrangement"
when {
  View/create: [ dataSource: ?ds; layout: ?layoutType ]
    => [ view: ?viewId ]
}
then {
  Layout/create: [ name: ?viewId; kind: ?layoutType ]
  UISchema/inspect: [ schema: ?viewId; conceptSpec: ?ds ]
}

sync ViewFieldsDriveUISchema [eager]
  purpose: "Reflect visible field changes in UI schema overrides"
when {
  View/setVisibleFields: [ view: ?viewId; fieldIds: ?fields ]
    => [ view: ?viewId ]
}
then {
  UISchema/override: [ schema: ?viewId; overrides: ?fields ]
}

sync ViewEmbedCreatesInlineSurface [eager]
  purpose: "Embed a View inside a ContentNode as an inline COIF surface"
when {
  View/embed: [ targetNodeId: ?node ]
    => [ view: ?viewId ]
}
then {
  Surface/create: [ surface: ?viewId; kind: "browser-dom";
    mountPoint: ?node ]
}
```

#### Validator → Machine(form) validation

COIF's form machine delegates constraint checking to the library Validator.

```
sync FormValidatesViaValidator [eager]
  purpose: "Delegate form submission validation to library Validator"
when {
  Machine/send: [ machine: ?form; event: "{ \"type\": \"SUBMIT\" }" ]
    => [ machine: ?form; state: "validating" ]
}
where {
  Binding: { ?binding signalMap: ?map }
  filter(contains(?map, ?form))
}
then {
  Validator/validate: [ nodeId: ?form; formData: ?map ]
}

sync ValidationResultToForm [eager]
  purpose: "Route validation results back to form machine"
when {
  Validator/validate: []
    => [ result: ?result ]
}
then {
  Machine/send: [ machine: ?form;
    event: "{ \"type\": \"VALIDATION_RESULT\", \"result\": ?result }" ]
}
```

#### Workflow → Signal (status state)

Workflow state transitions update COIF signals for live status display.

```
sync WorkflowStateToSignal [eager]
  purpose: "Reflect workflow state changes in UI signals"
when {
  Workflow/transition: [ entityId: ?entity; targetState: ?state ]
    => [ entityId: ?entity ]
}
then {
  Signal/write: [ signal: ?entity; value: ?state ]
}
```

#### EventBus → Signal (event stream)

Domain events update COIF signals subscribed to those event types.

```
sync EventBusFeedsSignals [eager]
  purpose: "Route domain events to subscribed UI signals"
when {
  EventBus/dispatch: [ event: ?event ]
    => [ eventType: ?type; payload: ?payload ]
}
where {
  Signal: { ?signal kind: "state" }
  filter(subscribedTo(?signal, ?type))
}
then {
  Signal/write: [ signal: ?signal; value: ?payload ]
}
```

#### Notification → Machine(toast)

Notifications render as toast widgets.

```
sync NotificationToToast [eager]
  purpose: "Display notifications as toast UI widgets"
when {
  Notification/send: [ userId: ?user; message: ?msg ]
    => [ notification: ?notif ]
}
then {
  Machine/spawn: [ machine: ?notif; widget: "toast";
    context: "{ \"message\": ?msg, \"variant\": \"info\" }" ]
}
```

#### ContentParser → Widget(rich-text)

Parsed content feeds rich-text widgets with interactive inline elements.

```
sync ParsedContentToRichText [eager]
  purpose: "Feed parsed AST to rich-text widget for interactive rendering"
when {
  ContentParser/parse: [ content: ?content; formatId: ?fmt ]
    => [ ast: ?ast; extractedMetadata: ?meta ]
}
then {
  Signal/write: [ signal: ?content; value: ?ast ]
}
```

#### Library Renderer → FrameworkAdapter

The library's content-to-render-tree pipeline feeds into COIF's framework adapter.

```
sync RendererFeedsAdapter [eager]
  purpose: "Route rendered content tree through framework adapter"
when {
  Renderer/render: [ element: ?el ]
    => [ renderTree: ?tree ]
}
where {
  FrameworkAdapter: { ?adapter status: "active" }
}
then {
  FrameworkAdapter/normalize: [ adapter: ?adapter; props: ?tree ]
}
```

#### Library Component → Widget (layout component rendering)

Library layout components (Drupal Blocks) render through COIF widgets.

```
sync LayoutComponentRendersViaWidget [eager]
  purpose: "Render layout components through COIF widget state machines"
when {
  Component/render: [ component: ?comp; context: ?ctx ]
    => [ component: ?comp ]
}
where {
  Widget: { ?widget name: ?comp }
}
then {
  Machine/spawn: [ machine: ?comp; widget: ?widget; context: ?ctx ]
}
```

### 6.5 coif-integration Kit Manifest

```yaml
kit:
  name: coif-integration
  version: 0.1.0
  description: >
    Syncs that bridge COPF Concept Library domain concepts to COIF interface
    concepts. Requires both COIF kits and the relevant library kits to be active.
  dependencies:
    - coif-core: ">=0.2.0"
    - coif-component: ">=0.2.0"
    - coif-render: ">=0.2.0"
    - coif-theme: ">=0.2.0"
  uses:
    "@copf/classification":
      concepts: [Schema]
    "@copf/foundation":
      concepts: [ContentParser, Intent]
    "@copf/presentation":
      concepts: [View, Renderer]
    "@copf/infrastructure":
      concepts: [EventBus, Validator]
    "@copf/automation":
      concepts: [Workflow, Control]
    "@copf/layout":
      concepts: [Component]
    "@copf/notification":
      concepts: [Notification]

concepts: []  # No new concepts — this kit is syncs-only

syncs:
  required:
    - path: ./syncs/schema-def-drives-ui.sync
      name: SchemaDefDrivesUI
    - path: ./syncs/schema-apply-drives-binding.sync
      name: SchemaApplyDrivesBinding
  recommended:
    - path: ./syncs/intent-enriches-ui.sync
      name: IntentEnrichesUI
    - path: ./syncs/view-drives-layout.sync
      name: ViewDrivesLayout
    - path: ./syncs/view-fields-drive-uischema.sync
      name: ViewFieldsDriveUISchema
    - path: ./syncs/view-embed-creates-surface.sync
      name: ViewEmbedCreatesInlineSurface
    - path: ./syncs/form-validates-via-validator.sync
      name: FormValidatesViaValidator
    - path: ./syncs/validation-result-to-form.sync
      name: ValidationResultToForm
    - path: ./syncs/workflow-state-to-signal.sync
      name: WorkflowStateToSignal
    - path: ./syncs/eventbus-feeds-signals.sync
      name: EventBusFeedsSignals
    - path: ./syncs/notification-to-toast.sync
      name: NotificationToToast
    - path: ./syncs/parsed-content-to-richtext.sync
      name: ParsedContentToRichText
    - path: ./syncs/renderer-feeds-adapter.sync
      name: RendererFeedsAdapter
    - path: ./syncs/layout-component-via-widget.sync
      name: LayoutComponentRendersViaWidget
```

### 6.6 Updated Concept Counts

| System | Before | After | Change |
|---|---|---|---|
| Concept Library | 54 concepts, 15 kits | 51 concepts, 14 kits | -3 (FormBuilder, DisplayMode, ExposedFilter removed) |
| COIF | 18 concepts, 4 kits (v0.1) | 23 concepts, 5 kits + 1 integration kit (v0.3) | 4 renames, +5 (Navigator, Host, Transport, Shell, PlatformAdapter) |
| Combined unique | — | 74 concepts, 20 kits | Zero overlap after renames |

The Presentation kit shrinks from 4 concepts (View, DisplayMode, FormBuilder, Renderer) to 2 (View, Renderer). It gains `uses` references to COIF kits.

---

## 7. Deployment Architecture

### 7.1 Deployment Manifest Extension

COIF extends COPF's `app.deploy.yaml`:

```yaml
app:
  name: my-app
  version: 1.0.0

kits:
  - name: coif-core
  - name: coif-component
  - name: coif-render
  - name: coif-theme
  - name: coif-app

interface:
  renderer: react
  platform: browser          # browser | mobile | watch | desktop | terminal

  surface:
    kind: browser-dom
    mountPoint: "#app"

  shell:
    zones:
      - { name: primary, role: navigated }
      - { name: sidebar, role: persistent }
      - { name: header, role: persistent }
    overlays: [toast, modal, drawer]

  navigation:
    mode: browser              # browser-history | hash | memory | ssr-adapt
    destinations:
      - { id: articles, pattern: "/articles", concept: "Article", view: list }
      - { id: article-detail, pattern: "/articles/:id", concept: "Article", view: detail }
      - { id: settings, pattern: "/settings", concept: "Settings", view: profile }

  transport:
    type: rest
    baseUrl: "/api"
    auth: bearer
    retry: { maxAttempts: 3, backoff: exponential }

  theme:
    base: light
    variants: [dark, high-contrast]
    defaultVariant: light
    respectSystemPreference: true

  deploy:
    mode: bundled
    options:
      bundled:
        target: esm
        treeshake: true
        minify: true
      cdn:
        url: "https://cdn.example.com/coif/v0.3.0/"
        globalName: "COIF"
      ssr:
        framework: next
        streaming: true
      native:
        platforms: [ios, android]
        renderer: react-native
        platform: mobile
      edge:
        runtime: cloudflare-worker
        hydration: partial

  customization:
    level: 2
```

### 7.2 Deployment Modes

| Mode | Output | Use Case | Size |
|------|--------|----------|------|
| **bundled** | ESM/CJS modules | npm install for React/Vue/etc | ~15KB core |
| **cdn** | UMD script + CSS | Script tag, prototyping | ~45KB gzipped |
| **ssr** | HTML + hydration | SEO, fast initial load | Framework-dependent |
| **native** | React Native components | Mobile apps | ~25KB core |
| **edge** | Worker-compatible bundle | Cloudflare/Vercel edge | ~20KB |

### 7.3 Framework Adapter Interface

Each FrameworkAdapter is ~200 LOC implementing:

```typescript
interface CoifAdapter {
  normalizeProps(props: CoifProps): FrameworkProps;
  createSignal<T>(initial: T): [get: () => T, set: (v: T) => void];
  useSignal<T>(signal: CoifSignal<T>): T;
  useMachine(component: string, config?: Record<string, unknown>): MachineAPI;
  mount(tree: CoifTree, target: Element | string): Disposable;
  render(tree: CoifTree, target: Element | string): void;
}
```

### 7.4 Platform Adapter Interface

Each PlatformAdapter is ~100-200 LOC implementing:

```typescript
interface CoifPlatformAdapter {
  platform: 'browser' | 'mobile' | 'watch' | 'desktop' | 'terminal';
  capabilities: Set<string>;

  mapNavigation(transition: NavigatorTransition): void;
  mapZone(zone: string, role: ZoneRole): PlatformZoneConfig | null;
  mapOverlay(overlay: OverlayConfig): void;
  handlePlatformEvent(event: PlatformEvent): NavigatorAction | null;
  setupListeners(navigator: NavigatorRef, shell: ShellRef): Disposable;
}
```

**Platform coverage:**

| Platform | FrameworkAdapter | PlatformAdapter | Total platform-specific LOC |
|---|---|---|---|
| Browser | React/Solid/Vue (~200) | Browser history, popstate (~150) | ~350 |
| Mobile | React Native (~200) | React Navigation stack/tab (~200) | ~400 |
| Watch | React Native subset (~150) | WK page list, crown (~100) | ~250 |
| Desktop | React DOM / Tauri (~200) | Multi-window, menubar (~200) | ~400 |
| Terminal | Ink (~200) | Screen switching, escape key (~80) | ~280 |

**React adapter example:**

```typescript
// @coif/react — ~200 LOC
import { useSyncExternalStore, useRef, useEffect } from 'react';

export function useSignal<T>(signal: CoifSignal<T>): T {
  return useSyncExternalStore(
    signal.subscribe, signal.getSnapshot, signal.getServerSnapshot
  );
}

export function useMachine(component: string, config?: Record<string, unknown>) {
  const ref = useRef<MachineInstance>(null);
  if (!ref.current) ref.current = coifRuntime.spawnMachine(component, config);

  const state = useSignal(ref.current.stateSignal);
  const props = ref.current.connect(state);
  const normalized = normalizeReactProps(props);

  useEffect(() => () => ref.current?.destroy(), []);
  return { state, props: normalized, send: ref.current.send };
}

export function useBinding(conceptUri: string, mode: BindingMode = 'coupled') {
  const ref = useRef<BindingInstance>(null);
  if (!ref.current) ref.current = coifRuntime.createBinding(conceptUri, mode);

  const data = useSignal(ref.current.dataSignal);
  const status = useSignal(ref.current.statusSignal);

  useEffect(() => () => ref.current?.unbind(), []);
  return { data, status, invoke: ref.current.invoke, refresh: ref.current.sync };
}
```

**Usage:**

```tsx
import { useBinding, useMachine } from '@coif/react';
import { CoifForm, CoifList } from '@coif/react/components';

function ArticleEditor() {
  const articles = useBinding('urn:app/Article');
  const dialog = useMachine('dialog', { open: false });

  return (
    <div>
      <CoifList binding={articles} view="list" />
      <button {...dialog.props.getTriggerProps()}>New</button>
      {dialog.state.open && (
        <div {...dialog.props.getContentProps()}>
          <CoifForm binding={articles} view="create" />
        </div>
      )}
    </div>
  );
}
```

---

## 8. Progressive Customization Ladder

Each level passes configuration to `Host/mount`. `coif.auto()` is sugar for creating a Host — every call below creates a Host instance that drives the full Binding → UISchema → Widget → Machine → FrameworkAdapter cascade.

### Level 0: Zero Config
```typescript
const ArticleUI = coif.auto('urn:app/Article');
// Host/mount({ concept: 'urn:app/Article', view: 'auto' })
// Generates complete CRUD: list, detail, create, edit views
```

### Level 1: Field-Level
```typescript
const ArticleUI = coif.auto('urn:app/Article', {
  fields: {
    title: { placeholder: 'Enter title...' },
    body: { widget: 'rich-text', rows: 20 },
    createdAt: { hidden: true },
  },
});
```

### Level 2: View-Level
```typescript
const ArticleUI = coif.auto('urn:app/Article', {
  views: {
    list: {
      columns: ['title', 'author', 'published', 'updatedAt'],
      defaultSort: { field: 'updatedAt', direction: 'desc' },
      pageSize: 25,
    },
    detail: {
      layout: 'sidebar',
      sections: [
        { name: 'content', fields: ['title', 'body'] },
        { name: 'meta', fields: ['author', 'published', 'createdAt'] },
      ],
    },
  },
});
```

### Level 3: Widget-Level (Slots)
```tsx
const ArticleUI = coif.auto('urn:app/Article', {
  slots: {
    'list.row': ({ data }) => <CustomArticleRow article={data} />,
    'detail.header': ({ data }) => <HeroImage src={data.coverImage} />,
    'form.body': ({ field, onChange }) => <MyEditor value={field.value} onChange={onChange} />,
  },
});
```

### Level 4: Full Custom (Headless Hooks)
```tsx
function CustomArticleEditor() {
  const articles = useBinding('urn:app/Article');
  const form = useMachine('form', {
    fields: articles.schema.createFields,
    onSubmit: (v) => articles.invoke('create', v),
  });

  return (
    <form {...form.props.getRootProps()}>
      <input {...form.props.getFieldProps('title')} className="custom" />
      <RichEditor {...form.props.getFieldProps('body')} />
      <button {...form.props.getSubmitProps()}>Create</button>
    </form>
  );
}
```

---

## 9. Type-Mapping Rules

UISchema concept uses these to generate default UI from COPF types:

| COPF Type | Element Kind | Default Widget |
|-----------|-------------|----------------|
| `String` | input-text | text-input |
| `Int` | input-number | number-input (step=1) |
| `Float` | input-number | number-input (step=0.01) |
| `Bool` | input-bool | toggle |
| `DateTime` | input-date | datetime-picker |
| `Bytes` | file-upload | file-input |
| `ID` | output-text | text-display (read-only) |
| `option T` | *same as T* | *same*, required=false |
| `set T` | selection-multi | multi-select / checkbox-group |
| `list T` | group (repeating) | repeating-field-group |
| `T -> T` (relation) | selection-single | select / combobox |
| `{ fields }` (record) | group | fieldset |

For list views, field types map to column behaviors:

| COPF Type | Column Behavior |
|-----------|----------------|
| `String` | Text, searchable, sortable |
| `Int/Float` | Numeric, sortable, right-aligned |
| `Bool` | Badge/icon (✓/✗), filterable |
| `DateTime` | Relative time, sortable |
| `ID` | Hidden by default |
| `set T` | Count badge, expandable |

---

## 10. Bootstrapping Plan

COIF is built on COPF from the first line of code. Every stage uses `.concept` specs, `.sync` files, and the COPF engine — no hand-wired coordination that gets "replaced later." COPF's own bootstrap (kernel → self-hosting) provides the engine; COIF layers concepts and syncs on top of it.

This means COIF requires a working COPF engine (Stage 3+ of COPF's bootstrap) as a prerequisite. COIF is a COPF application, not a parallel system.

### Stage 0: Foundation Concepts + Syncs

Deploy the coif-core kit's 5 concepts (DesignToken, Element, UISchema, Binding, Signal) as COPF `.concept` specs with TypeScript implementations. Deploy the 4 coif-core syncs (InspectAndGenerate, UISchemaToElements, BindingStateSync, ConceptStateToSignal) as `.sync` files loaded by the COPF engine.

All coordination runs through the engine from day one. When a Binding/bind completion arrives, the engine evaluates InspectAndGenerate and fires UISchema/inspect — no application code orchestrates this.

**Acceptance tests (generated from invariants + sync integration tests):**
- Binding/bind → engine fires InspectAndGenerate → UISchema/inspect produces valid UI schema
- UISchema/inspect completion → engine fires UISchemaToElements → element tree extracted
- Signal/write → engine fires BindingStateSync → Binding/sync propagates to backend
- Binding/sync completion → engine fires ConceptStateToSignal → Signal/batch updates all mapped signals
- DesignToken alias chains resolve correctly across define → alias → resolve

### Stage 1: Widget Kit

Deploy coif-component's 4 concepts (Widget, Machine, Anatomy, Slot) and 4 syncs (ElementToMachine, SpawnMachineForElement, MachineToFrameworkAdapter, DestroyMachineOnUnbind). Register the initial 10 widget state machines (button, input, textarea, select, checkbox, toggle, dialog, tabs, form, toast) via Widget/register actions.

The pipeline now runs end-to-end via syncs: a Binding/bind triggers schema inspection, which triggers element extraction, which triggers widget selection, which triggers machine spawning — all through the engine's sync evaluation loop.

**Acceptance tests:**
- Full pipeline: Binding/bind → ... → Machine/spawn produces running machines for each element
- Machine/connect returns valid props for each of the 10 widget types
- Machine/send transitions states correctly (dialog open/close, form submit/reset)
- Binding/unbind → engine fires DestroyMachineOnUnbind → all machines cleaned up

### Stage 2: Render Kit + React Adapter

Deploy coif-render's 4 concepts (FrameworkAdapter, Surface, Layout, Viewport) and 3 syncs (AttachAdapterToSurface, ResizeTriggersViewport, ViewportTriggersLayout). Build the React adapter (~200 LOC) as an implementation registered via FrameworkAdapter/register.

The adapter translates Machine/connect props to React bindings. The hooks API (useBinding, useMachine, useSignal) wraps COPF concept interactions in React idioms — but underneath, every data flow is a COPF action routed through the engine.

**Acceptance tests:**
- FrameworkAdapter/register → engine fires AttachAdapterToSurface → adapter connected to surface
- Surface/resize → engine fires ResizeTriggersViewport → Viewport/observe → breakpoint signal updated
- Viewport breakpoint change → engine fires ViewportTriggersLayout → layouts reconfigured
- React useBinding('urn:app/TestConcept') produces working CRUD interface end-to-end
- React useMachine('dialog') gives full headless control with proper ARIA

### Stage 3: App Kit

Deploy coif-app's 5 concepts (Navigator, Host, Transport, Shell, PlatformAdapter) and 15 syncs (HostMountCreatesBinding, HostUnmountCleansUp, NavigatorGoMountsHost, NavigatorGoUnmountsPrevious, BindingSyncViaTransport, TransportResponseToSignals, BindingInvokeViaMutate, HostTracksMachines, NavigatorToPlatform, NavigatorBackToPlatform, PlatformEventToNavigator, ShellInitCreatesRootSurface, ShellZoneToPlatform, ShellOverlayToPlatform, NavigatorGoAssignsHostToShell). Build the browser PlatformAdapter (~150 LOC).

With this stage, a complete app runs end-to-end: `Shell/initialize` → `Navigator/register` routes → user navigates → `Navigator/go` → `Host/mount` → existing Stages 0-2 cascade fires → `FrameworkAdapter/render` → `Surface/mount` → pixels on screen.

**Acceptance tests:**
- Shell/initialize → Surface/create + Layout/create → root shell rendered to DOM
- Navigator/register + Navigator/go → Host/mount → full Binding→Machine cascade → interactive UI
- Transport/configure("rest") + Transport/fetch → returns parsed JSON response
- Transport/mutate → optimistic update → Signal/write → UI updates immediately → server reconciliation
- Host/unmount → all machines destroyed, binding unbound, zone cleared
- Navigator guard blocks transition, displays confirmation dialog
- Shell/pushOverlay → modal overlay renders without displacing main content
- PlatformAdapter/handlePlatformEvent (popstate) → Navigator/back → UI updates
- `coif.auto('urn:app/Article')` produces working CRUD interface (Level 0 customization)

### Stage 4: Theme Kit

Deploy coif-theme's 5 concepts (Theme, Palette, Typography, Motion, Elevation) and 4 syncs (ThemeActivateTokens, ThemeTokensToSignals, PaletteToTokens, ContrastWarning). Create default light and dark themes via Theme/create actions. Generate default palettes via Palette/generate.

All theme changes propagate through the same engine: Theme/activate → engine fires ThemeActivateTokens → Theme/resolve → engine fires ThemeTokensToSignals → Signal/batch → UI re-renders. No special theming runtime — it's concepts and syncs all the way down.

**Acceptance tests:**
- Theme/activate → engine cascade → all token-dependent signals updated → UI reflects new theme
- Palette/generate → engine fires PaletteToTokens → colors registered as primitive tokens
- Palette/assignRole → engine fires ContrastWarning → Palette/checkContrast validates accessibility
- prefers-reduced-motion → Motion durations resolve to 0ms

### Stage 5: Additional Framework + Platform Adapters

Build additional FrameworkAdapters: Solid, Vue, Svelte, Ink (~200 LOC each). Build additional PlatformAdapters: mobile (~200 LOC), desktop (~200 LOC), terminal (~80 LOC), watch (~100 LOC). Each registers via FrameworkAdapter/register and PlatformAdapter/register — the engine's syncs handle all coordination.

**Acceptance tests:**
- Same concept spec + same syncs → working interfaces in React, Solid, Vue, Svelte, Ink
- FrameworkAdapter switch is a single register action, no concept/sync changes
- Ink FrameworkAdapter + terminal PlatformAdapter → full app in terminal
- React Native FrameworkAdapter + mobile PlatformAdapter → iOS/Android app
- Navigator/go on mobile → React Navigation stack push (not URL change)
- Shell zones on mobile → bottom tab bar for persistent, stack for navigated
- Shell zones on watch → single full screen (secondary zones silently skipped)
- Shell/pushOverlay on mobile → modal sheet, on terminal → floating box

### Stage 6: Deployment Modes

Extend the deployment manifest to support all modes (bundled, CDN, SSR, native, edge). The COPF engine runs differently per target — in-process for bundled/CDN, server-side for SSR, on-device for native, request-scoped for edge — but the concepts and syncs are identical.

**Acceptance tests:**
- CDN mode: single `<script>` tag loads COIF runtime + engine + concepts, `coif.auto()` works
- SSR mode: server renders HTML from Machine/connect output, client hydrates with React adapter
- Native mode: React Native adapter renders same component tree on iOS/Android
- Edge mode: Cloudflare Worker runs COPF engine, returns rendered HTML

---

## 11. Resolved Design Questions

| Question | Resolution |
|----------|-----------|
| CLI/API/SDK first-class in COIF? | No. COIF focuses on GUI. CLI/API/SDK via COPF code generators. |
| Atomic Design hierarchy? | No. Flat, concept-driven. Compose via slots and syncs. |
| Full SDUI or configuration-driven? | Configuration-driven. Concepts provide data/behavior; clients own rendering. |
| Signals or observables? | Signals (TC39 aligned) for UI state. Observable subscriptions for concept event streams only. |
| W3C DTCG compliance? | Yes. DesignToken concept follows 2025.10 spec. |
| Headless pattern? | Zag.js model: state machines → connect() → props API. Same pattern, no dependency. |
| Browser-only routing? | No. Navigator is abstract (destinations + transitions). PlatformAdapter maps to URLs, stacks, pages per platform. |
| Browser-only app shell? | No. Shell uses semantic zone roles (navigated, persistent). PlatformAdapter maps to platform conventions (sidebar, tab bar, single screen). |
| Who triggers Binding/bind? | Host concept. `coif.auto()` creates a Host which drives the full sync cascade. |
| Where does HTTP execution live? | Transport concept. Separated from Binding (what to sync) like ContentStorage is separated from ContentNode (what to store). |
| Who mounts to the DOM? | Surface/mount and FrameworkAdapter/render. Surface manages the mount point, FrameworkAdapter calls `ReactDOM.render()` etc. |
| Per-platform concepts or adapters? | Adapters. Navigator and Shell are platform-agnostic concepts. PlatformAdapter (~100-200 LOC each) provides platform-specific translation. Same pattern as FrameworkAdapter. |
| How much platform-specific code? | ~300-400 LOC total per platform: FrameworkAdapter (~200 LOC) + PlatformAdapter (~100-200 LOC). Everything else is shared. |

---

## 12. Design Philosophy: Beauty by Default

COIF's theme system is foundational, not an afterthought. The default themes produce interfaces that feel crafted, not generated:

**Intentional spacing.** 8px base grid, 4px half-step. Every gap references a spacing token — generous whitespace makes auto-generated interfaces feel calm.

**Typographic hierarchy.** 1.25 ratio (major third): 12, 14, 16, 20, 25, 31, 39. Heading weight 600 (semi-bold) — enough contrast without heaviness. Line heights calculated per-size.

**Color with meaning.** 11 shades per hue via OKLCH. Semantic colors: 3 variants each (default, hover, active). Every pairing WCAG AA compliant. Neutral palette with slight warm tint.

**Subtle motion.** Enter: 200ms ease-out. Exit: 150ms ease-in. Hover: 100ms. Nothing exceeds 500ms. Respects prefers-reduced-motion.

**Considered elevation.** Multi-layer shadows for realism. Dark mode: rgba(0,0,0,0.3) vs light mode's rgba(0,0,0,0.1). Elevation 0 is a 1px border, not "no shadow."

The result: `coif.auto('urn:app/Article')` produces an interface that looks intentionally designed — this is the standard every token and default serves.