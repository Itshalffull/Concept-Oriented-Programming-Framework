@version(1)
concept UISchema [S, C] {

  purpose {
    Inspect a concept spec and generate a UI schema — the
    complete description of how that concept should be presented.
    Implements the dual-schema pattern: data schema (from spec)
    is the source, UI schema (generated here) is the presentation
    layer. Inspection pipeline: inspect → classify interaction
    types → apply defaults → apply overrides → produce element tree.
  }

  state {
    concept: S -> C
    elements: S -> list String
    uiSchema: S -> String
    overrides: S -> option String
    generatedAt: S -> DateTime
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action inspect(schema: S, conceptSpec: String) {
      -> ok(schema: S) {
        Parse concept spec. Extract state fields, actions,
        and return variants. Generate default views: list,
        detail, create, edit. If spec contains an interface
        section, apply overrides on top of defaults.
      }
      -> parseError(message: String) { Spec could not be parsed. }
    }

    action override(schema: S, overrides: String) {
      -> ok(schema: S) {
        Apply partial UI schema on top of generated one.
        Merges at field/action/view level.
      }
      -> notfound(message: String) { No schema for this concept. }
      -> invalid(message: String) { Override malformed. }
    }

    action getSchema(schema: S) {
      -> ok(schema: S, uiSchema: String) { Return current schema. }
      -> notfound(message: String) { No schema exists. }
    }

    action getElements(schema: S) {
      -> ok(elements: String) {
        Return abstract element tree — intermediate
        representation consumed by downstream classification
        and widget resolution.
      }
      -> notfound(message: String) { No schema exists. }
    }
  }

  invariant {
    after inspect(schema: s, conceptSpec: "concept Test [T] { state { name: T -> String } }")
      -> ok(schema: s)
    then getElements(schema: s) -> ok(elements: _)
  }
}
