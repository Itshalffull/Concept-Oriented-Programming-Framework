@version(1)
concept Element [E] {

  purpose {
    Abstract, modality-independent interaction units. An Element
    describes WHAT a user can do — select, input, trigger, navigate,
    display — without specifying HOW it renders. The same Element
    renders as a dropdown in GUI, a prompt in CLI, an enum in API,
    or a picker in mobile.
  }

  state {
    kind: E -> String
    label: E -> String
    description: E -> option String
    dataType: E -> String
    required: E -> Bool
    constraints: E -> option String
    children: E -> list E
    parent: E -> option E
    interactorType: E -> option String
    interactorProps: E -> option String
    resolvedWidget: E -> option String
  }

  capabilities {
    requires persistent-storage
  }

  actions {
    action create(element: E, kind: String, label: String,
                  dataType: String) {
      -> ok(element: E) {
        Create an abstract element. Kind is one of:
        input-text, input-number, input-date, input-bool,
        selection-single, selection-multi, trigger, navigation,
        output-text, output-number, output-date, output-bool,
        group, container, rich-text, file-upload, media-display.
      }
      -> invalid(message: String) { Kind not recognized. }
    }

    action nest(parent: E, child: E) {
      -> ok(parent: E) { Add child to group or container. }
      -> invalid(message: String) { Parent cannot contain children. }
    }

    action setConstraints(element: E, constraints: String) {
      -> ok(element: E) {
        Apply constraints: min, max, minLength, maxLength,
        pattern, options (for selections).
      }
      -> notfound(message: String) { Element missing. }
    }

    action enrich(element: E, interactorType: String,
                  interactorProps: String) {
      -> ok(element: E) {
        Set the semantic interaction type and properties
        determined by classification.
      }
      -> notfound(message: String) { Element missing. }
    }

    action assignWidget(element: E, widget: String) {
      -> ok(element: E) {
        Set the resolved widget name determined by
        affordance matching.
      }
      -> notfound(message: String) { Element missing. }
    }

    action remove(element: E) {
      -> ok(element: E) { Remove element and detach children. }
      -> notfound(message: String) { Element missing. }
    }
  }

  invariant {
    after create(element: e, kind: "input-text", label: "Title",
                 dataType: "String") -> ok(element: e)
    then enrich(element: e, interactorType: "text-short",
                interactorProps: "{}") -> ok(element: e)
  }
}
