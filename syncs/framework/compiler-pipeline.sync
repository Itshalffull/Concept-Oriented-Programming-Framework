# ============================================================
# Stage 5 — Framework Synchronizations
#
# Multi-target compiler pipeline: SchemaGen produces a rich
# ConceptManifest, and per-language generators (TypeScriptGen,
# RustGen, SwiftGen, SolidityGen) each consume the manifest
# via their own sync. Adding a new language target requires
# only a new generator concept + one sync — no existing code
# changes.
#
# Pipeline: SpecParser → SchemaGen → TypeScriptGen
#                                  → RustGen
#                                  → SwiftGen
#                                  → SolidityGen
# ============================================================

# When a spec is parsed, generate the manifest
sync GenerateManifest [eager]
when {
  SpecParser/parse: [] => [ spec: ?spec; ast: ?ast ]
}
then {
  SchemaGen/generate: [ spec: ?spec; ast: ?ast ]
}

# When a manifest is generated, generate TypeScript code
sync GenerateTypeScript [eager]
when {
  SchemaGen/generate: [ spec: ?spec ] => [ manifest: ?manifest ]
}
then {
  TypeScriptGen/generate: [ spec: ?spec; manifest: ?manifest ]
}

# When a manifest is generated, generate Rust code
sync GenerateRust [eager]
when {
  SchemaGen/generate: [ spec: ?spec ] => [ manifest: ?manifest ]
}
then {
  RustGen/generate: [ spec: ?spec; manifest: ?manifest ]
}

# When a manifest is generated, generate Swift code
sync GenerateSwift [eager]
when {
  SchemaGen/generate: [ spec: ?spec ] => [ manifest: ?manifest ]
}
then {
  SwiftGen/generate: [ spec: ?spec; manifest: ?manifest ]
}

# When a manifest is generated, generate Solidity code
sync GenerateSolidity [eager]
when {
  SchemaGen/generate: [ spec: ?spec ] => [ manifest: ?manifest ]
}
then {
  SolidityGen/generate: [ spec: ?spec; manifest: ?manifest ]
}

# When a concept is registered, log it
sync LogRegistration [eager]
when {
  Registry/register: [] => [ concept: ?c ]
}
then {
  ActionLog/append: [ record: { type: "registration"; concept: ?c } ]
}
