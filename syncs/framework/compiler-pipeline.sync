# ============================================================
# Stage 5 — Framework Synchronizations
#
# Multi-target compiler pipeline: SchemaGen produces a rich
# ConceptManifest, and per-language generators (TypeScriptGen,
# RustGen) each consume the manifest via their own sync.
# Adding a new language target requires only a new generator
# concept + one sync — no existing code changes.
#
# Pipeline: SpecParser → SchemaGen → TypeScriptGen
#                                  → RustGen
# ============================================================

# When a spec is parsed, generate the manifest
sync GenerateManifest [eager]
when {
  SpecParser/parse: [] => [ spec: ?spec; ast: ?ast ]
}
then {
  SchemaGen/generate: [ spec: ?spec; ast: ?ast ]
}

# When a manifest is generated, generate TypeScript code
sync GenerateTypeScript [eager]
when {
  SchemaGen/generate: [ spec: ?spec ] => [ manifest: ?manifest ]
}
then {
  TypeScriptGen/generate: [ spec: ?spec; manifest: ?manifest ]
}

# When a manifest is generated, generate Rust code
sync GenerateRust [eager]
when {
  SchemaGen/generate: [ spec: ?spec ] => [ manifest: ?manifest ]
}
then {
  RustGen/generate: [ spec: ?spec; manifest: ?manifest ]
}

# When a concept is registered, log it
sync LogRegistration [eager]
when {
  Registry/register: [] => [ concept: ?c ]
}
then {
  ActionLog/append: [ record: { type: "registration"; concept: ?c } ]
}
