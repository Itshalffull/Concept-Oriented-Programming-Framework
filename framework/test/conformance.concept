@version(1)
concept Conformance [C] {

  purpose {
    Verify that generated code faithfully implements concept
    specifications. Maintain spec-to-test traceability. Track
    per-target conformance status. Document and manage acceptable
    deviations where a target language can't fully express a
    spec requirement.
  }

  state {
    suites: set C
    registry {
      concept: C -> String
      specVersion: C -> String
      targets: C -> list {
        language: String
        status: String
        coveredRequirements: Int
        totalRequirements: Int
        deviations: list { requirement: String, reason: String }
      }
    }
    requirements {
      specRequirements: C -> list {
        id: String
        description: String
        source: String
        category: String
      }
    }
    lastRun: C -> option DateTime
  }

  actions {
    action generate(concept: String, specPath: String) {
      -> ok(suite: C, testVectors: list { id: String, description: String, input: String, expectedOutput: String }) {
        Parse concept spec and generate language-independent
        test vectors. Each vector specifies an action invocation
        and expected outcome based on the spec's operational
        principle and invariants.

        Test vectors are language-independent — the same vector
        is executed against the TypeScript, Rust, Swift, and
        Solidity implementations.
      }
      -> specError(concept: String, message: String) {
        Spec couldn't be parsed or has ambiguous requirements.
      }
    }

    action verify(suite: C, language: String, artifactLocation: String) {
      -> ok(passed: Int, total: Int, coveredRequirements: list String) {
        Run conformance test vectors against a built artifact
        for a specific language. Returns which spec requirements
        are covered by passing tests.
      }
      -> failure(passed: Int, failed: Int, failures: list { testId: String, requirement: String, expected: String, actual: String }) {
        Some conformance tests failed. Each failure traces back
        to a specific spec requirement.
      }
      -> deviationDetected(requirement: String, language: String, reason: String) {
        A known deviation — the language can't express this
        requirement. Recorded, not treated as failure.
      }
    }

    action registerDeviation(concept: String, language: String, requirement: String, reason: String) {
      -> ok(suite: C) {
        Record an acceptable deviation. Example: Solidity
        can't express Option types the same way as Rust,
        so the conformance test for optional return values
        uses a different assertion shape.
      }
    }

    action matrix(concepts: option list String) {
      -> ok(matrix: list {
        concept: String,
        targets: list { language: String, conformance: String, covered: Int, total: Int, deviations: Int }
      }) {
        Return cross-target conformance matrix.
        Shows which concepts pass conformance for which
        languages. conformance values: "full", "partial",
        "failing", "untested".
      }
    }

    action traceability(concept: String) {
      -> ok(requirements: list {
        id: String,
        description: String,
        testedBy: list { language: String, testId: String, status: String }
      }) {
        Return full traceability: which spec requirements
        are tested by which test vectors in which languages.
      }
    }
  }

  invariant {
    after generate(concept: "password", specPath: "./specs/password.concept")
      -> ok(suite: c, testVectors: vs)
    and  verify(suite: c, language: "typescript", artifactLocation: ".clef-artifacts/ts/password")
      -> ok(passed: 12, total: 12, coveredRequirements: reqs)
    then matrix(concepts: ["password"]) -> ok(matrix: m)
  }
}
