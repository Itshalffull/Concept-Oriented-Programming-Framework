@version(1)
concept Emitter [F] {

  purpose {
    Materialize generated content as files. Content-addressed:
    same input produces same hash, skip-write preserves timestamps.
    Handles formatting, directory structure, orphan cleanup,
    source traceability, and drift detection.
  }

  state {
    manifest: F -> {
      path: String
      contentHash: String
      written: Bool
      lastWritten: DateTime
    }
    formatters: String -> String
    sourceMap: F -> list {
      sourcePath: String
      sourceRange: option String
      conceptName: option String
      actionName: option String
    }
  }

  actions {
    action write(path: String, content: String, formatHint: option String, sources: option list { sourcePath: String, sourceRange: option String, conceptName: option String, actionName: option String }) {
      -> ok(written: Bool, path: String, contentHash: String) {
        Compute content hash. Compare against manifest.
        If unchanged, skip write (written: false).
        If changed or new, write file (written: true).
        Update manifest with new hash and timestamp.

        If sources is provided, record in sourceMap for
        traceability. Generators that know provenance pass it;
        generators that don't, don't.
      }
      -> error(message: String, path: String) {
        Write failed (permissions, disk full, invalid path).
      }
    }

    action writeBatch(files: list { path: String, content: String, formatHint: option String, sources: option list { sourcePath: String, sourceRange: option String, conceptName: option String, actionName: option String } }) {
      -> ok(results: list { path: String, written: Bool, contentHash: String }) {
        Write multiple files atomically. If any file fails,
        none are written. Returns per-file results.
        More efficient — single manifest update, single format pass.
      }
      -> error(message: String, failedPath: String) {
        Batch write failed. No files were written.
      }
    }

    action format(path: String) {
      -> ok(changed: Bool) {
        Apply configured formatter (prettier, black, gofmt, rustfmt,
        buf format) based on file extension. No-op if no formatter
        configured for this extension.
      }
      -> error(message: String) {
        Formatter failed.
      }
    }

    action clean(outputDir: String, currentManifest: list String) {
      -> ok(removed: list String) {
        Remove files in outputDir that are NOT in currentManifest.
        These are orphans from previous generations. Only removes
        files tracked in the Emitter manifest — never removes
        files that weren't generated by the system.
      }
    }

    action manifest(outputDir: String) {
      -> ok(files: list { path: String, hash: String, lastWritten: DateTime }) {
        Return the current output manifest for an output directory.
        Used by dry-run, status, and diff commands.
      }
    }

    action trace(outputPath: String) {
      -> ok(sources: list { sourcePath: String, sourceRange: option String, conceptName: option String, actionName: option String }) {
        Return all source elements that contributed to this
        output file. Enables "which spec produced this generated
        code?" queries.
      }
      -> notFound(path: String) {
        Output path not in manifest.
      }
    }

    action affected(sourcePath: String) {
      -> ok(outputs: list String) {
        Return all output files whose sourceMap includes this
        source path. Enables "what regenerates if I change this
        spec?" queries.
      }
    }

    action audit(outputDir: String) {
      -> ok(status: list {
        path: String
        state: String
        expectedHash: option String
        actualHash: option String
      }) {
        Compare manifest against filesystem for drift detection.

        States:
        "current" — file exists, hash matches manifest.
        "drifted" — file exists, hash differs (manually edited).
        "missing" — in manifest but not on disk.
        "orphaned" — on disk in a generated dir but not in manifest.
      }
    }
  }

  invariant {
    after write(path: "src/password.ts", content: "export const x = 1;", formatHint: "typescript", sources: []) -> ok(written: true, path: "src/password.ts", contentHash: h1)
    then  write(path: "src/password.ts", content: "export const x = 1;", formatHint: "typescript", sources: []) -> ok(written: false, path: "src/password.ts", contentHash: h1)
  }

  invariant {
    after write(path: "src/password.ts", content: "export const x = 1;", formatHint: "typescript", sources: [{ sourcePath: "./specs/password.concept" }]) -> ok(written: true, path: p, contentHash: h)
    then  trace(outputPath: "src/password.ts") -> ok(sources: s)
    and   affected(sourcePath: "./specs/password.concept") -> ok(outputs: o)
  }
}
