@version(1)
concept DeployPlan [D] {

  purpose {
    Compute, validate, and execute deployment plans for kits.
    Constructs a dependency graph from concept specs, syncs,
    and the deploy manifest, then executes operations in
    topological order with parallelism on independent branches.
  }

  state {
    plans: set D
    graph {
      nodes: D -> list { id: String, kind: String, target: String, status: String }
      edges: D -> list { from: String, to: String }
    }
    metadata {
      kitName: D -> String
      kitVersion: D -> String
      environment: D -> String
      createdAt: D -> DateTime
      strategy: D -> String
    }
    execution {
      currentPhase: D -> String
      completedNodes: D -> list String
      failedNodes: D -> list String
      rollbackStack: D -> list String
    }
  }

  actions {
    action plan(manifest: String, environment: String) {
      -> ok(plan: D, graph: String, estimatedDuration: Int) {
        Parse the deploy manifest, resolve environment overlays,
        construct the deploy DAG. Return the plan for inspection
        before execution. Graph returned as serialized JSON.
      }
      -> invalidManifest(errors: list String) {
        Manifest parsing or schema validation failed.
      }
      -> incompleteGraph(missing: list String) {
        Sync references concepts not present in manifest or
        declared as external dependencies.
      }
      -> circularDependency(cycle: list String) {
        Deploy graph contains a cycle.
      }
      -> transportMismatch(details: list String) {
        Connected concepts use incompatible transports
        without an adapter path.
      }
    }

    action validate(plan: D) {
      -> ok(plan: D, warnings: list String) {
        All pre-deployment invariants pass: sync completeness,
        transport compatibility, storage migration safety,
        dependency ordering. Warnings for non-blocking issues.
      }
      -> migrationRequired(plan: D, concepts: list String, fromVersions: list Int, toVersions: list Int) {
        Storage schema changes detected. Migration must run
        before deployment can proceed.
      }
      -> schemaIncompatible(details: list String) {
        Breaking schema change with no migration path declared.
      }
    }

    action execute(plan: D) {
      -> ok(plan: D, duration: Int, nodesDeployed: Int) {
        All nodes in the deploy graph executed successfully.
        Progressive delivery completed if configured.
      }
      -> partial(plan: D, deployed: list String, failed: list String) {
        Some nodes succeeded, some failed. System is in a
        mixed state. Rollback recommended but not automatic.
      }
      -> rollbackTriggered(plan: D, reason: String, rolledBack: list String) {
        Deployment failed and automatic rollback executed.
        All compensating actions completed.
      }
      -> rollbackFailed(plan: D, reason: String, stuck: list String) {
        Rollback itself failed. Manual intervention required.
        Lists the nodes that could not be rolled back.
      }
    }

    action rollback(plan: D) {
      -> ok(plan: D, rolledBack: list String) {
        Compensating actions executed in reverse dependency order.
      }
      -> partial(plan: D, rolledBack: list String, stuck: list String) {
        Some rollbacks succeeded, some failed.
      }
    }

    action status(plan: D) {
      -> ok(plan: D, phase: String, progress: Float, activeNodes: list String) {
        Current execution status of an in-progress deployment.
      }
      -> notfound(plan: D) {
        Plan does not exist.
      }
    }
  }

  invariant {
    after plan(manifest: "valid-manifest", environment: "staging") -> ok(plan: p, graph: g, estimatedDuration: 300)
    then validate(plan: p) -> ok(plan: p, warnings: w)
    and execute(plan: p) -> ok(plan: p, duration: 120, nodesDeployed: 5)
  }
}
