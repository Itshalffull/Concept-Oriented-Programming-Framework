@version(1)
concept Validator [V] {

  purpose {
    Enforce runtime constraints at write time by validating data against
    schema rules, field rules, and custom validators.
  }

  state {
    constraints: set V
    schemaRules: V -> String
    fieldRules: V -> String
    customValidators: V -> String
  }

  actions {
    action registerConstraint(validator: V, constraint: String) {
      -> ok() {
        Register a new constraint on the validator.
      }
      -> exists() {
        The constraint is already registered on this validator.
      }
    }

    action addRule(validator: V, field: String, rule: String) {
      -> ok() {
        Add a field-level validation rule to the validator.
      }
      -> notfound() {
        The specified validator does not exist.
      }
    }

    action validate(validator: V, data: String) {
      -> ok(valid: Bool, errors: String) {
        Validate the data against all registered constraints and rules, returning validity and any errors.
      }
    }

    action validateField(validator: V, field: String, value: String) {
      -> ok(valid: Bool, errors: String) {
        Validate a single field value against its registered rules.
      }
    }

    action coerce(validator: V, data: String) {
      -> ok(coerced: String) {
        Attempt to coerce the data into a valid form according to the validator rules.
      }
      -> error(message: String) {
        The data could not be coerced into a valid form.
      }
    }

    action addCustomValidator(validator: V, name: String, implementation: String) {
      -> ok() {
        Register a custom validator function by name.
      }
      -> exists() {
        A custom validator with this name is already registered.
      }
    }
  }

  invariant {
    after registerConstraint(validator: v, constraint: "required") -> ok()
    then addRule(validator: v, field: "email", rule: "required|email") -> ok()
    and  validate(validator: v, data: "{\"email\":\"\"}") -> ok(valid: false, errors: "email is required")
  }
}
