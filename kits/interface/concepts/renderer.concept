@version(2)
concept Renderer [R] {

  purpose {
    Render opaque enrichment JSON into formatted output strings
    using data-driven templates. Handlers are declarative — each
    maps an enrichment key to a built-in render pattern (list,
    checklist, code-list, callout, heading-body, bad-good, etc.)
    plus a template config with {{field}} interpolation. Patterns
    are the small code surface shipped once; handlers are pure
    data that can live in YAML manifests. New enrichment kinds
    need only a YAML entry — zero code changes.
    See Architecture doc Section 1.8.
  }

  state {
    handlers: set R
    registry {
      key: R -> String
      format: R -> String
      order: R -> Int
      pattern: R -> String
      template: R -> String
    }
  }

  actions {
    action register(key: String, format: String, order: Int, pattern: String, template: String) {
      description {
        Register a handler for an enrichment key in a given format.
        Order determines rendering position — lower numbers render
        first. Pattern names a built-in render pattern (list,
        checklist, code-list, link-list, callout, heading-body,
        bad-good, scaffold-list, slash-list, keyed-checklist,
        inline-list). Template is a JSON config for the pattern
        with {{field}} interpolation placeholders. If a handler
        already exists for the (key, format) pair, it is replaced.
      }
      -> ok(handler: R) {
        Handler registered.
      }
      -> unknownPattern(pattern: String) {
        The named pattern does not exist.
      }
      -> invalidTemplate(template: String, reason: String) {
        Template config is malformed JSON.
      }
    }

    action render(content: String, format: String) {
      description {
        Render enrichment content in the given format. Parses the
        content JSON, walks top-level keys, dispatches each to the
        registered handler's pattern with its template config. Keys
        without a handler are collected in unhandledKeys for
        transparency. Output sections are ordered by handler order.
      }
      -> ok(output: String, sectionCount: Int, unhandledKeys: list String) {
        Rendered output with sections assembled in order.
        unhandledKeys lists content keys that had no registered
        handler for this format — not an error, just transparency.
      }
      -> invalidContent(reason: String) {
        Content string is not valid JSON.
      }
      -> unknownFormat(format: String) {
        No handlers registered for this format.
      }
    }

    action listHandlers(format: String) {
      -> ok(handlers: list String, count: Int) {
        Handler keys for the format, in render order.
      }
    }

    action listPatterns() {
      description {
        List all available render patterns.
      }
      -> ok(patterns: list String) {
        Names of built-in patterns available for handler templates.
      }
    }
  }

  invariant {
    after register(key: "migration-guide", format: "skill-md", order: 75,
      pattern: "heading-body", template: "{\"heading\":\"Migration Guide\"}")
      -> ok(handler: h)
    then render(
      content: "{\"migration-guide\":{\"heading\":\"Migration Guide\",\"body\":\"Follow these steps...\"}}",
      format: "skill-md")
      -> ok(output: o, sectionCount: 1, unhandledKeys: u)
  }
}
