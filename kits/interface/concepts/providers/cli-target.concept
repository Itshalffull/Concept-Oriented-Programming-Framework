@version(3)
concept CliTarget [C] {

  purpose {
    Generate CLI command trees from concept projections. Owns
    command/subcommand structure, flag derivation, argument
    mapping, output formatting (JSON/table/YAML), shell
    completion generation, and interactive mode for streaming.
    When @hierarchical trait is present, generates multi-level
    subcommand trees with auto-generated tree subcommand,
    --parent/--depth/--path flags, and breadcrumb display.
    Enrichment content from Projection is passed through for
    help text and example generation.
    See Architecture doc Section 2.4.
  }

  state {
    commands: set C
    config {
      binaryName: C -> String
      shell: C -> String
      outputFormats: C -> list String
    }
    commandTree {
      parent: C -> option C
      name: C -> String
      description: C -> String
      children: C -> list C
      depth: C -> Int
    }
    mapping {
      concept: C -> String
      action: C -> String
      command: C -> String
      args: C -> list { name: String, kind: String, required: Bool, positional: Bool, choices: list String, default: String }
      flags: C -> list { name: String, type: String, required: Bool, description: String, short: String }
    }
    help {
      synopsis: C -> String
      longDescription: C -> option String
      examples: C -> list { description: String, command: String }
      seeAlso: C -> list String
    }
    content: C -> String
  }

  actions {
    action generate(projection: String, config: String) {
      -> ok(commands: list String, files: list String) {
        CLI command tree generated from projection. Concept
        names become top-level command groups. Action names
        become subcommands. Flags derived from action parameters.
        Shell completion scripts produced for configured shells.
        Output formatters attached per command. Help text
        generated from concept purpose and action prose.
      }
      -> tooManyPositional(action: String, count: Int) {
        Action has more positional arguments than CLI
        conventions allow. Excess arguments should be
        converted to flags via annotation.
      }
    }

    action validate(command: C) {
      -> ok(command: C) {
        Command tree is well-formed. No flag name collisions.
        All required arguments have consistent types. Shell
        completion scripts are syntactically valid.
      }
      -> flagCollision(command: C, flag: String, actions: list String) {
        Two actions in the same command subtree define flags
        with the same name but different types.
      }
    }

    action listCommands(concept: String) {
      -> ok(commands: list String, subcommands: list String) {
        Return all generated commands and subcommands for
        a concept, including the full command tree hierarchy.
      }
    }
  }

  invariant {
    after generate(projection: "task-projection", config: "{}") -> ok(commands: c, files: f)
    then listCommands(concept: "Task") -> ok(commands: cmds, subcommands: subs)
  }
}
