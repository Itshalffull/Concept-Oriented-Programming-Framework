# Transport Interface Reference

Complete type definitions for the Clef transport layer. All adapters implement `ConceptTransport`.

## ConceptTransport

The interface every transport adapter must implement:

```typescript
interface ConceptTransport {
  invoke(invocation: ActionInvocation): Promise<ActionCompletion>;
  query(request: ConceptQuery): Promise<Record<string, unknown>[]>;
  health(): Promise<{ available: boolean; latency: number }>;
  queryMode: 'graphql' | 'lite';
}
```

### `invoke(invocation): Promise<ActionCompletion>`

Sends an action invocation to the concept and returns the completion.

**Contract:**
- The adapter sends the full `ActionInvocation` envelope to the concept
- The concept processes the action and returns an `ActionCompletion`
- The completion must preserve: `id`, `concept`, `action`, `input`, `flow` from the invocation
- The completion adds: `variant`, `output`, `timestamp`
- If the action is unknown, return a completion with `variant: 'error'`
- If the transport fails (network error, timeout), throw an Error

### `query(request): Promise<Record<string, unknown>[]>`

Queries the concept's state during sync where-clause evaluation.

**Contract:**
- Returns an array of records matching the query
- In `lite` mode: uses `request.relation` and `request.args` to filter
- In `graphql` mode: uses `request.graphql` (a GraphQL query string) or builds one from `request.relation`/`request.args`
- Returns `[]` if no matches
- Throws on transport failure

### `health(): Promise<{ available: boolean; latency: number }>`

Checks whether the concept is reachable and measures round-trip latency.

**Contract:**
- `available: true` if the concept responds within timeout
- `available: false` if the concept is unreachable or errors
- `latency`: round-trip time in milliseconds
- Must never throw — catches errors internally and returns `{ available: false, latency }`

### `queryMode: 'graphql' | 'lite'`

Declares which query protocol this adapter uses. Set once at creation time, does not change.

## ActionInvocation

The message the engine sends when invoking a concept action:

```typescript
interface ActionInvocation {
  id: string;                        // Unique invocation ID (UUID)
  concept: string;                   // Concept URI (e.g., "urn:app:Password")
  action: string;                    // Action name (e.g., "register")
  input: Record<string, unknown>;    // Action input fields
  flow: string;                      // Flow ID for provenance tracking
  sync?: string;                     // Sync that triggered this invocation
  timestamp: string;                 // ISO 8601 timestamp
}
```

**Fields:**
- `id` — Unique ID for this invocation. Generated by the engine via `generateId()`.
- `concept` — The URI of the target concept. Must match the registry key.
- `action` — The action name from the concept spec.
- `input` — Key-value pairs matching the action's parameters.
- `flow` — Flow ID that ties all related invocations/completions together.
- `sync` — Optional: the sync that triggered this invocation.
- `timestamp` — When the engine created this invocation.

## ActionCompletion

The message returned after a concept processes an action:

```typescript
interface ActionCompletion {
  id: string;                        // Same ID as the invocation
  concept: string;                   // Same concept as the invocation
  action: string;                    // Same action as the invocation
  input: Record<string, unknown>;    // Same input as the invocation
  variant: string;                   // Result variant (e.g., "ok", "error", "notfound")
  output: Record<string, unknown>;   // Variant-specific output fields
  flow: string;                      // Same flow as the invocation
  timestamp: string;                 // When the completion was produced
}
```

**Variant semantics:**
- `variant` is a discriminated union tag from the concept spec's return types
- Common variants: `ok`, `error`, `notfound`, `duplicate`, `denied`
- The engine uses the variant + output to match `when` patterns in syncs
- Error variants are normal completions — the engine chains them through syncs like any other variant

## ConceptQuery

The query the engine sends during where-clause evaluation:

```typescript
interface ConceptQuery {
  relation: string;                  // State relation to query (e.g., "credentials")
  args?: Record<string, unknown>;    // Filter criteria (key-value pairs)
  graphql?: string;                  // Full GraphQL query string (graphql mode only)
}
```

**Usage by query mode:**

| Field | Lite Mode | GraphQL Mode |
|-------|-----------|-------------|
| `relation` | Required — the relation to query | Used to build query if `graphql` is absent |
| `args` | Optional — filter criteria for `storage.find()` | Used to build query if `graphql` is absent |
| `graphql` | Ignored | Preferred — full GraphQL query string |

## ConceptRegistry

The registry maps concept URIs to transport adapters:

```typescript
interface ConceptRegistry {
  register(uri: string, transport: ConceptTransport): void;
  resolve(uri: string): ConceptTransport | undefined;
  available(uri: string): boolean;
  reloadConcept?(uri: string, transport: ConceptTransport): void;
  deregisterConcept?(uri: string): boolean;
}
```

**Methods:**
- `register(uri, transport)` — Maps a concept URI to a transport adapter
- `resolve(uri)` — Returns the adapter for a concept, or `undefined` if not registered
- `available(uri)` — Returns `true` if the concept is registered
- `reloadConcept(uri, transport)` — Hot-swap the adapter (in-flight calls drain naturally)
- `deregisterConcept(uri)` — Remove a concept from the registry

**Source:** `kernel/src/transport.ts:createConceptRegistry()`

## ConceptHandler

The handler interface that in-process adapters wrap:

```typescript
interface ConceptHandler {
  [actionName: string]: (
    input: Record<string, unknown>,
    storage: ConceptStorage,
  ) => Promise<{ variant: string; [key: string]: unknown }>;
}
```

**Used by:** `InProcessAdapter` — wraps a handler + storage into a `ConceptTransport`.

## ConceptStorage

The storage interface used by in-process concepts:

```typescript
interface ConceptStorage {
  put(relation: string, key: string, value: Record<string, unknown>): Promise<void>;
  get(relation: string, key: string): Promise<Record<string, unknown> | null>;
  find(relation: string, criteria?: Record<string, unknown>): Promise<Record<string, unknown>[]>;
  del(relation: string, key: string): Promise<void>;
  delMany(relation: string, criteria: Record<string, unknown>): Promise<number>;
  getMeta?(relation: string, key: string): Promise<EntryMeta | null>;
  onConflict?: (info: ConflictInfo) => ConflictResolution;
}
```

**Used by:** `InProcessAdapter.query()` delegates to `storage.find()`.

## LiteQueryProtocol

The three-tier query protocol for lite mode concepts:

```typescript
interface LiteQueryProtocol {
  snapshot(): Promise<ConceptStateSnapshot>;
  lookup?(relation: string, key: string): Promise<Record<string, unknown> | null>;
  filter?(criteria: LiteFilter[]): Promise<Record<string, unknown>[]>;
}

interface LiteFilter {
  field: string;
  op: 'eq' | 'neq' | 'gt' | 'gte' | 'lt' | 'lte' | 'in' | 'contains';
  value: unknown;
}

interface ConceptStateSnapshot {
  asOf: string;
  relations: Record<string, Record<string, unknown>[]>;
}
```

**Tier fallback:** Engine tries `lookup` → `filter` → `snapshot`, falling through if a tier is not implemented.

## Source Files

| Type | Source |
|------|--------|
| `ConceptTransport`, `ConceptQuery` | `kernel/src/types.ts:91-102` |
| `ActionInvocation`, `ActionCompletion` | `kernel/src/types.ts:9-28` |
| `ConceptRegistry` | `kernel/src/types.ts:106-114` |
| `ConceptHandler`, `ConceptStorage` | `kernel/src/types.ts:68-87` |
| `LiteQueryProtocol`, `LiteFilter` | `kernel/src/types.ts:386-401` |
| `createConceptRegistry()` | `kernel/src/transport.ts:75-109` |
