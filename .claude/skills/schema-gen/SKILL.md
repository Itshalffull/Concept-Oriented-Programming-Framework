---
name: schema-gen
description: Transform parsed concept ASTs into rich , language neutral 
 ConceptManifests The manifest contains everything a code 
 generator needs : relation schemas ( after merge grouping ) , 
 fully typed action signatures , structured invariants with 
 test values , GraphQL schema fragments , and JSON Schemas
argument-hint: $ARGUMENTS
allowed-tools: Read, Grep, Glob, Edit, Write, Bash
---

<!-- Auto-generated by COPF Interface Kit — claude-skills target -->
<!-- Concept: SchemaGen -->
<!-- Do not edit manually; regenerate with: copf interface generate -->

# SchemaGen

Generate a ConceptManifest from **$ARGUMENTS** that provides typed action signatures, state schemas, and invariant test values for code generation.


> **When to use:** Use when generating ConceptManifests from parsed ASTs, implementing concept handlers, or inspecting the schema that drives code generation.


## Design Principles

- **One Handler per Action:** Each action in the concept spec maps to exactly one async method in the implementation handler.
- **Variant Completeness:** Every return variant declared in the spec must have a corresponding code path in the handler — no missing branches.
- **Storage Sovereignty:** Each concept owns its storage exclusively — no shared databases, no cross-concept state access.

## Step-by-Step Process

### Step 1: Generate Schema from Spec

Generate ConceptManifest from parsed AST. The manifest provides typed action signatures for implementation.

**Arguments:** `$0` **spec** (S), `$1` **ast** (ast)

**Checklist:**
- [ ] All action parameters have types?
- [ ] Return variants match spec declarations?
- [ ] State relations are correctly grouped?
- [ ] Type parameters are resolved?

**Examples:**
*Generate manifest from AST*
```typescript
import { schemaGenHandler } from './schema-gen.impl';
const result = await schemaGenHandler.generate(
  { conceptAst: JSON.stringify(ast) }, storage
);
```
*Generate from CLI*
```bash
copf generate specs/my-concept.concept
```

## References

- [Implementation patterns and storage](references/implementation-patterns.md)
- [Spec-to-TypeScript type mapping rules](references/type-mapping.md)
## Supporting Materials

- [End-to-end handler implementation walkthrough](examples/implement-a-handler.md)
## Quick Reference

| Spec Type | TypeScript Type | Notes |
|-----------|----------------|-------|
| String | string | Direct mapping |
| Int | number | Direct mapping |
| Bool | boolean | Direct mapping |
| list T | T[] | Array mapping |
| option T | T \| undefined | Optional mapping |
| set T | Set<T> or Map | Primary collection |


## Example Walkthroughs

For complete examples with design rationale:

- [Implement a concept handler (User example)](examples/implement-a-handler.md)
## Anti-Patterns

### Cross-concept storage access
Handler reads or writes another concept's storage — violates sovereignty.

**Bad:**
```
async create(input, storage) {
  const user = await userStorage.get(input.userId); // Wrong!
  // ...
}

```

**Good:**
```
async create(input, storage) {
  // userId is passed in — concept doesn't know where it came from
  const item = { id: generateId(), owner: input.userId };
  await storage.set(item.id, item);
  return { variant: 'ok', item: item.id };
}

```
## Validation

*Generate manifests from specs:*
```bash
npx tsx tools/copf-cli/src/index.ts generate
```
*Run schema generation tests:*
```bash
npx vitest run tests/schema-gen.test.ts
```
## Related Skills

| Skill | When to Use |
| --- | --- |
| `/concept-designer` | Design concepts before implementing them |
| `/concept-validator` | Validate specs before generating schemas |
| `/sync-designer` | Wire implemented concepts together with syncs |
