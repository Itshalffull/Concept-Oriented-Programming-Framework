# Type Parameter Alignment

How to declare shared type identities across concepts within a kit, so the compiler can validate sync correctness and humans can understand the intended relationships.

## The Problem

Consider a content management kit with Entity, Field, and Relation concepts. Each is independently designed with its own type parameter:

```
concept Entity [E] { ... }
concept Field [F] { state { target: F -> String } ... }
concept Relation [R] { state { source: R -> String; target: R -> String } ... }
```

When writing syncs, we pass values between these concepts:

```
sync CascadeDeleteFields [required]
when {
  Entity/delete: [ entity: ?entity ] => [ entity: ?entity ]
}
where {
  Field: { ?field target: ?entity }  // ?entity flows from Entity's E to Field's target
}
then {
  Field/detach: [ field: ?field ]
}
```

The `?entity` variable flows from Entity (where it's an `E`) to Field's `target` lookup (where it's a `String`). At runtime this works fine — all type parameters are strings. But how do we know this is intentional and not a mistake?

## The Solution: `as` Tags

The `params` section in `kit.yaml` assigns shared identity tags using `as`:

```yaml
concepts:
  Entity:
    spec: ./entity.concept
    params:
      E: { as: entity-ref, description: "Reference to an entity" }

  Field:
    spec: ./field.concept
    params:
      F: { as: field-ref, description: "Reference to a field instance" }
      T: { as: entity-ref }    # Same as Entity's E

  Relation:
    spec: ./relation.concept
    params:
      R: { as: relation-ref, description: "Reference to a relation" }
      T: { as: entity-ref }    # Same as Entity's E

  Node:
    spec: ./node.concept
    params:
      N: { as: entity-ref }    # Node IS an entity
```

**What `as: entity-ref` means**: Entity's `E`, Field's `T`, Relation's `T`, and Node's `N` all carry the same kind of opaque identifier at runtime. UUIDs generated by Entity/create can safely flow into Field/attach's target parameter, because they share the `entity-ref` identity.

## Alignment Rules

### Same `as` tag = Same wire type

Parameters with the same `as` tag carry the same kind of identifier. A UUID from Entity/create can be passed to any parameter tagged `as: entity-ref`.

### Different `as` tags = Different wire types

Parameters with different `as` tags are not expected to be interchangeable. Passing a `field-ref` where an `entity-ref` is expected is likely a bug.

### Advisory, not enforcing

At runtime, ALL type parameters are strings. The alignment is advisory:
- The compiler **warns** if a sync passes a value between misaligned parameters
- The compiler does **not error** — creative uses are allowed
- The alignment is documentation for humans and LLMs writing syncs

### Every parameter needs an `as` tag

If a concept has a type parameter, it must be declared in the kit manifest with an `as` tag. This is how the compiler knows which parameters to compare.

## Writing Alignment Tags

### Naming convention

Use kebab-case nouns with a `-ref` suffix:
- `entity-ref` — references to entities
- `field-ref` — references to field instances
- `user-ref` — references to users
- `article-ref` — references to articles
- `token-ref` — references to tokens

### Primary vs. secondary parameters

Most concepts have one type parameter (their primary entity). Some concepts have multiple:

```yaml
Field:
  spec: ./field.concept
  params:
    F: { as: field-ref, description: "Reference to a field instance" }  # Primary
    T: { as: entity-ref }  # Secondary — the entity this field attaches to
```

The primary parameter (`F`) is the concept's own entity type. The secondary parameter (`T`) connects to another concept's entity type.

### Cross-kit alignment

When a kit integrates with another kit, use the same `as` tags:

```yaml
# content-management kit
integrations:
  - kit: auth
    syncs:
      - path: ./syncs/entity-ownership.sync
        description: Record which user created an entity.
```

In the integration sync, the `?user` variable would carry `user-ref` (from the auth kit) and `?entity` would carry `entity-ref` (from this kit). Even though the kits are separate, the `as` tags let the compiler check consistency.

## Compiler Validation

When the compiler processes a kit's syncs, it checks:

1. **Variable flow**: When `?var` flows from one concept to another in a sync, check if the source parameter's `as` tag matches the destination's
2. **Lookup bindings**: When `where { Concept: { ?entity field: ?var } }` binds a variable, check if the entity lookup's type aligns with the variable's source
3. **Advisory warnings**: Misalignment produces a warning, not an error

Example warning:
```
WARNING: In sync CascadeDeleteReactions, variable ?entity flows from
  Entity/delete (entity-ref) to Reaction/target (field-ref).
  Expected entity-ref. This may be intentional — suppress with
  #suppress-alignment if so.
```

## Alignment in the Auth Kit Example

```yaml
# kits/auth/kit.yaml
concepts:
  User:
    spec: ./user.concept
    params:
      U: { as: user-ref, description: "Reference to a user account" }

  Password:
    spec: ./password.concept
    params:
      U: { as: user-ref }    # Same user that User manages

  JWT:
    spec: ./jwt.concept
    params:
      U: { as: user-ref }    # Tokens are for users
```

All three concepts share `user-ref`. When the login sync passes `?user` from Password/check's output to JWT/generate's input, the compiler can verify both parameters carry `user-ref`.

## Common Patterns

### Entity-owns-children

Parent owns a collection, children reference parent via aligned parameter:

```yaml
Article:
  params:
    A: { as: article-ref }
Comment:
  params:
    C: { as: comment-ref }
    T: { as: article-ref }   # The article this comment is on
```

### User-keyed relations

Multiple concepts keyed by the same user identity:

```yaml
User:
  params: { U: { as: user-ref } }
Profile:
  params: { U: { as: user-ref } }
Follow:
  params: { U: { as: user-ref } }
Favorite:
  params: { U: { as: user-ref } }
```

### Entity-is-also-parent

A concept IS a specialization of another concept's type:

```yaml
Entity:
  params: { E: { as: entity-ref } }
Node:
  params: { N: { as: entity-ref } }  # A Node IS an Entity
```

Node's `N` shares `entity-ref` because a Node identifier is also a valid Entity identifier — they're the same thing.
