---
name: test-selection
description: Select the minimum set of tests to run given a code change 
 Maintain source to test mappings from runtime coverage data 
 Prioritize tests by historical failure probability , change 
 proximity , and execution cost Enable confident defect 
 detection while minimizing total test execution time
argument-hint: [command] [changedSources] [testType]
---

<!-- Auto-generated by COPF Interface Kit â€” claude-skills target -->
<!-- Concept: TestSelection -->
<!-- Do not edit manually; regenerate with: copf interface generate -->

# TestSelection

Select the minimum set of tests to run given a code change 
 Maintain source to test mappings from runtime coverage data 
 Prioritize tests by historical failure probability , change 
 proximity , and execution cost Enable confident defect 
 detection while minimizing total test execution time

## Commands

### analyze
Given changed source files , compute which tests are 
 affected using stored source to test coverage mappings 
 If testType is provided , only return tests of that type 
 Otherwise returns all affected tests across all types 
 Relevance score ( 0 -1 ) based on : 
 Direct coverage ( test exercises changed code ) : 1.0 
 Transitive dependency : 0.5 -0.9 
 Historical co failure : variable 
 Reason explains why each test was selected : 
 direct-coverage , transitive-dep , co-failure-history

**Arguments:** `$0` **changedSources** (string[]), `$1` **testType** (string?)

### select
From the affected tests , select the subset to run 
 within the given budget Prioritized by : 
 1 Recent failure history ( tests that failed recently ) 
 2 Relevance score ( higher more likely affected ) 
 3 Execution cost ( faster tests first for quick signal ) 
 If no budget specified , returns all affected tests

**Arguments:** `$0` **affectedTests** (unknown[]), `$1` **budget** (unknown?)

### record
Update source to test coverage mapping after a test 
 execution testType indicates which runner produced the 
 coverage data ( e g , unit , e2e , integration ) 
 This is how mappings are built instrumenting test runs 
 to collect file level coverage , then storing the 
 test to source mapping

**Arguments:** `$0` **testId** (string), `$1` **language** (string), `$2` **testType** (string), `$3` **coveredSources** (string[]), `$4` **duration** (int), `$5` **passed** (bool)

### statistics
Return selection effectiveness statistics 
 Selection ratio : what fraction of tests are typically 
 selected ( lower more efficient )
