# COPF DevTools — Interface Generation Manifest
#
# Generates Claude Skills and CLI commands from
# framework concept specs. Uses workflow and annotation
# metadata to produce rich, step-based skills that
# match the hand-written originals.
#
# Usage:
#   copf interface generate --manifest examples/devtools/devtools.interface.yaml

interface:
  name: copf-devtools
  version: 0.2.0

# ─── GENERATION TARGETS ──────────────────────────────
targets:
  claude-skills:
    name: copf-devtools
    grouping: per-concept
    output-dir: ./.claude/skills

  cli:
    name: copf
    output-dir: ./tools/copf-cli/src/commands

# ─── CONCEPT SPECS ───────────────────────────────────
# Framework concepts that map to CLI commands and skills.
# Each concept has corresponding actions in its .concept spec.
concepts:
  - specs/framework/spec-parser.concept
  - specs/framework/schema-gen.concept
  - specs/framework/sync-parser.concept
  - specs/framework/sync-compiler.concept
  - specs/framework/flow-trace.concept
  - specs/framework/deployment-validator.concept
  - specs/framework/migration.concept
  - specs/framework/project-scaffold.concept
  - specs/framework/dev-server.concept
  - specs/framework/cache-compiler.concept
  - specs/framework/kit-manager.concept
  # Generation kit concepts
  - kits/generation/emitter.concept
  - kits/generation/build-cache.concept
  - kits/generation/resource.concept
  - kits/generation/kind-system.concept
  - kits/generation/generation-plan.concept
  # Deploy kit build concepts
  - kits/deploy/concepts/builder.concept
  - kits/deploy/concepts/toolchain.concept
  # Scaffold generator concepts
  - specs/framework/kit-scaffold-gen.concept
  - specs/framework/deploy-scaffold-gen.concept
  - specs/framework/interface-scaffold-gen.concept
  - specs/framework/concept-scaffold-gen.concept
  - specs/framework/sync-scaffold-gen.concept
  - specs/framework/handler-scaffold-gen.concept
  - specs/framework/storage-adapter-scaffold-gen.concept
  - specs/framework/transport-adapter-scaffold-gen.concept
  - specs/framework/coif-component-scaffold-gen.concept
  - specs/framework/coif-theme-scaffold-gen.concept

# ─── OUTPUT CONFIGURATION ────────────────────────────
output:
  dir: ./generated/devtools
  formatting:
    typescript: prettier
  clean: true

# ─── WORKFLOWS ───────────────────────────────────────
# Define ordered, annotated workflows for skill targets.
# Each workflow maps a concept to a step-by-step guide.

workflows:

  # ─── SpecParser: concept-validator ─────────────────
  concept-validator:
    concept: SpecParser
    steps:
      - action: parse
        title: "Parse and Validate"
        prose: "Parse all .concept specs in the project and report syntax or structural errors."
    checklists:
      parse:
        - "Has purpose block?"
        - "Actions have at least one variant?"
        - "Invariants reference valid actions?"
        - "Type parameters declared and used?"
    design-principles:
      - title: "Spec as Source of Truth"
        rule: "The .concept file is the single authoritative definition — all generated code, tests, and documentation derive from it."
      - title: "Fail Fast on Ambiguity"
        rule: "Parser rejects specs with ambiguous state relations or incomplete action signatures rather than guessing intent."
    references:
      - path: references/concept-grammar.md
        label: "Concept grammar reference"
        tier: reference
        content: |
          # Concept Grammar Reference

          Complete grammar for `.concept` specification files.

          ## Top-Level Structure

          ```
          concept Name [TypeParam, ...] {
            purpose { ... }
            state { ... }
            actions { ... }
            invariants { ... }
          }
          ```

          ## Purpose Block

          ```
          purpose { Free-text description in imperative present tense. }
          ```

          One to three sentences. No implementation details.

          ## State Block

          ```
          state {
            items: set T            # Primary collection
            name: T -> String       # Total function (every T has one)
            email: T -> option String  # Partial (may be absent)
            tags: T -> list String  # Multi-valued
          }
          ```

          **Relation types:**
          | Syntax | Meaning | TypeScript |
          |--------|---------|-----------|
          | `set T` | Collection of T | `Map<id, T>` |
          | `T -> V` | Total function | Required field |
          | `T -> option V` | Partial function | Optional field |
          | `T -> list V` | Multi-valued | Array field |

          ## Actions Block

          ```
          actions {
            action create(name: String, email: String) {
              -> ok(item: T) { Created successfully. }
              -> duplicate(name: String) { Name already taken. }
            }
          }
          ```

          - Each action has a name, typed parameters, and one or more **variants**.
          - Variants use `->` arrow syntax: `-> variantName(bindings) { prose }`.
          - At least one variant is required per action.

          **Parameter types:** `String`, `Int`, `Bool`, `T` (type param), `list T`, `option T`.

          ## Invariants Block

          ```
          invariants {
            after create(name) -> ok(item) {
              then { item in items; name(item) = name }
            }
            after delete(item) -> ok {
              then { item not in items }
            }
          }
          ```

          - `after action -> variant { then { assertions } }` — post-condition.
          - Assertions: `field(item) = value`, `item in collection`, `item not in collection`.

          ## Type Parameters

          Declared in brackets after concept name: `concept Name [T, U]`.
          Used throughout state and action signatures. Resolved by syncs at composition time.
      - path: references/jackson-methodology.md
        label: "Jackson's concept design methodology"
        tier: reference
        content: |
          # Jackson's Concept Design Methodology

          Summary of Daniel Jackson's software concept design methodology
          as applied in COPF.

          ## Five Core Principles

          ### 1. Singularity
          Each concept serves exactly one purpose. If the purpose statement
          contains "and", it should be split into separate concepts.

          ### 2. Independence
          A concept never references another concept directly — no imports,
          no shared types, no cross-concept calls. Concepts communicate only
          through type parameters and syncs.

          ### 3. Sufficiency
          The concept's state and actions are sufficient to fulfill its purpose.
          Every use case implied by the purpose can be served by the declared actions.

          ### 4. Necessity
          Every piece of state is needed by at least one action. Every action
          serves the concept's purpose. No dead state or unused actions.

          ### 5. Invariant Completeness
          Key properties of the concept are captured as formal invariants.
          Invariants document what must always be true after each action completes.

          ## Design Workflow

          1. **Articulate purpose** — Write 1-3 sentences describing what the
             concept is for, not how it works.
          2. **Design state** — Start with the primary collection (`items: set T`),
             then add relations that serve the actions.
          3. **Design actions** — Define verbs with typed parameters and return
             variants. Each variant represents a distinct outcome.
          4. **Write invariants** — For each action+variant, state what must be
             true afterward. This catches design gaps early.
          5. **Validate** — Run `copf check` to verify syntax, completeness, and
             consistency.

          ## Common Concept Patterns

          | Pattern | State Shape | Example |
          |---------|-------------|---------|
          | Entity CRUD | `items: set T; fields: T -> Type` | User, Article |
          | Relationship | `links: set L; from: L -> A; to: L -> B` | Friendship, Membership |
          | Workflow | `items: set T; status: T -> Status` | Order, Approval |
          | Guard | `(no primary state)` | Password, RateLimit |
    validation-commands:
      - label: "Parse and validate all concept specs"
        command: "npx tsx tools/copf-cli/src/index.ts check"
      - label: "Run parser tests"
        command: "npx vitest run tests/spec-parser.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | parse | `copf check <file>` | Validate concept spec syntax and structure |
    related-workflows:
      - name: concept-designer
        description: "Design new concepts following Jackson's methodology"
      - name: implementation-builder
        description: "Write handlers that implement concept actions"
      - name: sync-designer
        description: "Write syncs that connect concepts together"
    anti-patterns:
      - title: "Missing purpose block"
        description: "Concept spec has no purpose — impossible to evaluate design quality."
        bad: |
          concept User [U] {
            state { users: set U; name: U -> String }
            actions { action create(name: String) { -> ok(user: U) { Created. } } }
          }
        good: |
          concept User [U] {
            purpose { Manage user identity and profile information. }
            state { users: set U; name: U -> String }
            actions { action create(name: String) { -> ok(user: U) { Created. } } }
          }
      - title: "Untyped action parameters"
        description: "Action parameters lack types — generated code will use 'any'."
        bad: |
          action create(name, email) { -> ok(user: U) { Created. } }
        good: |
          action create(name: String, email: String) { -> ok(user: U) { Created. } }

  # ─── SpecParser: concept-designer ──────────────────
  concept-designer:
    concept: SpecParser
    steps:
      - action: parse
        title: "Articulate the Purpose"
        prose: "The purpose answers: What is this concept for? Write 1-3 sentences in imperative present tense."
    checklists:
      parse:
        - "Single purpose — no 'and also'?"
        - "Describes why, not what?"
        - "A user would understand it without seeing the implementation?"
    design-principles:
      - title: "Singularity"
        rule: "Each concept serves exactly one purpose — if the purpose has 'and', it's two concepts."
      - title: "Independence"
        rule: "A concept never references another concept's types or calls another concept's actions directly — use type parameters and syncs."
      - title: "Sufficiency & Necessity"
        rule: "Every state field is needed by at least one action, and every action can be served from the declared state."
    references:
      - path: references/jackson-methodology.md
        label: "Jackson's full methodology"
        tier: reference
        content: |
          # Jackson's Concept Design Methodology

          Summary of Daniel Jackson's software concept design methodology
          as applied in COPF.

          ## Five Core Principles

          ### 1. Singularity
          Each concept serves exactly one purpose. If the purpose statement
          contains "and", it should be split into separate concepts.

          ### 2. Independence
          A concept never references another concept directly — no imports,
          no shared types, no cross-concept calls. Concepts communicate only
          through type parameters and syncs.

          ### 3. Sufficiency
          The concept's state and actions are sufficient to fulfill its purpose.
          Every use case implied by the purpose can be served by the declared actions.

          ### 4. Necessity
          Every piece of state is needed by at least one action. Every action
          serves the concept's purpose. No dead state or unused actions.

          ### 5. Invariant Completeness
          Key properties of the concept are captured as formal invariants.
          Invariants document what must always be true after each action completes.

          ## Design Workflow

          1. **Articulate purpose** — Write 1-3 sentences describing what the
             concept is for, not how it works.
          2. **Design state** — Start with the primary collection (`items: set T`),
             then add relations that serve the actions.
          3. **Design actions** — Define verbs with typed parameters and return
             variants. Each variant represents a distinct outcome.
          4. **Write invariants** — For each action+variant, state what must be
             true afterward. This catches design gaps early.
          5. **Validate** — Run `copf check` to verify syntax, completeness, and
             consistency.

          ## Common Concept Patterns

          | Pattern | State Shape | Example |
          |---------|-------------|---------|
          | Entity CRUD | `items: set T; fields: T -> Type` | User, Article |
          | Relationship | `links: set L; from: L -> A; to: L -> B` | Friendship, Membership |
          | Workflow | `items: set T; status: T -> Status` | Order, Approval |
          | Guard | `(no primary state)` | Password, RateLimit |
      - path: references/concept-catalog.md
        label: "Reusable concept catalog"
        tier: reference
        content: |
          # Reusable Concept Catalog

          Common concepts that appear across applications. Use as starting
          points — adapt state and actions to your specific purpose.

          ## Identity & Access

          | Concept | Purpose | Key Actions |
          |---------|---------|-------------|
          | User | Manage user identity | create, update, delete, find |
          | Password | Verify credentials | set, check, reset |
          | Session | Track authenticated sessions | start, end, validate |
          | Role | Assign permissions to users | grant, revoke, check |

          ## Content

          | Concept | Purpose | Key Actions |
          |---------|---------|-------------|
          | Article | Manage authored content | create, publish, archive |
          | Tag | Categorize items with labels | add, remove, find |
          | Comment | Attach discussion to items | post, edit, delete |

          ## Commerce

          | Concept | Purpose | Key Actions |
          |---------|---------|-------------|
          | Cart | Collect items for purchase | add, remove, clear |
          | Order | Track purchase lifecycle | place, fulfill, cancel |
          | Payment | Process financial transactions | charge, refund |
          | Invoice | Record financial obligations | issue, pay, void |

          ## Communication

          | Concept | Purpose | Key Actions |
          |---------|---------|-------------|
          | Email | Send transactional messages | send, schedule, cancel |
          | Notification | Alert users of events | create, read, dismiss |

          ## Composition Notes

          These concepts are designed to be independent. Wire them together
          using syncs:

          ```
          sync WelcomeEmail [eager] {
            when { User/create => ok[user: ?u] }
            where { User: { ?u email: ?email } }
            then { Email/send[to: ?email, template: "welcome"] }
          }
          ```
    anti-patterns:
      - title: "Kitchen-sink concept"
        description: "Concept has multiple unrelated purposes — split into separate concepts."
        bad: |
          concept UserAuth [U] {
            purpose { Manage users AND authenticate them. }
          }
        good: |
          concept User [U] { purpose { Manage user identity. } }
          concept Password [U] { purpose { Verify credentials for a user. } }
      - title: "Leaky independence"
        description: "Concept references another concept's types or calls another concept's actions — use type parameters instead."
        bad: |
          concept Order [O] {
            state { customer: O -> User }
          }
        good: |
          concept Order [O, U] {
            state { customer: O -> U }
          }
    validation-commands:
      - label: "Validate the new concept spec"
        command: "npx tsx tools/copf-cli/src/index.ts check"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Section | What to Write | Key Question |
        |---------|---------------|--------------|
        | purpose | 1-3 sentences | What is this concept for? |
        | state | Relations on type params | What does the concept remember? |
        | actions | Verbs with variants | What can users do? |
        | invariants | after/then assertions | What must always be true? |
    related-workflows:
      - name: concept-validator
        description: "Parse and validate concept specs for syntax errors"
      - name: sync-designer
        description: "Write syncs that connect concepts together"
      - name: implementation-builder
        description: "Write TypeScript handlers for concept actions"
    content-sections:
      - heading: "State Design Principles"
        body: |
          State is what the concept remembers. Start from the purpose — every
          piece of state must serve at least one action. Use the primary
          collection pattern (`items: set T`) and derive everything else as
          relations on T. Avoid storing derived data that can be computed.
        afterStep: 1

  # ─── SyncCompiler: sync-designer ───────────────────
  sync-designer:
    concept: SyncCompiler
    steps:
      - action: compile
        title: "Compile Sync Rules"
        prose: "Compile .sync files that wire concepts together through pattern matching on completions."
    checklists:
      compile:
        - "Sync references valid concept actions?"
        - "Variable bindings are consistent across when/where/then?"
        - "Where-clause queries are well-formed?"
        - "Sync mode (eager vs eventual) matches intent?"
    design-principles:
      - title: "Completion Chaining"
        rule: "Syncs compose through completions, never by referencing other syncs — each sync reacts to what happened, not who caused it."
      - title: "Concept Independence"
        rule: "Syncs wire concepts together without the concepts knowing about each other — concepts never import or reference each other."
      - title: "Pattern Exhaustiveness"
        rule: "Every when-clause variant that a sync matches should be explicitly listed — don't rely on fallthrough behavior."
    references:
      - path: references/sync-design.md
        label: "Sync language and patterns"
        tier: reference
        content: |
          # Sync Language Reference

          Syncs wire concepts together by reacting to completions. A sync
          never calls another sync — it only sees concept action completions.

          ## Sync Declaration

          ```
          sync Name [mode] {
            when { ... }
            where { ... }    # optional
            filter(...)      # optional
            then { ... }
          }
          ```

          **Modes:**
          - `eager` — Executes synchronously within the same transaction.
            Use for data consistency (e.g., creating related records).
          - `eventual` — Queued for async execution. Use for side effects
            (e.g., sending emails, updating caches).

          ## When Clause

          Pattern matches on a concept action completion:

          ```
          when { Concept/action => variant[binding: ?var, ...] }
          ```

          - `Concept/action` — The concept and action to watch.
          - `=> variant` — Which return variant to match.
          - `[binding: ?var]` — Extract values from the completion into variables.

          ## Where Clause

          Queries concept state to bind additional variables:

          ```
          where { Concept: { ?item field: ?value } }
          ```

          - `?item` — Binds to items in the concept's primary collection.
          - `field: ?value` — Binds the field value to a variable.

          ## Filter Clause

          Guards execution with a boolean condition:

          ```
          filter(?count > 0)
          filter(?status = "active")
          ```

          ## Then Clause

          Invokes a target concept action with bound variables:

          ```
          then { Concept/action[param: ?var, ...] }
          ```

          All variables in then must be bound in when or where.

          ## Variable Binding Rules

          1. Variables start with `?` — e.g., `?user`, `?email`.
          2. A variable must be bound (in when or where) before use in then.
          3. Variables are scoped to a single sync — no cross-sync sharing.
      - path: references/sync-patterns.md
        label: "Reusable sync templates"
        tier: reference
        content: |
          # Reusable Sync Patterns

          Common sync patterns for wiring concepts together.

          ## CRUD Chain

          When one entity is created, create related records:

          ```
          sync CreateProfile [eager] {
            when { User/create => ok[user: ?u] }
            then { Profile/create[owner: ?u] }
          }
          ```

          ## Auth-Gated Action

          Validate authentication before allowing an action:

          ```
          sync AuthGate [eager] {
            when { Session/validate => ok[token: ?t] }
            where { Session: { ?t userId: ?uid } }
            then { Article/create[author: ?uid] }
          }
          ```

          ## Notification on Event

          Send async notification when something happens:

          ```
          sync NotifyOnOrder [eventual] {
            when { Order/place => ok[order: ?o] }
            where { Order: { ?o customer: ?c } }
            where { User: { ?c email: ?email } }
            then { Email/send[to: ?email, template: "order-placed"] }
          }
          ```

          ## Cache Invalidation

          Invalidate cache when source data changes:

          ```
          sync InvalidateUserCache [eager] {
            when { User/update => ok[user: ?u] }
            then { Cache/invalidate[key: ?u, namespace: "user"] }
          }
          ```

          ## Cascade Delete

          Clean up related data when a parent is deleted:

          ```
          sync CascadeDelete [eager] {
            when { User/delete => ok[user: ?u] }
            then { Profile/deleteByOwner[owner: ?u] }
          }
          ```

          ## Guarded Sync

          Only fire when a condition is met:

          ```
          sync HighValueOrder [eventual] {
            when { Order/place => ok[order: ?o] }
            where { Order: { ?o total: ?amount } }
            filter(?amount > 1000)
            then { Alert/create[type: "high-value", ref: ?o] }
          }
          ```
    anti-patterns:
      - title: "Sync referencing sync"
        description: "One sync tries to trigger another sync directly instead of reacting to a completion."
        bad: |
          sync BadChain [eager] {
            when { MySyncA/complete => ok }
            then { ConceptB/doThing }
          }
        good: |
          sync GoodChain [eager] {
            when { ConceptA/create => ok[item: ?x] }
            then { ConceptB/process[item: ?x] }
          }
      - title: "Overly broad pattern match"
        description: "Sync matches all variants of an action instead of the specific one it needs."
        bad: |
          sync TooWide [eager] {
            when { User/register => [user: ?u] }
            then { Email/send[to: ?u] }
          }
        good: |
          sync Precise [eager] {
            when { User/register => ok[user: ?u] }
            then { Email/send[to: ?u] }
          }
    validation-commands:
      - label: "Compile all sync rules"
        command: "npx tsx tools/copf-cli/src/index.ts compile-syncs"
      - label: "Run sync compiler tests"
        command: "npx vitest run tests/sync-compiler.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Clause | Purpose | Example |
        |--------|---------|---------|
        | when | Pattern match on completion | `ConceptA/action => ok[field: ?var]` |
        | where | Query concept state | `ConceptB: { ?item state.field: ?val }` |
        | then | Invoke target action | `ConceptC/action[param: ?var]` |
        | filter | Guard condition | `filter(?val > 0)` |
    related-workflows:
      - name: concept-designer
        description: "Design concepts that syncs connect"
      - name: implementation-builder
        description: "Write handlers for concept actions"
      - name: concept-validator
        description: "Validate concept specs before writing syncs"
    content-sections:
      - heading: "Completion Chaining Pattern"
        body: |
          Syncs compose through completions, not references. A typical
          authenticated CRUD flow chains like this:

          1. `User/login => ok[session: ?s]`
          2. → `Auth/validate[session: ?s] => ok[token: ?t]`
          3. → `Article/create[author: ?t] => ok[article: ?a]`

          Each sync sees only the completion it reacts to — no sync
          knows about the others in the chain.
        afterStep: 1

  # ─── SchemaGen: implementation-builder ─────────────
  implementation-builder:
    concept: SchemaGen
    steps:
      - action: generate
        title: "Generate Schema from Spec"
        prose: "Generate ConceptManifest from parsed AST. The manifest provides typed action signatures for implementation."
    checklists:
      generate:
        - "All action parameters have types?"
        - "Return variants match spec declarations?"
        - "State relations are correctly grouped?"
        - "Type parameters are resolved?"
    design-principles:
      - title: "One Handler per Action"
        rule: "Each action in the concept spec maps to exactly one async method in the implementation handler."
      - title: "Variant Completeness"
        rule: "Every return variant declared in the spec must have a corresponding code path in the handler — no missing branches."
      - title: "Storage Sovereignty"
        rule: "Each concept owns its storage exclusively — no shared databases, no cross-concept state access."
    references:
      - path: references/implementation-patterns.md
        label: "Implementation patterns and storage"
        tier: reference
        content: |
          # Implementation Patterns

          Patterns for writing concept handler implementations.

          ## Handler Structure

          Each concept gets one handler file. Each action maps to one async method:

          ```typescript
          export const userHandler: ConceptHandler<UserState> = {
            async create(input, storage) {
              const id = generateId();
              await storage.set(id, { name: input.name, email: input.email });
              return { variant: 'ok', user: id };
            },

            async delete(input, storage) {
              const exists = await storage.has(input.user);
              if (!exists) return { variant: 'notFound', user: input.user };
              await storage.delete(input.user);
              return { variant: 'ok' };
            },
          };
          ```

          ## Storage Patterns

          **Key-value storage** — Every concept gets isolated key-value storage:
          - `storage.get(key)` — Read a record
          - `storage.set(key, value)` — Write a record
          - `storage.has(key)` — Check existence
          - `storage.delete(key)` — Remove a record
          - `storage.list()` — List all keys

          **Storage sovereignty** — A concept only accesses its own storage.
          Never import or reference another concept's storage.

          ## Return Variants

          Every code path must return one of the declared variants:

          ```typescript
          // Spec declares: -> ok(item: T), -> duplicate(name: String)
          async create(input, storage) {
            const existing = await findByName(input.name, storage);
            if (existing) {
              return { variant: 'duplicate', name: input.name };
            }
            // ... create logic
            return { variant: 'ok', item: id };
          }
          ```

          **Rules:**
          - Every variant from the spec must have a code path.
          - Return object must include `variant` field plus declared bindings.
          - No undeclared variants — the runtime rejects unknown variants.

          ## Error Handling

          - Use variants for expected outcomes (not found, duplicate, invalid).
          - Throw exceptions only for unexpected failures (storage errors, bugs).
          - The runtime wraps thrown exceptions as `error` completions automatically.
      - path: references/type-mapping.md
        label: "Spec-to-TypeScript type mapping rules"
        tier: reference
        content: |
          # Spec-to-TypeScript Type Mapping

          Rules for mapping concept spec types to TypeScript types in
          generated manifests and handler interfaces.

          ## Primitive Types

          | Spec Type | TypeScript Type | Notes |
          |-----------|----------------|-------|
          | `String` | `string` | |
          | `Int` | `number` | Integer values |
          | `Bool` | `boolean` | |
          | `Float` | `number` | Floating point |

          ## Collection Types

          | Spec Type | TypeScript Type | Notes |
          |-----------|----------------|-------|
          | `set T` | `Map<string, T>` | Primary collection keyed by ID |
          | `list T` | `T[]` | Ordered array |
          | `option T` | `T \| undefined` | Nullable/optional |

          ## Relation Types

          | Spec Syntax | TypeScript Type | Meaning |
          |-------------|----------------|---------|
          | `T -> String` | `string` (required field) | Total function |
          | `T -> option String` | `string \| undefined` | Partial function |
          | `T -> list String` | `string[]` | Multi-valued |
          | `T -> set U` | `Set<U>` | Set-valued |

          ## Type Parameters

          Type parameters (`[T, U]`) become generic type arguments.
          In generated code, they resolve to `string` (ID references)
          unless a concrete type is provided by the sync wiring.

          ## Action Signatures

          ```
          // Spec:
          action create(name: String, count: Int) {
            -> ok(item: T) { ... }
          }

          // Generated TypeScript:
          create(input: { name: string; count: number }, storage: Storage)
            : Promise<{ variant: 'ok'; item: string } | ...>
          ```
    validation-commands:
      - label: "Generate manifests from specs"
        command: "npx tsx tools/copf-cli/src/index.ts generate"
      - label: "Run schema generation tests"
        command: "npx vitest run tests/schema-gen.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Spec Type | TypeScript Type | Notes |
        |-----------|----------------|-------|
        | String | string | Direct mapping |
        | Int | number | Direct mapping |
        | Bool | boolean | Direct mapping |
        | list T | T[] | Array mapping |
        | option T | T \| undefined | Optional mapping |
        | set T | Set<T> or Map | Primary collection |
    related-workflows:
      - name: concept-designer
        description: "Design concepts before implementing them"
      - name: concept-validator
        description: "Validate specs before generating schemas"
      - name: sync-designer
        description: "Wire implemented concepts together with syncs"
    anti-patterns:
      - title: "Cross-concept storage access"
        description: "Handler reads or writes another concept's storage — violates sovereignty."
        bad: |
          async create(input, storage) {
            const user = await userStorage.get(input.userId); // Wrong!
            // ...
          }
        good: |
          async create(input, storage) {
            // userId is passed in — concept doesn't know where it came from
            const item = { id: generateId(), owner: input.userId };
            await storage.set(item.id, item);
            return { variant: 'ok', item: item.id };
          }

  # ─── SyncParser: sync-validator ────────────────────
  sync-validator:
    concept: SyncParser
    steps:
      - action: parse
        title: "Parse and Validate Sync Files"
        prose: "Parse .sync files into structured ASTs and validate variable bindings, concept references, and action signatures against loaded manifests."
    checklists:
      parse:
        - "Sync file has valid when/then structure?"
        - "All concept references resolve to loaded manifests?"
        - "Variable bindings are consistent across clauses?"
        - "Action parameters match concept action signatures?"
        - "Sync mode (eager/eventual) is declared?"
    design-principles:
      - title: "Manifest-Aware Validation"
        rule: "Sync validation cross-references concept manifests to verify that referenced actions and parameters actually exist."
      - title: "Early Error Detection"
        rule: "Catch variable binding mismatches and type errors at parse time, not at runtime when the sync fires."
    references:
      - path: references/sync-design.md
        label: "Sync language reference"
        tier: reference
        content: |
          # Sync Language Reference

          Syncs wire concepts together by reacting to completions. A sync
          never calls another sync — it only sees concept action completions.

          ## Sync Declaration

          ```
          sync Name [mode] {
            when { ... }
            where { ... }    # optional
            filter(...)      # optional
            then { ... }
          }
          ```

          **Modes:**
          - `eager` — Synchronous, same transaction. Use for data consistency.
          - `eventual` — Queued async. Use for side effects.

          ## When Clause

          ```
          when { Concept/action => variant[binding: ?var, ...] }
          ```

          ## Where Clause

          ```
          where { Concept: { ?item field: ?value } }
          ```

          ## Filter Clause

          ```
          filter(?count > 0)
          ```

          ## Then Clause

          ```
          then { Concept/action[param: ?var, ...] }
          ```

          ## Variable Binding Rules

          1. Variables start with `?`.
          2. Must be bound in when or where before use in then.
          3. Scoped to a single sync.
      - path: references/sync-patterns.md
        label: "Common sync patterns and templates"
        tier: reference
        content: |
          # Common Sync Patterns

          ## CRUD Chain
          ```
          sync CreateProfile [eager] {
            when { User/create => ok[user: ?u] }
            then { Profile/create[owner: ?u] }
          }
          ```

          ## Notification
          ```
          sync NotifyOnOrder [eventual] {
            when { Order/place => ok[order: ?o] }
            where { Order: { ?o customer: ?c } }
            where { User: { ?c email: ?email } }
            then { Email/send[to: ?email, template: "order-placed"] }
          }
          ```

          ## Cache Invalidation
          ```
          sync InvalidateCache [eager] {
            when { User/update => ok[user: ?u] }
            then { Cache/invalidate[key: ?u, namespace: "user"] }
          }
          ```

          ## Guarded Sync
          ```
          sync HighValue [eventual] {
            when { Order/place => ok[order: ?o] }
            where { Order: { ?o total: ?amount } }
            filter(?amount > 1000)
            then { Alert/create[type: "high-value", ref: ?o] }
          }
          ```
    validation-commands:
      - label: "Parse all sync files"
        command: "npx tsx tools/copf-cli/src/index.ts compile-syncs"
      - label: "Run sync parser tests"
        command: "npx vitest run tests/sync-parser.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Element | Syntax | Purpose |
        |---------|--------|---------|
        | Sync declaration | `sync Name [mode] { ... }` | Define a synchronization rule |
        | When clause | `Concept/action => variant[bindings]` | Pattern match on completion |
        | Where clause | `Concept: { ?item field: ?val }` | Query concept state |
        | Then clause | `Concept/action[params]` | Invoke target action |
    related-workflows:
      - name: sync-designer
        description: "Compile validated sync rules into executables"
      - name: concept-validator
        description: "Validate concept specs referenced by syncs"
    anti-patterns:
      - title: "Unbound variable in then-clause"
        description: "Then-clause uses a variable not bound in when or where — will fail at runtime."
        bad: |
          sync Broken [eager] {
            when { User/create => ok[user: ?u] }
            then { Email/send[to: ?email] }
          }
        good: |
          sync Working [eager] {
            when { User/create => ok[user: ?u] }
            where { User: { ?u email: ?email } }
            then { Email/send[to: ?email] }
          }

  # ─── FlowTrace: trace-debugger ────────────────────
  trace-debugger:
    concept: FlowTrace
    steps:
      - action: build
        title: "Build Execution Trace"
        prose: "Build a trace from a flow ID showing which concepts were invoked, what syncs fired, and data flow between them."
      - action: render
        title: "Render Trace Output"
        prose: "Render the trace tree as a human-readable output with timing, success/failure status, and data flow arrows."
    checklists:
      build:
        - "Flow ID exists in action log?"
        - "All causal links followed (action → sync → action)?"
        - "Timing data captured for each node?"
      render:
        - "Tree indentation correct?"
        - "Failed nodes highlighted?"
        - "Data flow arrows show variable propagation?"
    design-principles:
      - title: "Causal Completeness"
        rule: "The trace shows the complete causal chain — every action that fired because of the initial trigger, not just the immediate effects."
      - title: "Non-Intrusive"
        rule: "Tracing reads the action log — it never modifies runtime behavior or adds overhead to normal execution."
    references:
      - path: references/debugging.md
        label: "Debugging with FlowTrace"
        tier: reference
        content: |
          # Debugging with FlowTrace

          FlowTrace builds causal execution trees from the action log,
          showing every concept action and sync firing triggered by
          an initial action.

          ## Reading a Trace

          ```
          Flow abc-123
          ├─ User/create => ok [user: u1]        2ms
          │  ├─ [sync: CreateProfile] eager
          │  │  └─ Profile/create => ok [profile: p1]  1ms
          │  └─ [sync: WelcomeEmail] eventual
          │     └─ Email/send => ok               45ms
          └─ total: 48ms
          ```

          **Reading the tree:**
          - Root node is the initial action.
          - Indented children are syncs that fired from the parent.
          - `[sync: Name]` shows which sync rule triggered the action.
          - Timing shows per-node and total duration.

          ## Common Debugging Scenarios

          ### Sync didn't fire
          1. Check the when-clause variant matches the actual completion.
          2. Verify variable bindings — a misspelled binding silently fails.
          3. Check sync mode — eventual syncs execute asynchronously.

          ### Unexpected cascade
          1. Look for broad pattern matches (missing variant name).
          2. Check if multiple syncs react to the same completion.
          3. Look for circular chains: A→B→C→A.

          ### Slow execution
          1. Look for deep nesting (long sync chains).
          2. Check eventual syncs for slow external calls.
          3. Look for N+1 patterns in where-clause queries.

          ## Trace Commands

          | Command | Purpose |
          |---------|---------|
          | `copf trace <flow-id>` | Build and display a trace |
          | `copf trace <flow-id> --json` | Output trace as JSON |
          | `copf trace --recent` | Show last 10 flow traces |
    validation-commands:
      - label: "Build a trace"
        command: "npx tsx tools/copf-cli/src/index.ts trace <flow-id>"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | build | `copf trace <flow-id>` | Build trace from a flow ID |
        | render | (automatic) | Render trace as tree output |
    related-workflows:
      - name: sync-designer
        description: "Design the syncs whose execution traces debug"
      - name: concept-validator
        description: "Validate specs before debugging runtime issues"
      - name: dev-workflow
        description: "Run the dev server to generate flow IDs for tracing"

  # ─── Builder: build-orchestration ─────────────────
  build-orchestration:
    concept: Builder
    steps:
      - action: build
        title: "Build Concept"
        prose: "Compile, test, and package a concept implementation for a language and platform. Routes to language-specific providers."
      - action: buildAll
        title: "Build All Targets"
        prose: "Build multiple concepts across multiple target languages and platforms in parallel."
      - action: test
        title: "Run Tests"
        prose: "Run tests only for a previously built concept — no recompilation."
      - action: status
        title: "Build Status"
        prose: "Check the current status of a build: pending, compiling, testing, packaging, done, or failed."
      - action: history
        title: "Build History"
        prose: "Show build history for a concept, optionally filtered by language."
    checklists:
      build:
        - "Toolchain resolved for language+platform?"
        - "Source directory exists and is non-empty?"
        - "Config mode is valid (debug/release/skip-tests)?"
        - "Artifact hash is content-addressed?"
      buildAll:
        - "All target languages have resolved toolchains?"
        - "Independent targets build in parallel?"
        - "Partial results reported if some builds fail?"
      test:
        - "Build artifact exists for this concept+language?"
        - "Test runner detected for language?"
      status:
        - "Build reference is valid?"
      history:
        - "Language filter is valid (if provided)?"
    design-principles:
      - title: "Coordination, Not Compilation"
        rule: "Builder coordinates — it never compiles directly. Language-specific provider concepts own compilation logic."
      - title: "Content-Addressed Artifacts"
        rule: "Build outputs are stored in Artifact with content-addressed hashes. Same inputs always produce same artifact."
      - title: "Executor Transparency"
        rule: "Builder doesn't know whether builds run locally, remotely, or in containers. Execution strategy is a provider-internal concern."
    references:
      - path: references/build-pipeline.md
        label: "Build pipeline architecture"
        tier: reference
        content: |
          # Build Pipeline Architecture

          The build layer bridges generated source and deployable artifacts.

          ## Pipeline Flow

          1. DeployPlan/execute — triggers build phase
          2. Toolchain/resolve — find compiler for language+platform
          3. Builder/build — compile, test, package (routed to provider)
          4. Artifact/store — content-addressed artifact storage
          5. Runtime/deploy — deploy the stored artifact

          ## Execution Strategies

          Builder providers support three executor types configured in
          the deploy manifest:

          | Type | Description |
          |------|-------------|
          | `local` | Invoke compiler directly on host |
          | `remote` | Send source to remote build service |
          | `container` | Run build in Docker container |

          ## Deploy Manifest Build Section

          ```yaml
          build:
            targets:
              - language: swift
                platform: linux-arm64
                mode: release
                config:
                  version: ">=5.10"
                  package-format: framework

            executor:
              swift:
                type: remote
                endpoint: https://build.internal/swift
          ```

          ## DAG Integration

          Build nodes insert before deploy nodes in the DAG:

          ```
          resolve-toolchain → build-concept → store-artifact → deploy-concept
          ```

          Independent language targets build in parallel. Toolchain
          resolution happens once per language, shared across concepts.
    validation-commands:
      - label: "Build all targets"
        command: "copf build ./app.deploy.yaml"
      - label: "Build specific language"
        command: "copf build ./app.deploy.yaml --language swift"
      - label: "Dry run (show build plan)"
        command: "copf build ./app.deploy.yaml --plan"
      - label: "Run tests only"
        command: "copf build test --concept password --language swift"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | build | `copf build` | Compile, test, package one concept |
        | buildAll | `copf build` (all targets) | Build all concepts for all targets |
        | test | `copf build test` | Run tests only (no compile) |
        | status | `copf build status` | Check build status |
        | history | `copf build history` | Show build history |
    related-workflows:
      - name: toolchain-management
        description: "Resolve toolchains before building"
      - name: deployment-config
        description: "Deploy built artifacts"
    anti-patterns:
      - title: "Building without toolchain resolution"
        description: "Calling Builder/build before Toolchain/resolve — compilation will fail."
        bad: |
          # Skip toolchain resolution
          Builder/build(concept: "password", language: "swift", ...)
        good: |
          # Resolve first, then build
          Toolchain/resolve(language: "swift", platform: "linux-arm64")
          # -> ok(tool, version, path)
          Builder/build(concept: "password", language: "swift", ...)
      - title: "Monolithic build action"
        description: "Putting compilation, testing, and packaging logic in Builder instead of provider concepts."
        bad: |
          # Builder implementation knows about swiftc flags
          if (language === "swift") { exec("swiftc -c release ..."); }
        good: |
          # Builder routes to SwiftBuilder which owns swift-specific logic
          SwiftBuilder/build(source, toolchainPath, platform, config)

  # ─── Toolchain: toolchain-management ────────────────
  toolchain-management:
    concept: Toolchain
    steps:
      - action: resolve
        title: "Resolve Toolchain"
        prose: "Find and validate a compiler toolchain for a language and platform. Routes to language-specific providers."
      - action: validate
        title: "Validate Toolchain"
        prose: "Verify a previously resolved toolchain is still valid — tool exists at path, version matches."
      - action: list
        title: "List Toolchains"
        prose: "List all resolved toolchains, optionally filtered by language."
      - action: capabilities
        title: "Show Capabilities"
        prose: "Return detailed capabilities for a resolved tool."
    checklists:
      resolve:
        - "Language is supported (swift/typescript/rust/solidity)?"
        - "Platform identifier is valid?"
        - "Version constraint parseable?"
        - "Provider registered for this language?"
      validate:
        - "Tool reference is valid?"
        - "Tool still exists at recorded path?"
        - "Version hasn't changed since resolution?"
      list:
        - "Language filter is valid (if provided)?"
      capabilities:
        - "Tool reference is valid?"
    design-principles:
      - title: "Resolution Caching"
        rule: "Resolve once per language+platform, reuse across all concept builds. Toolchain resolution is shared."
      - title: "Drift Detection"
        rule: "Validate before build to catch environment drift — tools may be uninstalled, upgraded, or moved between resolves."
      - title: "Provider Routing"
        rule: "Toolchain never knows about swiftc, tsc, or rustc — it routes to SwiftToolchain, TypeScriptToolchain, etc."
    references:
      - path: references/toolchain-resolution.md
        label: "Toolchain resolution and validation"
        tier: reference
        content: |
          # Toolchain Resolution

          Toolchain resolves compilers for the build layer.

          ## Resolution Flow

          1. Toolchain/resolve(language, platform, versionConstraint)
          2. → Routes to language provider (SwiftToolchain, etc.)
          3. Provider checks PATH, validates version, detects capabilities
          4. Returns: tool ref, version, path, capability list

          ## Capabilities

          Capabilities describe what a resolved tool supports:

          | Language | Example Capabilities |
          |----------|---------------------|
          | Swift | macros, swift-testing, typed-throws, cross-compile |
          | TypeScript | esm, cjs, declaration-maps, composite-projects |
          | Rust | wasm-target, proc-macros, incremental |
          | Solidity | optimizer, via-ir, foundry-tests, hardhat-tests |

          ## Validation

          `validate(tool)` re-checks a previously resolved tool:
          - File exists at recorded path
          - Version matches what was resolved
          - Not corrupted or partially uninstalled

          Used before builds to catch environment drift without
          full re-resolution.

          ## Commands

          | Command | Purpose |
          |---------|---------|
          | `copf toolchain list` | Show all resolved toolchains |
          | `copf toolchain resolve swift` | Resolve Swift toolchain |
          | `copf toolchain validate` | Re-validate all toolchains |
    validation-commands:
      - label: "List resolved toolchains"
        command: "copf toolchain list"
      - label: "Resolve a specific toolchain"
        command: "copf toolchain resolve swift --platform linux-arm64 --version '>=5.10'"
      - label: "Validate all toolchains"
        command: "copf toolchain validate"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | resolve | `copf toolchain resolve <lang>` | Find compiler for language |
        | validate | `copf toolchain validate` | Re-check resolved tools |
        | list | `copf toolchain list` | Show all toolchains |
        | capabilities | `copf toolchain capabilities` | Show tool capabilities |
    related-workflows:
      - name: build-orchestration
        description: "Builder uses resolved toolchains"
      - name: deployment-config
        description: "Deploy manifest configures build targets"
    anti-patterns:
      - title: "Hardcoded tool paths"
        description: "Builder uses hardcoded paths to compilers instead of resolving through Toolchain."
        bad: |
          SwiftBuilder/build(toolchainPath: "/usr/bin/swiftc", ...)
        good: |
          Toolchain/resolve(language: "swift", platform: "linux-arm64")
          # -> ok(tool, version, path: "/usr/bin/swiftc", capabilities)
          SwiftBuilder/build(toolchainPath: ?path, ...)

  # ─── DeploymentValidator: deployment-config ────────
  deployment-config:
    concept: DeploymentValidator
    steps:
      - action: validate
        title: "Validate Deployment Manifest"
        prose: "Validate that deployment manifests correctly map concepts to runtimes, assign syncs to engines, and satisfy capability requirements."
    checklists:
      validate:
        - "Every concept mapped to a runtime?"
        - "Sync engine assignments cover all syncs?"
        - "Transport adapters match concept locations?"
        - "Capability requirements satisfied by target runtimes?"
    design-principles:
      - title: "Declarative Deployment"
        rule: "The deployment manifest declares intent (what runs where), not imperative steps — the framework resolves transport and engine assignments."
      - title: "Capability Matching"
        rule: "Each runtime declares capabilities (storage types, transport protocols) and the validator checks that every concept's needs are met."
    references:
      - path: references/deployment-guide.md
        label: "Deployment configuration guide"
        tier: reference
        content: |
          # Deployment Configuration Guide

          A deployment manifest maps concepts to runtimes, assigns syncs
          to engines, and configures transport between runtimes.

          ## Manifest Structure

          ```yaml
          deployment:
            name: my-app
            version: 1.0.0

          runtimes:
            api:
              type: node
              concepts: [User, Article, Comment]
              capabilities: [storage-postgres, transport-http]
            worker:
              type: node
              concepts: [Email, Notification]
              capabilities: [storage-redis, transport-amqp]

          engines:
            default:
              type: in-process
              syncs: [CreateProfile, UpdateCache]
            async:
              type: queue
              syncs: [WelcomeEmail, NotifyOnComment]

          transports:
            api-to-worker:
              type: http
              from: api
              to: worker
              endpoint: http://worker:3001
          ```

          ## Runtime Configuration

          Each runtime declares:
          - **type** — Execution environment (node, deno, edge)
          - **concepts** — Which concepts run in this runtime
          - **capabilities** — Available storage and transport types

          ## Engine Assignment

          Sync engines execute sync rules. Types:
          - `in-process` — Runs within the concept's runtime. For eager syncs.
          - `queue` — Uses a message queue. For eventual syncs.
          - `distributed` — Cross-runtime engine. For multi-runtime syncs.

          ## Validation Rules

          The validator checks:
          1. Every concept is assigned to exactly one runtime.
          2. Every sync is assigned to an engine.
          3. Cross-runtime syncs have a transport adapter configured.
          4. Runtime capabilities satisfy concept requirements.
      - path: references/transport-adapters.md
        label: "Transport adapter configuration"
        tier: reference
        content: |
          # Transport Adapter Reference

          Transport adapters enable cross-runtime communication when
          concepts in different runtimes need to interact through syncs.

          ## Adapter Types

          | Type | Use Case | Latency |
          |------|----------|---------|
          | `http` | REST-based communication | Medium |
          | `websocket` | Bidirectional real-time | Low |
          | `amqp` | Message queue (RabbitMQ) | Medium |
          | `in-process` | Same runtime (no transport) | None |

          ## HTTP Adapter

          ```yaml
          transports:
            api-to-worker:
              type: http
              from: api
              to: worker
              endpoint: http://worker:3001
              timeout: 5000
              retries: 3
          ```

          ## WebSocket Adapter

          ```yaml
          transports:
            realtime:
              type: websocket
              from: api
              to: client
              path: /ws
          ```

          ## AMQP Adapter

          ```yaml
          transports:
            async-bridge:
              type: amqp
              from: api
              to: worker
              url: amqp://rabbitmq:5672
              exchange: copf-events
              queue: worker-tasks
          ```

          ## When to Use Transports

          - **Same runtime**: No transport needed. Syncs run in-process.
          - **Two runtimes, same machine**: Use `http` or `in-process` IPC.
          - **Distributed**: Use `amqp` for reliability or `websocket` for
            low-latency bidirectional communication.
    validation-commands:
      - label: "Validate deployment manifest"
        command: "npx tsx tools/copf-cli/src/index.ts deploy --validate"
      - label: "Run deployment validator tests"
        command: "npx vitest run tests/deployment-validator.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Section | Purpose | Required |
        |---------|---------|----------|
        | runtimes | Map concepts to execution environments | Yes |
        | engines | Assign sync engines to sync groups | Yes |
        | transports | Configure cross-runtime communication | If multi-runtime |
        | capabilities | Declare runtime capabilities | Recommended |
    related-workflows:
      - name: concept-validator
        description: "Validate concept specs before deployment"
      - name: cache-build
        description: "Pre-compile artifacts for faster deployment"
      - name: kit-lifecycle
        description: "Manage kits that bundle deployed concepts"
    anti-patterns:
      - title: "Missing transport for cross-runtime sync"
        description: "Two concepts in different runtimes connected by a sync but no transport adapter configured."
        bad: |
          runtimes:
            api: { concepts: [User] }
            worker: { concepts: [Email] }
          syncs:
            - SendWelcome  # User -> Email, but no transport!
        good: |
          runtimes:
            api: { concepts: [User] }
            worker: { concepts: [Email] }
          transports:
            api-to-worker: { type: http, from: api, to: worker }
          syncs:
            - SendWelcome  # Now has a transport path

  # ─── Migration: migration-runner ───────────────────
  migration-runner:
    concept: Migration
    steps:
      - action: plan
        title: "Plan Migration"
        prose: "Analyze schema changes and plan migration steps for concept state transitions."
      - action: apply
        title: "Apply Migration"
        prose: "Execute the planned migration, transforming stored state to match the new schema."
    checklists:
      plan:
        - "Schema diff shows expected changes?"
        - "No data loss in state transformations?"
        - "Rollback strategy identified?"
      apply:
        - "Backup created before applying?"
        - "Migration ran to completion?"
        - "Post-migration validation passed?"
    design-principles:
      - title: "Version Gating"
        rule: "A concept cannot start until its storage schema matches its current spec version — the migration concept gates startup."
      - title: "Reversible by Default"
        rule: "Every migration step should have a corresponding rollback step — data transformations should be invertible."
    references:
      - path: references/migration-guide.md
        label: "Migration planning and execution guide"
        tier: reference
        content: |
          # Migration Planning and Execution Guide

          When a concept's spec changes (new state fields, renamed actions,
          changed types), stored data must be migrated to match.

          ## Migration Workflow

          1. **Detect** — Compare current spec version against stored schema version.
          2. **Plan** — Generate migration steps from the schema diff.
          3. **Dry-run** — Validate the plan against a copy of stored data.
          4. **Apply** — Execute the migration, transforming stored state.
          5. **Verify** — Confirm the new schema matches the updated spec.

          ## Schema Diff Types

          | Change | Migration Action | Risk |
          |--------|-----------------|------|
          | Add field (optional) | Set default value | Low |
          | Add field (required) | Compute or prompt for value | Medium |
          | Remove field | Drop column/key | Low (data loss) |
          | Rename field | Copy + drop | Medium |
          | Change type | Transform values | High |
          | Add action | No migration needed | None |
          | Remove action | No migration needed | None |

          ## Rollback Strategy

          Every migration step should be reversible:

          ```yaml
          migration:
            steps:
              - action: addField
                concept: User
                field: displayName
                type: String
                default: ""
                rollback: removeField
          ```

          ## Commands

          | Command | Purpose |
          |---------|---------|
          | `copf migrate --status` | Show current schema versions |
          | `copf migrate --plan` | Preview planned migration steps |
          | `copf migrate --dry-run` | Test migration without applying |
          | `copf migrate --apply` | Execute the migration |

          ## Safety Rules

          - Always create a backup before applying.
          - Run `--dry-run` before `--apply` on production data.
          - Never skip schema versions — migrations are sequential.
          - Version-gate startup: concepts refuse to start if schema is outdated.
    validation-commands:
      - label: "Check migration status"
        command: "npx tsx tools/copf-cli/src/index.ts migrate --status"
      - label: "Run migration dry-run"
        command: "npx tsx tools/copf-cli/src/index.ts migrate --dry-run"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | plan | `copf migrate --plan` | Show planned migration steps |
        | apply | `copf migrate --apply` | Execute migration |
        | status | `copf migrate --status` | Check current schema versions |
    related-workflows:
      - name: concept-validator
        description: "Validate the updated concept spec"
      - name: implementation-builder
        description: "Update the handler implementation after schema change"
      - name: deployment-config
        description: "Re-validate deployment after migration"

  # ─── ProjectScaffold: project-initializer ──────────
  project-initializer:
    concept: ProjectScaffold
    steps:
      - action: scaffold
        title: "Scaffold New Project"
        prose: "Create a new COPF project directory with specs, syncs, implementations, and configuration files."
    checklists:
      scaffold:
        - "Project name is valid (kebab-case, no conflicts)?"
        - "Directory structure created correctly?"
        - "Example concept spec is parseable?"
        - "Configuration files have sensible defaults?"
    design-principles:
      - title: "Minimal Viable Structure"
        rule: "Scaffold the minimum needed to run `copf check` and `copf generate` — don't overload with unused templates."
      - title: "Convention Over Configuration"
        rule: "Project follows standard directory layout (specs/, syncs/, implementations/) so tools work without configuration."
    references:
      - path: references/project-structure.md
        label: "Standard project directory layout"
        tier: reference
        content: |
          # Standard Project Directory Layout

          A COPF project follows a convention-over-configuration directory
          structure. Tools expect this layout to work without extra config.

          ## Directory Tree

          ```
          my-app/
          ├── specs/                 # Concept specifications
          │   ├── user.concept
          │   ├── article.concept
          │   └── comment.concept
          ├── syncs/                 # Synchronization rules
          │   ├── create-profile.sync
          │   └── welcome-email.sync
          ├── implementations/       # Handler code
          │   ├── user.impl.ts
          │   ├── article.impl.ts
          │   └── comment.impl.ts
          ├── kits/                  # Reusable concept packages
          │   └── auth-kit/
          │       ├── kit.yaml
          │       ├── concepts/
          │       └── syncs/
          ├── tests/                 # Conformance and integration tests
          │   ├── user.test.ts
          │   └── syncs.test.ts
          ├── generated/             # Auto-generated output (do not edit)
          │   ├── manifests/
          │   └── types/
          ├── deploy.yaml            # Deployment manifest
          └── copf.config.yaml       # Project configuration
          ```

          ## Key Directories

          | Directory | Purpose | File Types |
          |-----------|---------|------------|
          | `specs/` | Concept definitions | `.concept` |
          | `syncs/` | Sync rules | `.sync` |
          | `implementations/` | Handler code | `.impl.ts` |
          | `kits/` | Reusable packages | `kit.yaml` + subdirs |
          | `generated/` | Auto-generated (gitignored) | `.ts`, `.json` |
          | `tests/` | Tests | `.test.ts` |

          ## Configuration File

          ```yaml
          # copf.config.yaml
          project:
            name: my-app
            version: 0.1.0
          specs:
            dir: ./specs
          syncs:
            dir: ./syncs
          output:
            dir: ./generated
          ```
    validation-commands:
      - label: "Validate scaffolded project"
        command: "npx tsx tools/copf-cli/src/index.ts check"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Directory | Purpose | Contains |
        |-----------|---------|----------|
        | specs/ | Concept specifications | .concept files |
        | syncs/ | Synchronization rules | .sync files |
        | implementations/ | Handler code | .impl.ts files |
        | kits/ | Kit manifests | kit.yaml + concepts + syncs |
    related-workflows:
      - name: concept-designer
        description: "Design concepts for the new project"
      - name: kit-lifecycle
        description: "Bundle concepts into reusable kits"
      - name: dev-workflow
        description: "Start the dev server for the new project"

  # ─── KitManager: kit-lifecycle ─────────────────────
  kit-lifecycle:
    concept: KitManager
    steps:
      - action: init
        title: "Create Kit"
        prose: "Scaffold a new kit directory with kit.yaml, concept and sync subdirectories, and example files."
      - action: validate
        title: "Validate Kit"
        prose: "Validate a kit manifest, its concept specs, sync definitions, and cross-kit references."
      - action: test
        title: "Test Kit"
        prose: "Run conformance and integration tests for the kit."
      - action: list
        title: "List Active Kits"
        prose: "List all kits used by the current application."
      - action: checkOverrides
        title: "Check Overrides"
        prose: "Verify that application sync overrides reference valid syncs in the target kit."
    checklists:
      init:
        - "Kit name follows naming convention?"
        - "Kit.yaml has required fields (name, version, description)?"
        - "Example concept spec is valid?"
      validate:
        - "All concept specs parse successfully?"
        - "All sync files compile?"
        - "Cross-kit references resolve?"
        - "Type parameters align across concepts?"
      test:
        - "Conformance tests pass?"
        - "Integration tests pass?"
        - "No failing assertions?"
      checkOverrides:
        - "Override references valid syncs?"
        - "Override parameters match original sync signature?"
    design-principles:
      - title: "Kit as Reusable Unit"
        rule: "A kit bundles related concepts and syncs into a single distributable package — like an npm package for COPF."
      - title: "Cross-Kit Isolation"
        rule: "Concepts in one kit never reference concepts in another kit directly — cross-kit integration happens through syncs and type parameter alignment."
      - title: "Required vs Recommended Syncs"
        rule: "Kit syncs are tiered: required syncs are load-bearing, recommended syncs provide useful defaults, integration syncs wire to other kits."
    references:
      - path: references/kit-structure.md
        label: "Kit manifest and directory structure"
        tier: reference
        content: |
          # Kit Manifest and Directory Structure

          A kit bundles related concepts and syncs into a reusable package.

          ## Kit Directory

          ```
          my-kit/
          ├── kit.yaml              # Kit manifest
          ├── concepts/             # Concept specs
          │   ├── user.concept
          │   └── profile.concept
          ├── syncs/                # Internal syncs
          │   └── create-profile.sync
          ├── implementations/      # Default implementations
          │   ├── user.impl.ts
          │   └── profile.impl.ts
          └── tests/                # Kit tests
              └── conformance.test.ts
          ```

          ## Kit Manifest (kit.yaml)

          ```yaml
          kit:
            name: auth
            version: 1.0.0
            description: Authentication and identity management

          concepts:
            - concepts/user.concept
            - concepts/password.concept
            - concepts/session.concept

          syncs:
            required:
              - syncs/validate-session.sync
            recommended:
              - syncs/create-profile.sync
            integration:
              - syncs/audit-login.sync

          typeParameters:
            User: [U]
            Session: [S, U]

          dependencies: []
          ```

          ## Sync Tiers

          | Tier | Meaning | Override? |
          |------|---------|-----------|
          | `required` | Load-bearing, must be active | No |
          | `recommended` | Useful defaults | Yes |
          | `integration` | Wire to other kits | Yes |

          ## Kit vs Application Syncs

          Kit syncs wire concepts *within* the kit. Application syncs
          wire *across* kits. Applications can override recommended
          and integration syncs but not required syncs.
      - path: references/kit-publishing.md
        label: "Publishing and versioning kits"
        tier: reference
        content: |
          # Publishing and Versioning Kits

          ## Versioning

          Kits follow semantic versioning:
          - **Major** — Breaking changes to concept specs or required syncs.
          - **Minor** — New concepts, new optional syncs, new actions.
          - **Patch** — Bug fixes, documentation, implementation improvements.

          ## Publishing Workflow

          1. **Validate** — `copf kit validate ./kits/my-kit`
          2. **Test** — `copf kit test ./kits/my-kit`
          3. **Version** — Update `kit.yaml` version field.
          4. **Package** — `copf kit pack ./kits/my-kit`
          5. **Publish** — `copf kit publish ./kits/my-kit`

          ## Registry

          Kits are published to a registry (npm-compatible):

          ```bash
          # Publish to default registry
          copf kit publish ./kits/my-kit

          # Publish to custom registry
          copf kit publish ./kits/my-kit --registry https://my-registry.com
          ```

          ## Installing Kits

          ```bash
          copf kit add auth@1.0.0
          ```

          This adds the kit to the project's `copf.config.yaml`:

          ```yaml
          kits:
            - name: auth
              version: 1.0.0
              overrides:
                syncs:
                  - syncs/custom-profile.sync  # Override recommended sync
          ```

          ## Breaking Change Guidelines

          When making a breaking change:
          1. Bump major version.
          2. Document migration steps.
          3. Provide a migration sync if state schema changed.
    anti-patterns:
      - title: "Cross-kit concept reference"
        description: "Kit A's concept imports Kit B's types directly instead of using type parameters."
        bad: |
          # In kit-a/concepts/order.concept
          concept Order [O] {
            state { customer: O -> kit_b.User }  # Direct reference!
          }
        good: |
          # In kit-a/concepts/order.concept
          concept Order [O, U] {
            state { customer: O -> U }  # Type parameter, wired by sync
          }
      - title: "Monolithic kit"
        description: "Kit bundles unrelated concepts — violates the reusable unit principle."
        bad: |
          # kit.yaml
          kit: { name: everything }
          concepts: [User, Article, Payment, Analytics, Email, Notification]
        good: |
          # Split into focused kits
          kit: { name: content }   # concepts: [Article, Tag, Comment]
          kit: { name: commerce }  # concepts: [Payment, Invoice, Refund]
    validation-commands:
      - label: "Validate a kit"
        command: "npx tsx tools/copf-cli/src/index.ts kit validate ./kits/my-kit"
      - label: "Run kit tests"
        command: "npx tsx tools/copf-cli/src/index.ts kit test ./kits/my-kit"
      - label: "List active kits"
        command: "npx tsx tools/copf-cli/src/index.ts kit list"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | init | `copf kit init <name>` | Scaffold a new kit |
        | validate | `copf kit validate <path>` | Validate kit manifest |
        | test | `copf kit test <path>` | Run kit tests |
        | list | `copf kit list` | List active kits |
        | checkOverrides | `copf kit check-overrides <path>` | Verify sync overrides |
    related-workflows:
      - name: concept-designer
        description: "Design concepts to include in the kit"
      - name: sync-designer
        description: "Write syncs that wire kit concepts together"
      - name: deployment-config
        description: "Deploy kits to production runtimes"

  # ─── DevServer: dev-workflow ───────────────────────
  dev-workflow:
    concept: DevServer
    steps:
      - action: start
        title: "Start Dev Server"
        prose: "Start a local development server that watches for changes and auto-recompiles."
      - action: status
        title: "Check Status"
        prose: "Check whether the dev server is running and view uptime stats."
      - action: stop
        title: "Stop Server"
        prose: "Stop the running development server."
    checklists:
      start:
        - "Port is available?"
        - "Specs and syncs directories exist?"
        - "Initial compilation succeeds?"
      status:
        - "Server is responsive?"
        - "Last recompile was successful?"
    design-principles:
      - title: "Watch and Recompile"
        rule: "The dev server watches .concept and .sync files for changes and recompiles automatically — no manual rebuild step."
      - title: "Fast Feedback Loop"
        rule: "Recompilation should complete in under a second for typical projects — parse errors show immediately."
    references:
      - path: references/dev-workflow.md
        label: "Development workflow guide"
        tier: reference
        content: |
          # Development Workflow Guide

          The COPF dev server provides a fast feedback loop for iterating
          on concept specs and sync rules.

          ## Starting the Dev Server

          ```bash
          copf dev --port 3000
          ```

          The dev server:
          1. Parses all `.concept` files in `specs/`.
          2. Compiles all `.sync` files in `syncs/`.
          3. Generates manifests and types.
          4. Watches for file changes and re-runs on save.

          ## Development Cycle

          1. **Edit a .concept file** — Save triggers reparse + validation.
          2. **Edit a .sync file** — Save triggers recompile + binding check.
          3. **Edit a .impl.ts file** — Save triggers type check against manifest.
          4. **View errors** — Parse/compile errors show in terminal immediately.

          ## Watch Mode Behavior

          | File Change | Action Taken |
          |-------------|-------------|
          | `.concept` modified | Reparse spec, regenerate manifest |
          | `.sync` modified | Recompile sync, recheck bindings |
          | `.impl.ts` modified | Type-check against manifest |
          | `copf.config.yaml` modified | Full restart |

          ## Debugging During Dev

          The dev server assigns flow IDs to every action invocation.
          Use `copf trace <flow-id>` to debug execution chains.

          ## Performance

          - Incremental recompilation: only changed files are reprocessed.
          - Typical recompile time: under 100ms for small-medium projects.
          - Full rebuild on config change or first start.
    validation-commands:
      - label: "Start dev server"
        command: "npx tsx tools/copf-cli/src/index.ts dev --port 3000"
      - label: "Check dev server status"
        command: "npx tsx tools/copf-cli/src/index.ts dev status"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | start | `copf dev --port <port>` | Start dev server |
        | status | `copf dev status` | Check if running |
        | stop | `copf dev stop` | Stop the server |
    related-workflows:
      - name: concept-validator
        description: "Validate specs that the dev server watches"
      - name: trace-debugger
        description: "Debug flows generated during dev server sessions"
      - name: cache-build
        description: "Pre-compile for production after dev iteration"

  # ─── CacheCompiler: cache-build ────────────────────
  cache-build:
    concept: CacheCompiler
    steps:
      - action: compile
        title: "Build Cache"
        prose: "Parse specs and syncs, generate manifests, compile sync rules, and write pre-compiled artifacts to the cache directory."
    checklists:
      compile:
        - "All concept specs parse without errors?"
        - "All sync files compile?"
        - "Cache directory is writable?"
        - "Previous cache is cleaned or invalidated?"
    design-principles:
      - title: "Content-Addressed Cache"
        rule: "Cached artifacts are keyed by content hash — identical input produces identical output, and unchanged files are never rewritten."
      - title: "Complete Compilation"
        rule: "Cache includes everything needed for deployment — parsed ASTs, generated manifests, compiled syncs, and type information."
    references:
      - path: references/caching.md
        label: "Cache compilation and invalidation"
        tier: reference
        content: |
          # Cache Compilation and Invalidation

          The cache compiler pre-compiles all concept specs and sync rules
          into artifacts for faster startup and deployment.

          ## What Gets Cached

          | Artifact | Source | Format |
          |----------|--------|--------|
          | Parsed ASTs | `.concept` files | JSON |
          | Concept manifests | Parsed ASTs | JSON |
          | Compiled syncs | `.sync` files | JavaScript |
          | Type definitions | Manifests | TypeScript `.d.ts` |

          ## Cache Directory

          ```
          .copf-cache/
          ├── manifests/
          │   ├── user.manifest.json
          │   └── article.manifest.json
          ├── syncs/
          │   ├── create-profile.compiled.js
          │   └── welcome-email.compiled.js
          ├── types/
          │   ├── user.d.ts
          │   └── article.d.ts
          └── cache.lock.json       # Content hashes for invalidation
          ```

          ## Content-Addressed Invalidation

          Each cached artifact is keyed by the content hash of its source
          file. When you run `copf compile --cache`:

          1. Hash each source file.
          2. Compare against `cache.lock.json`.
          3. Only recompile files whose hash changed.
          4. Update `cache.lock.json` with new hashes.

          ## Commands

          | Command | Purpose |
          |---------|---------|
          | `copf compile --cache` | Build/rebuild the cache |
          | `copf compile --cache --clean` | Wipe and rebuild from scratch |
          | `copf compile --cache --verbose` | Show per-file cache hits/misses |

          ## Deployment Use

          In production, deploy the `.copf-cache/` directory alongside
          your application. The runtime loads pre-compiled artifacts
          instead of parsing specs at startup.
    validation-commands:
      - label: "Build the cache"
        command: "npx tsx tools/copf-cli/src/index.ts compile --cache"
      - label: "Verify cache contents"
        command: "ls -la .copf-cache/"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | compile | `copf compile --cache` | Build pre-compiled cache |
    related-workflows:
      - name: concept-validator
        description: "Validate specs before caching"
      - name: deployment-config
        description: "Deploy using cached artifacts"
      - name: dev-workflow
        description: "Dev server uses cache for fast startup"

  # ─── Emitter: file-emission ──────────────────────────
  file-emission:
    concept: Emitter
    steps:
      - action: write
        title: "Write Single File"
        prose: "Write a single generated file with content-addressed deduplication."
      - action: writeBatch
        title: "Emit Generated Files"
        prose: "Atomically write a batch of generated files with content-addressed deduplication."
      - action: audit
        title: "Drift Detection"
        prose: "Compare generated files on disk against expected output to detect manual edits."
      - action: clean
        title: "Orphan Cleanup"
        prose: "Remove output files that are no longer produced by any generator."
      - action: trace
        title: "Source Provenance"
        prose: "Show which source files and concept actions produced a given output file."
      - action: affected
        title: "Impact Analysis"
        prose: "Show what output files are affected by a change to a given source file."
    checklists:
      write:
        - "Path is within the designated output directory?"
        - "Content hash computed before write?"
      writeBatch:
        - "All source provenance metadata attached?"
        - "Format hint set for each file?"
        - "Output directory exists?"
      audit:
        - "Generated files match expected hashes?"
        - "No manual edits detected?"
      clean:
        - "Current manifest accurately lists all expected files?"
        - "Orphaned files identified and removed?"
      trace:
        - "Output path resolves to a tracked generated file?"
        - "Source provenance entries are complete?"
      affected:
        - "Source path resolves to a tracked input?"
        - "All downstream outputs identified?"
    design-principles:
      - title: "Content-Addressed Writes"
        rule: "Files are only written when their content hash changes — identical rewrites are skipped."
      - title: "Source Provenance"
        rule: "Every output file tracks which source files and concept actions produced it."
    references:
      - path: references/emitter-architecture.md
        label: "Emitter architecture and traceability"
        tier: reference
        content: |
          # Emitter Architecture

          The Emitter concept manages all file I/O for the generation pipeline.

          ## Content-Addressed Writes

          Every `write` or `writeBatch` call computes a SHA-256 hash of the
          content. If the on-disk file already matches, the write is skipped.
          This prevents unnecessary file-system churn and avoids triggering
          downstream watchers.

          ## Source Provenance (sourceMap)

          Each output file stores a list of sources that contributed to it:
          - `sourcePath` — the input file (e.g., `specs/app/article.concept`)
          - `conceptName` — the concept that produced it
          - `actionName` — the action (e.g., `generate`)

          This enables:
          - `copf impact <file>` — which outputs change if this input changes
          - `copf emitter trace <output>` — which inputs produced this output
          - `copf emitter audit <dir>` — detect files modified outside generation

          ## Batch Writes

          `writeBatch` writes multiple files atomically — if any file fails,
          the batch reports the failure while the successful writes persist.
    validation-commands:
      - label: "Audit generated files"
        command: "npx tsx tools/copf-cli/src/index.ts generate --audit"
      - label: "Clean orphans"
        command: "npx tsx tools/copf-cli/src/index.ts generate --clean"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | write | `copf emitter write` | Write a single file |
        | writeBatch | `copf emitter write-batch` | Atomic batch write |
        | audit | `copf emitter audit <dir>` | Detect drift |
        | clean | `copf emitter clean <dir>` | Remove orphans |
        | trace | `copf emitter trace <path>` | Show source provenance |
        | affected | `copf emitter affected <path>` | Show impact of a source change |
        | manifest | `copf emitter manifest <dir>` | List all tracked outputs |
        | format | `copf emitter format <path>` | Format a generated file |
    related-workflows:
      - name: cache-compiler
        description: "Cache compiler uses Emitter for output"
      - name: implementation-builder
        description: "Code generation writes through Emitter"

  # ─── BuildCache: incremental-caching ──────────────────
  incremental-caching:
    concept: BuildCache
    steps:
      - action: check
        title: "Check Cache"
        prose: "Compare input hash against cached entry to determine if regeneration is needed."
      - action: record
        title: "Record Result"
        prose: "Store generation result with input/output hashes for future cache lookups."
      - action: status
        title: "Cache Status"
        prose: "Show all cache entries with staleness indicators."
      - action: staleSteps
        title: "List Stale Entries"
        prose: "List step keys that need regeneration because their inputs have changed."
    checklists:
      check:
        - "Step key uniquely identifies this generation step?"
        - "Input hash is deterministic?"
      record:
        - "Output hash computed from actual files written?"
        - "Source locator recorded for invalidation?"
      status:
        - "Stale entries identified?"
      staleSteps:
        - "All step keys evaluated?"
    design-principles:
      - title: "Hash-Based Invalidation"
        rule: "Cache validity is determined solely by comparing input hashes — no timestamps or file watchers."
      - title: "Per-Step Granularity"
        rule: "Each generator+concept pair has its own cache entry, enabling partial rebuilds."
    references:
      - path: references/build-cache-architecture.md
        label: "BuildCache design and invalidation strategy"
        tier: reference
        content: |
          # BuildCache Architecture

          BuildCache tracks generation results per step key (generator:concept pair).

          ## Cache Check Flow

          1. Compute input hash (deterministic hash of concept manifest or projection)
          2. Look up step key in cache
          3. Compare hashes → `unchanged` (cache hit) or `changed` (cache miss)

          ## Invalidation Strategies

          - **By source**: When a `.concept` file changes, invalidate all steps
            that used it (`invalidateBySource`)
          - **By kind**: When an IR kind is invalidated, cascade to all dependent
            kinds (`invalidateByKind`)
          - **Manual**: `invalidateAll` clears the entire cache

          ## Deterministic vs Non-Deterministic

          Deterministic generators (same input → same output) can be cached
          aggressively. Non-deterministic generators (e.g., timestamp-based)
          are always re-run.
    validation-commands:
      - label: "Show cache status"
        command: "npx tsx tools/copf-cli/src/index.ts generate --status"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | check | `copf build-cache check` | Check if step is cached |
        | record | `copf build-cache record` | Record generation result |
        | status | `copf build-cache status` | Show all cache entries |
        | staleSteps | `copf build-cache stale-steps` | List stale entries |
        | invalidate | `copf build-cache invalidate` | Invalidate one step |
        | invalidateBySource | `copf build-cache invalidate-by-source` | Invalidate by source file |
        | invalidateByKind | `copf build-cache invalidate-by-kind` | Invalidate by IR kind |
        | invalidateAll | `copf build-cache invalidate-all` | Clear entire cache |
    related-workflows:
      - name: file-emission
        description: "Emitter writes files after cache miss"
      - name: incremental-caching
        description: "Self-referential: cache checks gate generation"

  # ─── Resource: input-tracking ────────────────────────
  input-tracking:
    concept: Resource
    steps:
      - action: upsert
        title: "Track Input"
        prose: "Register or update a tracked input resource with its content digest."
      - action: list
        title: "List Resources"
        prose: "List all tracked input resources, optionally filtered by kind."
    checklists:
      upsert:
        - "Locator is a stable, unique identifier?"
        - "Digest is a content hash (not a timestamp)?"
      list:
        - "Kind filter matches expected resource types?"
    design-principles:
      - title: "Content-Addressed Tracking"
        rule: "Resources are tracked by content digest, not modification time. Two files with identical content have the same digest."
    validation-commands:
      - label: "List tracked resources"
        command: "npx tsx tools/copf-cli/src/index.ts generate --status"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | upsert | `copf resource upsert` | Track or update an input |
        | get | `copf resource get` | Look up a tracked resource |
        | list | `copf resource list` | List all tracked inputs |
        | remove | `copf resource remove` | Stop tracking a resource |
        | diff | `copf resource diff` | Classify a content change |
    related-workflows:
      - name: incremental-caching
        description: "Resource changes invalidate BuildCache entries"
      - name: file-emission
        description: "Resource tracking feeds into generation pipeline"

  # ─── KindSystem: pipeline-topology ───────────────────
  pipeline-topology:
    concept: KindSystem
    steps:
      - action: graph
        title: "View Kind Graph"
        prose: "Display the full IR kind taxonomy showing all kinds and transform edges."
      - action: route
        title: "Find Transform Path"
        prose: "Find the shortest transform path between two IR kinds."
      - action: consumers
        title: "Show Consumers"
        prose: "List all transforms that consume a given kind."
      - action: producers
        title: "Show Producers"
        prose: "List all transforms that produce a given kind."
    checklists:
      graph:
        - "All generator kinds registered?"
        - "No orphan kinds (unreachable from any source)?"
      route:
        - "Path exists between the two kinds?"
    design-principles:
      - title: "Cycle-Free DAG"
        rule: "The kind graph must be a directed acyclic graph. Cycle detection runs on every connect() call."
      - title: "Static Topology"
        rule: "Kinds and edges are registered at startup from kit.yaml metadata, not at generation time."
    references:
      - path: references/kind-system-architecture.md
        label: "KindSystem taxonomy and routing"
        tier: reference
        content: |
          # KindSystem Architecture

          The KindSystem models the pipeline topology as a directed acyclic graph
          of IR (intermediate representation) kinds.

          ## Kind Categories

          - **source**: Raw input files (ConceptDSL, SyncDSL, InterfaceManifest)
          - **model**: Parsed/structured data (ConceptAST, ConceptManifest, Projection)
          - **artifact**: Generated output files (TypeScriptFiles, RestRoutes, etc.)

          ## Transform Edges

          Each edge represents a generator that transforms one kind into another:
          - `ConceptDSL →[SpecParser]→ ConceptAST`
          - `ConceptAST →[SchemaGen]→ ConceptManifest`
          - `ConceptManifest →[TypeScriptGen]→ TypeScriptFiles`
          - `Projection →[RestTarget]→ RestRoutes`

          ## Routing

          `route(from, to)` finds the shortest path using BFS. This determines
          which generators must run to produce a desired artifact from a given source.

          ## Cascade Invalidation

          When a kind is invalidated, `dependents(kind)` returns all downstream
          kinds that need re-generation. This drives the cascade invalidation syncs.
    validation-commands:
      - label: "List all kinds"
        command: "npx tsx tools/copf-cli/src/index.ts kinds list"
      - label: "Find transform path"
        command: "npx tsx tools/copf-cli/src/index.ts kinds path ConceptDSL TypeScriptFiles"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | graph | `copf kind-system graph` | Show full kind taxonomy |
        | route | `copf kind-system route` | Find shortest transform path |
        | consumers | `copf kind-system consumers` | What consumes a kind |
        | producers | `copf kind-system producers` | What produces a kind |
        | define | `copf kind-system define` | Register a new kind |
        | connect | `copf kind-system connect` | Declare a transform edge |
        | validate | `copf kind-system validate` | Validate an edge |
        | dependents | `copf kind-system dependents` | List downstream kinds |
    related-workflows:
      - name: incremental-caching
        description: "Kind graph drives cascade invalidation"
      - name: file-emission
        description: "Kind routing determines generation order"

  # ─── GenerationPlan: run-tracking ────────────────────
  run-tracking:
    concept: GenerationPlan
    steps:
      - action: status
        title: "Run Status"
        prose: "Show detailed step-by-step status of a generation run."
      - action: summary
        title: "Run Summary"
        prose: "Show aggregate statistics: total/executed/cached/failed steps, duration, files produced."
      - action: history
        title: "Run History"
        prose: "Show recent generation runs with their outcomes."
    checklists:
      status:
        - "Run reference is valid?"
      summary:
        - "All steps accounted for?"
      history:
        - "Limit is reasonable?"
    design-principles:
      - title: "Passive Observer"
        rule: "GenerationPlan is purely passive — it records what syncs report, never drives execution."
      - title: "Run Isolation"
        rule: "Each generation run has its own reference. Steps are recorded against the active run."
    validation-commands:
      - label: "Show generation summary"
        command: "npx tsx tools/copf-cli/src/index.ts generate --summary"
      - label: "Show generation history"
        command: "npx tsx tools/copf-cli/src/index.ts generate --history"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | begin | `copf generation-plan begin` | Mark run started |
        | recordStep | `copf generation-plan record-step` | Record step outcome |
        | complete | `copf generation-plan complete` | Mark run finished |
        | status | `copf generation-plan status` | Show step-by-step status |
        | summary | `copf generation-plan summary` | Show aggregate statistics |
        | history | `copf generation-plan history` | Show recent runs |
    related-workflows:
      - name: file-emission
        description: "Emitter writes tracked by GenerationPlan"
      - name: incremental-caching
        description: "Cache hits/misses recorded as steps"

  # ─── KitScaffoldGen: kit-scaffold ──────────────────
  kit-scaffold:
    concept: KitScaffoldGen
    steps:
      - action: register
        title: "Register Generator"
        prose: "Self-register with PluginRegistry so KindSystem can track KitConfig → KitManifest transformations. Registration is also handled automatically by register-generator-kinds.sync."
      - action: preview
        title: "Preview Changes"
        prose: "Dry-run the generation using Emitter content-addressing to classify each output file as new, changed, or unchanged. No files are written."
      - action: generate
        title: "Generate Kit Manifest"
        prose: "Generate a kit.yaml manifest with concept declarations, sync tier groupings, type parameter alignment, and directory structure stubs. Sync rules then cascade: kit-scaffold-emit.sync routes files through Emitter, kit-scaffold-record-cache.sync records output in BuildCache, and kit-scaffold-observer.sync tracks the run in GenerationPlan."
    checklists:
      generate:
        - "Kit name is kebab-case?"
        - "Version is valid semver?"
        - "All listed concepts have matching .concept stub files?"
        - "Syncs are grouped by tier (required/recommended/integration)?"
        - "Type parameter `as` tags are kebab-case with -ref suffix?"
        - "Dependencies use semver constraints?"
        - "All files written through Emitter (not directly to disk)?"
        - "Source provenance attached to each file?"
        - "Generation step recorded in GenerationPlan?"
    design-principles:
      - title: "Convention Over Configuration"
        rule: "Generated kit.yaml follows the standard layout — concepts at top, syncs by tier, uses for external references. Tools work without extra configuration."
      - title: "Type Parameter Alignment"
        rule: "Every concept's type parameter has an `as` tag that enables cross-concept type alignment. Concepts sharing the same `as` tag share the same entity type."
      - title: "Sync Tier Discipline"
        rule: "Required syncs protect data integrity. Recommended syncs provide useful defaults. Integration syncs wire to external kits. Never promote a recommended sync to required without justification."
    references:
      - path: references/kit-manifest-schema.md
        label: "Kit manifest (kit.yaml) schema reference"
        tier: reference
        content: |
          # Kit Manifest Schema Reference

          Complete schema for `kit.yaml` manifest files.

          ## Root Structure

          ```yaml
          kit:
            name: my-kit           # kebab-case
            version: 0.1.0         # semver
            description: >         # Multi-line description
              What this kit provides.
          ```

          ## Concepts Section

          ```yaml
          concepts:
            ConceptName:
              spec: ./concept-name.concept
              params:
                T: { as: concept-ref, description: "Reference to a ConceptName" }
          ```

          **Rules:**
          - Concept names are PascalCase
          - File names are kebab-case
          - Type parameters are single capital letters
          - The `as` tag enables cross-concept type alignment

          ## Syncs Section

          ```yaml
          syncs:
            required:
              - path: ./syncs/validate-before-save.sync
                description: "Prevents invalid state — removal causes corruption."
            recommended:
              - path: ./syncs/notify-on-change.sync
                name: NotifyOnChange
                description: "Sends notifications — apps can override or disable."
            integration:
              - path: ./syncs/audit-log.sync
                name: AuditLog
                description: "Logs changes — activated by audit kit."
          ```

          | Tier | Overridable | Disableable | When to Use |
          |------|------------|-------------|-------------|
          | required | No | No | Removal causes data corruption |
          | recommended | Yes | Yes | Useful defaults apps can customize |
          | integration | Yes | Depends | Cross-kit wiring |

          ## Uses Section

          ```yaml
          uses:
            - kit: auth
              concepts:
                - name: User
                  params: { U: { as: user-ref } }
            - kit: storage
              optional: true
              concepts:
                - name: Database
          ```

          ## Infrastructure Section (domain kits only)

          ```yaml
          infrastructure:
            transports:
              - name: http
                path: ./transports/http-transport.ts
            storage:
              - name: sqlite
                path: ./storage/sqlite-storage.ts
            deployTemplates:
              - path: ./deploy-templates/default.deploy.yaml
          ```

          ## Dependencies

          ```yaml
          dependencies:
            - auth: ">=1.0.0"
            - coif-core: ">=0.2.0"
          ```
      - path: references/type-alignment.md
        label: "Cross-concept type parameter alignment"
        tier: reference
        content: |
          # Type Parameter Alignment

          Type parameters connect concepts without violating independence.

          ## How It Works

          1. Concept A declares `params: { U: { as: user-ref } }`
          2. Concept B declares `params: { X: { as: user-ref } }`
          3. Both use `user-ref` — the framework unifies A's `U` with B's `X`

          ## Example

          ```yaml
          concepts:
            User:
              spec: ./user.concept
              params:
                U: { as: user-ref }
            Session:
              spec: ./session.concept
              params:
                S: { as: session-ref }
                U: { as: user-ref }    # Same tag → same entity type
          ```

          Now `Session`'s `U` and `User`'s `U` refer to the same entity,
          enabling syncs to pass user references between them.
    validation-commands:
      - label: "Generate a kit scaffold"
        command: "npx tsx tools/copf-cli/src/index.ts scaffold kit --name my-kit --concepts User,Session"
      - label: "Validate generated kit"
        command: "npx tsx tools/copf-cli/src/index.ts kit validate ./kits/my-kit"
      - label: "Run scaffold generator tests"
        command: "npx vitest run tests/scaffold-generators.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Input | Type | Purpose |
        |-------|------|---------|
        | name | String | Kit name (kebab-case) |
        | description | String | Kit purpose description |
        | concepts | list String | PascalCase concept names |
        | syncs | list {name, tier} | Sync declarations with tiers |
        | dependencies | list String | External kit dependencies |
        | isDomain | Boolean | Include infrastructure section |
    related-workflows:
      - name: kit-lifecycle
        description: "Manage kit versions and dependencies after scaffolding"
      - name: concept-scaffold
        description: "Generate concept specs for the kit's concepts"
      - name: sync-scaffold
        description: "Generate sync rules for the kit's syncs"
    anti-patterns:
      - title: "Missing type parameter alignment"
        description: "Concepts in the same kit lack `as` tags, preventing cross-concept type unification."
        bad: |
          concepts:
            User:
              spec: ./user.concept
              params:
                U: {}
            Session:
              spec: ./session.concept
              params:
                S: {}
        good: |
          concepts:
            User:
              spec: ./user.concept
              params:
                U: { as: user-ref }
            Session:
              spec: ./session.concept
              params:
                S: { as: session-ref }
                U: { as: user-ref }
      - title: "Flat sync list without tiers"
        description: "All syncs listed without tier annotation — impossible to know which are safe to override."
        bad: |
          syncs:
            - syncs/validate.sync
            - syncs/notify.sync
            - syncs/audit.sync
        good: |
          syncs:
            required:
              - path: ./syncs/validate.sync
            recommended:
              - path: ./syncs/notify.sync
                name: Notify

  # ─── DeployScaffoldGen: deploy-scaffold ────────────
  deploy-scaffold:
    concept: DeployScaffoldGen
    steps:
      - action: register
        title: "Register Generator"
        prose: "Self-register with PluginRegistry so KindSystem can track DeployConfig → DeployManifest transformations. Registration is also handled automatically by register-generator-kinds.sync."
      - action: preview
        title: "Preview Changes"
        prose: "Dry-run the generation using Emitter content-addressing to classify each output file as new, changed, or unchanged. No files are written."
      - action: generate
        title: "Generate Deploy Manifest"
        prose: "Generate a deploy.yaml manifest with runtime configurations, infrastructure declarations, concept-to-runtime assignments, and build settings. Sync rules then cascade: deploy-scaffold-emit.sync routes files through Emitter, deploy-scaffold-record-cache.sync records output in BuildCache, and deploy-scaffold-observer.sync tracks the run in GenerationPlan."
    checklists:
      generate:
        - "App name is valid?"
        - "Every runtime has a type and transport?"
        - "Infrastructure storage backends match runtime storage refs?"
        - "Every listed concept has a runtime assignment?"
        - "IaC provider is set (terraform, cloudformation, pulumi, docker-compose)?"
        - "Build section specifies compiler and test runner?"
        - "All files written through Emitter (not directly to disk)?"
        - "Source provenance attached to each file?"
        - "Generation step recorded in GenerationPlan?"
    design-principles:
      - title: "Declarative Over Imperative"
        rule: "The deploy manifest declares intent (what runs where) — the framework resolves transport, storage, and engine assignments."
      - title: "Runtime Isolation"
        rule: "Each concept runs in exactly one runtime. Cross-runtime communication uses transport adapters configured in the infrastructure section."
      - title: "Infrastructure as Code"
        rule: "The IaC provider setting enables `copf deploy` to generate Terraform, CloudFormation, or Pulumi resources from the manifest."
    references:
      - path: references/deploy-manifest-schema.md
        label: "Deploy manifest (deploy.yaml) schema reference"
        tier: reference
        content: |
          # Deploy Manifest Schema Reference

          Complete schema for `deploy.yaml` manifest files.

          ## Root Structure

          ```yaml
          app:
            name: my-app
            version: "0.1.0"
          ```

          ## Runtimes

          ```yaml
          runtimes:
            api:
              type: node
              transport: http
              storage: postgresql
              iac: terraform
              config:
                cpu: 256
                memory: 512
                replicas: 2
            worker:
              type: node
              transport: sqs
              storage: redis
            engine:
              engine: true
              transport: http
          ```

          | Field | Required | Description |
          |-------|----------|-------------|
          | type | Yes | Runtime type (node, deno, edge) |
          | transport | Yes | Communication protocol |
          | storage | No | Persistence backend |
          | iac | No | IaC provider for this runtime |
          | config | No | Resource limits and scaling |

          ## Infrastructure

          ```yaml
          infrastructure:
            storage:
              postgresql:
                type: postgresql
                config:
                  host: localhost
                  port: 5432
            transports:
              http:
                type: http
                config:
                  port: 3000
            iac:
              provider: terraform
          ```

          ## Concepts

          ```yaml
          concepts:
            User:
              spec: ./specs/app/user.concept
              implementations:
                - language: typescript
                  path: ./implementations/typescript/app/user.impl.ts
                  runtime: api
                  storage: postgresql
          ```

          ## Build

          ```yaml
          build:
            typescript:
              compiler: tsc
              testRunner: vitest
          ```
    validation-commands:
      - label: "Generate a deploy scaffold"
        command: "npx tsx tools/copf-cli/src/index.ts scaffold deploy --app my-app"
      - label: "Validate deploy manifest"
        command: "npx tsx tools/copf-cli/src/index.ts deploy --validate"
      - label: "Run scaffold generator tests"
        command: "npx vitest run tests/scaffold-generators.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Input | Type | Purpose |
        |-------|------|---------|
        | appName | String | Application name |
        | version | String | Semver version |
        | runtimes | list Runtime | Runtime configs (name, type, transport, storage) |
        | concepts | list Assignment | Concept-to-runtime mappings |
        | iacProvider | String | IaC provider (terraform, cloudformation, pulumi) |
    related-workflows:
      - name: deployment-config
        description: "Validate and refine generated deploy manifests"
      - name: kit-scaffold
        description: "Generate kits referenced by the deploy manifest"
      - name: build-orchestration
        description: "Build concepts for the declared runtimes"
    anti-patterns:
      - title: "Concept without runtime assignment"
        description: "Concept listed in deploy manifest but not assigned to any runtime."
        bad: |
          concepts:
            User:
              spec: ./specs/user.concept
              # No implementations or runtime!
        good: |
          concepts:
            User:
              spec: ./specs/user.concept
              implementations:
                - language: typescript
                  runtime: api
                  storage: postgresql
      - title: "Mismatched storage backends"
        description: "Runtime references a storage backend not declared in infrastructure."
        bad: |
          runtimes:
            api: { storage: mongodb }  # Not in infrastructure!
          infrastructure:
            storage:
              postgresql: { type: postgresql }
        good: |
          runtimes:
            api: { storage: postgresql }
          infrastructure:
            storage:
              postgresql: { type: postgresql }

  # ─── InterfaceScaffoldGen: interface-scaffold ──────
  interface-scaffold:
    concept: InterfaceScaffoldGen
    steps:
      - action: register
        title: "Register Generator"
        prose: "Self-register with PluginRegistry so KindSystem can track InterfaceConfig → InterfaceManifest transformations. Registration is also handled automatically by register-generator-kinds.sync."
      - action: preview
        title: "Preview Changes"
        prose: "Dry-run the generation using Emitter content-addressing to classify each output file as new, changed, or unchanged. No files are written."
      - action: generate
        title: "Generate Interface Manifest"
        prose: "Generate an interface.yaml manifest with target configurations (REST, GraphQL, gRPC, CLI, MCP, Claude Skills), SDK settings, spec outputs, and per-concept overrides. Sync rules then cascade: interface-scaffold-emit.sync routes files through Emitter, interface-scaffold-record-cache.sync records output in BuildCache, and interface-scaffold-observer.sync tracks the run in GenerationPlan."
    checklists:
      generate:
        - "Interface name is valid?"
        - "At least one target is specified?"
        - "Each target has sensible defaults?"
        - "SDK package names are unique per language?"
        - "Per-concept overrides reference valid concepts?"
        - "Grouping strategy is set?"
        - "All files written through Emitter (not directly to disk)?"
        - "Source provenance attached to each file?"
        - "Generation step recorded in GenerationPlan?"
    design-principles:
      - title: "Target Independence"
        rule: "Each target (REST, GraphQL, CLI, etc.) generates independently — they share concept specs but produce separate output trees."
      - title: "Layered Configuration"
        rule: "Configuration flows from global defaults → target defaults → per-concept overrides. Specific settings override general ones."
      - title: "SDK Completeness"
        rule: "Each SDK target should generate a fully-functional client library — types, methods, error handling, and documentation."
    references:
      - path: references/interface-manifest-schema.md
        label: "Interface manifest (interface.yaml) schema reference"
        tier: reference
        content: |
          # Interface Manifest Schema Reference

          Complete schema for `interface.yaml` manifest files.

          ## Root Structure

          ```yaml
          interface:
            name: my-api
            version: "0.1.0"
          ```

          ## Targets

          ```yaml
          targets:
            rest:
              basePath: /api
              framework: hono
              versioning: url
            graphql:
              path: /graphql
              relay: true
              subscriptions: true
            grpc:
              package: app.v1
            cli:
              name: my-cli
              shell: [bash, zsh, fish]
            mcp:
              name: my-mcp-server
              transport: stdio
            claude-skills:
              name: my-skills
              progressive: true
          ```

          ## SDKs

          ```yaml
          sdk:
            typescript:
              packageName: "@app/sdk"
              moduleSystem: esm
            python:
              packageName: app-sdk
              asyncSupport: true
            go:
              modulePath: github.com/org/app-sdk-go
            rust:
              packageName: app-sdk
            java:
              packageName: com.org.app.sdk
            swift:
              packageName: AppSDK
          ```

          ## Specs

          ```yaml
          specs:
            openapi: true
            asyncapi: false
          ```

          ## Per-Concept Overrides

          ```yaml
          concepts:
            User:
              rest:
                basePath: /api/users
              graphql:
                typeName: User
            Article:
              rest:
                basePath: /api/articles
          ```

          ## Output

          ```yaml
          output:
            dir: ./generated/interface
            clean: true
          grouping:
            strategy: per-concept
          ```
    validation-commands:
      - label: "Generate an interface scaffold"
        command: "npx tsx tools/copf-cli/src/index.ts scaffold interface --name my-api --targets rest,graphql"
      - label: "Generate interfaces from manifest"
        command: "npx tsx tools/copf-cli/src/index.ts interface generate --manifest my-api.interface.yaml"
      - label: "Run scaffold generator tests"
        command: "npx vitest run tests/scaffold-generators.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Input | Type | Purpose |
        |-------|------|---------|
        | name | String | Interface name |
        | targets | list String | Target types (rest, graphql, grpc, cli, mcp, claude-skills) |
        | sdks | list String | SDK languages (typescript, python, go, rust, java, swift) |
        | concepts | list String | Concepts with per-concept overrides |
        | openapi | Boolean | Generate OpenAPI spec (default: true) |
        | asyncapi | Boolean | Generate AsyncAPI spec (default: false) |
    related-workflows:
      - name: kit-scaffold
        description: "Generate kits whose concepts the interface exposes"
      - name: concept-scaffold
        description: "Generate concept specs for interface concepts"
      - name: deployment-config
        description: "Deploy the service that hosts the generated interface"
    anti-patterns:
      - title: "Targets without concept overrides"
        description: "All concepts use the same REST base path — collision risk."
        bad: |
          targets:
            rest: { basePath: /api }
          # No per-concept overrides — all concepts share /api
        good: |
          targets:
            rest: { basePath: /api }
          concepts:
            User:
              rest: { basePath: /api/users }
            Article:
              rest: { basePath: /api/articles }

  # ─── ConceptScaffoldGen: concept-scaffold ──────────
  concept-scaffold:
    concept: ConceptScaffoldGen
    steps:
      - action: register
        title: "Register Generator"
        prose: "Self-register with PluginRegistry so KindSystem can track ConceptConfig → ConceptSpec transformations. Registration is also handled automatically by register-generator-kinds.sync."
      - action: preview
        title: "Preview Changes"
        prose: "Dry-run the generation using Emitter content-addressing to classify each output file as new, changed, or unchanged. No files are written."
      - action: generate
        title: "Generate Concept Spec"
        prose: "Generate a .concept specification file with purpose block, typed state declarations, action signatures with variants, and a register() action for PluginRegistry discovery. Sync rules then cascade: concept-scaffold-emit.sync routes files through Emitter, concept-scaffold-record-cache.sync records output in BuildCache, and concept-scaffold-observer.sync tracks the run in GenerationPlan."
    checklists:
      generate:
        - "Concept name is PascalCase?"
        - "Type parameter is a single capital letter?"
        - "Purpose block describes why, not what?"
        - "State fields use correct relation types (set, ->, option, list)?"
        - "Every action has at least one variant?"
        - "register() action is included for PluginRegistry?"
        - "Annotations (@category, @visibility) are present?"
        - "All files written through Emitter (not directly to disk)?"
        - "Source provenance attached to each file?"
        - "Generation step recorded in GenerationPlan?"
    design-principles:
      - title: "Singularity"
        rule: "Each concept serves exactly one purpose — if the purpose has 'and', it's two concepts."
      - title: "Independence"
        rule: "A concept never references another concept's types or calls another concept's actions. Use type parameters and syncs."
      - title: "Sufficiency & Necessity"
        rule: "Every state field is needed by at least one action. Every action serves the concept's purpose. No dead state."
      - title: "Invariant Completeness"
        rule: "Key properties are captured as formal invariants documenting what must be true after each action."
    references:
      - path: references/concept-spec-guide.md
        label: "Concept specification writing guide"
        tier: reference
        content: |
          # Concept Specification Guide

          How to write well-formed `.concept` files.

          ## Structure

          ```
          @category("domain")
          @visibility("public")
          concept Name [T] {
            purpose { ... }
            state { ... }
            actions { ... }
            invariant { ... }
          }
          ```

          ## State Relations

          | Syntax | Meaning | Example |
          |--------|---------|---------|
          | `set T` | Collection | `users: set U` |
          | `T -> V` | Total function | `name: U -> String` |
          | `T -> option V` | Partial function | `email: U -> option String` |
          | `T -> list V` | Multi-valued | `tags: U -> list String` |

          ## Action Signatures

          ```
          action create(name: String, email: String) {
            description { Create a new user. }
            -> ok(user: U) { User created. }
            -> duplicate(email: String) { Email already registered. }
            -> error(message: String) { Creation failed. }
          }
          ```

          **Rules:**
          - Every parameter must have a type
          - At least one variant per action
          - Variant names are lowercase
          - `ok` is the conventional success variant

          ## Register Action

          Every generator concept includes `register()`:

          ```
          action register() {
            -> ok(name: String, inputKind: String, outputKind: String,
                  capabilities: list String) {
              Return static metadata for PluginRegistry.
            }
          }
          ```

          ## Invariants

          ```
          invariant {
            after create(name: "alice") -> ok(user: u)
            then create(name: "alice") -> duplicate(email: _)
          }
          ```
    validation-commands:
      - label: "Generate a concept scaffold"
        command: "npx tsx tools/copf-cli/src/index.ts scaffold concept --name User --actions create,update,delete"
      - label: "Validate generated concept"
        command: "npx tsx tools/copf-cli/src/index.ts check specs/app/user.concept"
      - label: "Run scaffold generator tests"
        command: "npx vitest run tests/scaffold-generators.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Input | Type | Purpose |
        |-------|------|---------|
        | name | String | PascalCase concept name |
        | typeParam | String | Type parameter letter (default: T) |
        | purpose | String | Purpose description |
        | category | String | Annotation category (domain, devtools, etc.) |
        | stateFields | list StateField | State declarations |
        | actions | list ActionDef | Action signatures with variants |
    related-workflows:
      - name: concept-designer
        description: "Design concepts using Jackson's methodology before generating"
      - name: handler-scaffold
        description: "Generate handler implementations for the concept"
      - name: sync-scaffold
        description: "Generate sync rules connecting the concept"
    anti-patterns:
      - title: "Purpose describes implementation"
        description: "Purpose block says how the concept works instead of why it exists."
        bad: |
          purpose {
            Store users in a Map<string, User> and provide CRUD operations
            via async handler methods.
          }
        good: |
          purpose {
            Manage user identity and profile information.
          }
      - title: "Missing variants"
        description: "Action only has ok variant — no error handling path."
        bad: |
          action create(name: String) {
            -> ok(user: U) { Created. }
          }
        good: |
          action create(name: String) {
            -> ok(user: U) { Created. }
            -> duplicate(name: String) { Name taken. }
            -> error(message: String) { Failed. }
          }

  # ─── SyncScaffoldGen: sync-scaffold ────────────────
  sync-scaffold:
    concept: SyncScaffoldGen
    steps:
      - action: register
        title: "Register Generator"
        prose: "Self-register with PluginRegistry so KindSystem can track SyncConfig → SyncSpec transformations. Registration is also handled automatically by register-generator-kinds.sync."
      - action: preview
        title: "Preview Changes"
        prose: "Dry-run the generation using Emitter content-addressing to classify each output file as new, changed, or unchanged. No files are written."
      - action: generate
        title: "Generate Sync Rule"
        prose: "Generate a .sync file with when clause (trigger pattern), optional where clause (guard conditions), and then clause (effect actions). Sync rules then cascade: sync-scaffold-emit.sync routes files through Emitter, sync-scaffold-record-cache.sync records output in BuildCache, and sync-scaffold-observer.sync tracks the run in GenerationPlan."
    checklists:
      generate:
        - "Sync name is PascalCase?"
        - "Tier annotation matches intended behavior ([eager], [required], [recommended])?"
        - "When clause references a valid concept/action?"
        - "Variable bindings in where clause use ?prefix?"
        - "Then clause references a valid concept/action?"
        - "Purpose statement explains why the sync exists?"
        - "All files written through Emitter (not directly to disk)?"
        - "Source provenance attached to each file?"
        - "Generation step recorded in GenerationPlan?"
    design-principles:
      - title: "Declarative Wiring"
        rule: "Syncs declare what happens when — they never contain imperative logic, loops, or conditionals beyond pattern matching."
      - title: "Concept Independence"
        rule: "Syncs reference concepts by name but concepts never know about syncs. The sync is the only place where concept names appear together."
      - title: "Pattern Completeness"
        rule: "The when clause must match specific action completions (concept/action with variant). The then clause invokes specific actions."
    references:
      - path: references/sync-rule-guide.md
        label: "Sync rule writing guide"
        tier: reference
        content: |
          # Sync Rule Guide

          How to write well-formed `.sync` files.

          ## Structure

          ```
          sync SyncName [eager]
            purpose { Why this sync exists. }
          when {
            SourceConcept/action: [
              field: ?var
            ] => ok(result: ?value)
          }
          where {
            bind(?var.property as ?local)
            query(OtherConcept/find: [criteria: ?local] as ?results)
            any(?local = "value1"; ?local = "value2")
            not(?local = "forbidden")
          }
          then {
            TargetConcept/action: [
              field: ?var;
              other: ?local
            ]
          }
          ```

          ## When Clause

          Matches completions of concept actions:
          - `Concept/action: [params] => variant(results)`
          - Variables use `?` prefix: `?user`, `?name`
          - Can destructure: `metadata: ?meta`

          ## Where Clause (optional)

          Guard conditions:
          - `bind(?expr as ?local)` — Extract nested values
          - `query(Concept/action: [...] as ?result)` — Query state
          - `any(cond1; cond2)` — OR conditions
          - `not(cond)` — Negation
          - `?a = ?b` — Equality check

          ## Then Clause

          Actions to invoke:
          - `Concept/action: [field: ?var]`
          - Multiple actions allowed
          - Variables from when/where are available

          ## Tier Annotations

          | Annotation | Meaning |
          |-----------|---------|
          | `[eager]` | Fires immediately (same as required) |
          | `[required]` | Cannot be disabled or overridden |
          | `[recommended]` | Can be overridden by application |
    validation-commands:
      - label: "Generate a sync scaffold"
        command: "npx tsx tools/copf-cli/src/index.ts scaffold sync --name CreateProfile --from User/create --to Profile/init"
      - label: "Validate generated sync"
        command: "npx tsx tools/copf-cli/src/index.ts sync validate syncs/create-profile.sync"
      - label: "Run scaffold generator tests"
        command: "npx vitest run tests/scaffold-generators.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Input | Type | Purpose |
        |-------|------|---------|
        | name | String | PascalCase sync name |
        | tier | String | Sync tier (required, recommended) |
        | eager | Boolean | Fire immediately (default: true) |
        | trigger | Trigger | When clause (concept, action, params, variant) |
        | conditions | list Condition | Where clause guards |
        | effects | list Effect | Then clause actions |
    related-workflows:
      - name: sync-designer
        description: "Design syncs using formal patterns before generating"
      - name: concept-scaffold
        description: "Generate concept specs referenced by the sync"
      - name: sync-validator
        description: "Validate compiled syncs"
    anti-patterns:
      - title: "Sync with imperative logic"
        description: "Sync tries to express conditionals or loops instead of pattern matching."
        bad: |
          # Pseudo-code in sync — not valid!
          if user.isAdmin then
            AdminPanel/grant: [user: ?u]
        good: |
          where {
            bind(?meta.role as ?role)
            any(?role = "admin")
          }
          then {
            AdminPanel/grant: [user: ?u]
          }

  # ─── HandlerScaffoldGen: handler-scaffold ──────────
  handler-scaffold:
    concept: HandlerScaffoldGen
    steps:
      - action: register
        title: "Register Generator"
        prose: "Self-register with PluginRegistry so KindSystem can track HandlerConfig → HandlerImpl transformations. Registration is also handled automatically by register-generator-kinds.sync."
      - action: preview
        title: "Preview Changes"
        prose: "Dry-run the generation using Emitter content-addressing to classify each output file as new, changed, or unchanged. No files are written."
      - action: generate
        title: "Generate Handler Implementation"
        prose: "Generate a TypeScript .impl.ts handler with register() action, typed action methods, input extraction, storage patterns, and an optional conformance test. Sync rules then cascade: handler-scaffold-emit.sync routes files through Emitter, handler-scaffold-record-cache.sync records output in BuildCache, and handler-scaffold-observer.sync tracks the run in GenerationPlan."
    checklists:
      generate:
        - "Handler export name follows convention (camelCase + 'Handler')?"
        - "register() returns correct name, inputKind, outputKind?"
        - "Each action extracts input parameters with correct types?"
        - "Each action returns all declared variants?"
        - "Storage operations use correct relation names?"
        - "Error handling catches and wraps exceptions?"
        - "Conformance test covers register() and each action?"
        - "All files written through Emitter (not directly to disk)?"
        - "Source provenance attached to each file?"
        - "Generation step recorded in GenerationPlan?"
    design-principles:
      - title: "One Handler per Action"
        rule: "Each action in the concept spec maps to exactly one async method in the handler."
      - title: "Variant Completeness"
        rule: "Every return variant declared in the spec must have a corresponding code path — no missing branches."
      - title: "Storage Sovereignty"
        rule: "Each concept owns its storage exclusively — no shared databases, no cross-concept state access."
      - title: "Input Extraction"
        rule: "Extract inputs with `as` casts at the top of each method. Validate required fields before processing."
    references:
      - path: references/handler-implementation-guide.md
        label: "Handler implementation patterns"
        tier: reference
        content: |
          # Handler Implementation Guide

          How to implement COPF concept handlers in TypeScript.

          ## ConceptHandler Interface

          ```typescript
          interface ConceptHandler {
            [actionName: string]: (
              input: Record<string, unknown>,
              storage: ConceptStorage,
            ) => Promise<{ variant: string; [key: string]: unknown }>;
          }
          ```

          ## Standard Pattern

          ```typescript
          export const myConceptHandler: ConceptHandler = {
            async register() {
              return {
                variant: 'ok',
                name: 'MyConcept',
                inputKind: 'MyInput',
                outputKind: 'MyOutput',
                capabilities: JSON.stringify(['cap1', 'cap2']),
              };
            },

            async create(input, storage) {
              const name = input.name as string;
              if (!name) return { variant: 'error', message: 'name required' };

              try {
                const id = crypto.randomUUID();
                await storage.put('items', id, { id, name });
                return { variant: 'ok', item: id };
              } catch (err) {
                const msg = err instanceof Error ? err.message : String(err);
                return { variant: 'error', message: msg };
              }
            },
          };
          ```

          ## Storage Patterns

          | Operation | Method | Example |
          |-----------|--------|---------|
          | Create/Update | `storage.put(rel, key, value)` | `put('items', id, data)` |
          | Read | `storage.get(rel, key)` | `get('items', id)` |
          | Query | `storage.find(rel, criteria)` | `find('items', { status: 'active' })` |
          | Delete | `storage.del(rel, key)` | `del('items', id)` |
          | Bulk delete | `storage.delMany(rel, criteria)` | `delMany('items', { expired: true })` |

          ## Type Mapping

          | Concept Type | TypeScript Type |
          |-------------|----------------|
          | String | string |
          | Int | number |
          | Bool | boolean |
          | list T | T[] |
          | set T | Map<string, T> |
          | option T | T \| undefined |
    validation-commands:
      - label: "Generate a handler scaffold"
        command: "npx tsx tools/copf-cli/src/index.ts scaffold handler --concept User --actions create,update,delete"
      - label: "Run generated conformance test"
        command: "npx vitest run tests/user.conformance.test.ts"
      - label: "Run scaffold generator tests"
        command: "npx vitest run tests/scaffold-generators.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Input | Type | Purpose |
        |-------|------|---------|
        | conceptName | String | PascalCase concept name |
        | actions | list ActionDef | Action signatures with params and variants |
        | inputKind | String | KindSystem input kind |
        | outputKind | String | KindSystem output kind |
        | capabilities | list String | Generator capabilities |
    related-workflows:
      - name: concept-scaffold
        description: "Generate concept specs before implementing handlers"
      - name: implementation-builder
        description: "Use SchemaGen for more advanced handler generation"
      - name: concept-validator
        description: "Validate concept specs before generating handlers"
    anti-patterns:
      - title: "Missing error variant"
        description: "Handler doesn't return error variant on failure — caller gets an unstructured exception."
        bad: |
          async create(input, storage) {
            const id = crypto.randomUUID();
            await storage.put('items', id, { name: input.name });
            return { variant: 'ok', item: id };
            // Exception propagates raw if storage.put fails!
          }
        good: |
          async create(input, storage) {
            try {
              const id = crypto.randomUUID();
              await storage.put('items', id, { name: input.name });
              return { variant: 'ok', item: id };
            } catch (err) {
              return { variant: 'error', message: String(err) };
            }
          }

  # ─── StorageAdapterScaffoldGen: storage-adapter-scaffold ─
  storage-adapter-scaffold:
    concept: StorageAdapterScaffoldGen
    steps:
      - action: register
        title: "Register Generator"
        prose: "Self-register with PluginRegistry so KindSystem can track StorageConfig → StorageAdapter transformations. Registration is also handled automatically by register-generator-kinds.sync."
      - action: preview
        title: "Preview Changes"
        prose: "Dry-run the generation using Emitter content-addressing to classify each output file as new, changed, or unchanged. No files are written."
      - action: generate
        title: "Generate Storage Adapter"
        prose: "Generate a ConceptStorage adapter implementation for the specified backend (SQLite, PostgreSQL, Redis, DynamoDB, or in-memory) with put, get, find, del, and delMany methods. Sync rules then cascade: storage-adapter-scaffold-emit.sync routes files through Emitter, storage-adapter-scaffold-record-cache.sync records output in BuildCache, and storage-adapter-scaffold-observer.sync tracks the run in GenerationPlan."
    checklists:
      generate:
        - "Backend is valid (sqlite, postgresql, redis, dynamodb, memory)?"
        - "Adapter class implements ConceptStorage interface?"
        - "All five methods (put, get, find, del, delMany) are implemented?"
        - "Constructor accepts backend-specific configuration?"
        - "Find method supports criteria-based filtering?"
        - "Proper serialization (JSON.stringify/parse) for non-native types?"
        - "All files written through Emitter (not directly to disk)?"
        - "Source provenance attached to each file?"
        - "Generation step recorded in GenerationPlan?"
    design-principles:
      - title: "Interface Compliance"
        rule: "Every adapter must implement all five ConceptStorage methods — put, get, find, del, delMany. No optional methods."
      - title: "Backend Transparency"
        rule: "Concept handlers use storage through the interface without knowing which backend is active. Swapping backends requires no handler changes."
      - title: "Relation-Key Namespace"
        rule: "Storage is organized by relation name and key. Each concept uses its own relation names, preventing cross-concept conflicts."
    references:
      - path: references/storage-adapter-guide.md
        label: "Storage adapter implementation guide"
        tier: reference
        content: |
          # Storage Adapter Guide

          How to implement ConceptStorage adapters for different backends.

          ## ConceptStorage Interface

          ```typescript
          interface ConceptStorage {
            put(relation: string, key: string, value: Record<string, unknown>): Promise<void>;
            get(relation: string, key: string): Promise<Record<string, unknown> | null>;
            find(relation: string, criteria?: Record<string, unknown>): Promise<Record<string, unknown>[]>;
            del(relation: string, key: string): Promise<void>;
            delMany(relation: string, criteria: Record<string, unknown>): Promise<number>;
          }
          ```

          ## Backend Comparison

          | Backend | Best For | Persistence | Query Power |
          |---------|----------|-------------|-------------|
          | memory | Tests, prototypes | None | In-memory filter |
          | sqlite | Single-node, embedded | File | SQL |
          | postgresql | Production, multi-node | Server | Full SQL |
          | redis | Caching, sessions | Optional | Key-value |
          | dynamodb | Serverless, high-scale | Managed | Key + query |

          ## SQLite Example

          ```typescript
          class SqliteStorage implements ConceptStorage {
            private db: Database;

            constructor(dbPath: string) {
              this.db = new Database(dbPath);
              this.db.exec(`
                CREATE TABLE IF NOT EXISTS concept_store (
                  relation TEXT NOT NULL,
                  key TEXT NOT NULL,
                  value TEXT NOT NULL,
                  PRIMARY KEY (relation, key)
                )
              `);
            }

            async put(relation, key, value) {
              this.db.prepare(
                'INSERT OR REPLACE INTO concept_store VALUES (?, ?, ?)'
              ).run(relation, key, JSON.stringify(value));
            }
            // ... other methods
          }
          ```
    validation-commands:
      - label: "Generate a storage adapter"
        command: "npx tsx tools/copf-cli/src/index.ts scaffold storage --name AppStorage --backend postgresql"
      - label: "Run scaffold generator tests"
        command: "npx vitest run tests/scaffold-generators.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Input | Type | Purpose |
        |-------|------|---------|
        | name | String | Adapter class name (PascalCase) |
        | backend | String | Backend type (sqlite, postgresql, redis, dynamodb, memory) |

        | Backend | Import | Constructor |
        |---------|--------|-------------|
        | sqlite | better-sqlite3 | `new SqliteStorage(dbPath)` |
        | postgresql | pg | `new PgStorage(connectionString)` |
        | redis | redis | `new RedisStorage(url)` |
        | dynamodb | @aws-sdk/client-dynamodb | `new DynamoStorage(region, table)` |
        | memory | (none) | `new MemoryStorage()` |
    related-workflows:
      - name: deployment-config
        description: "Configure storage backends in deploy manifests"
      - name: handler-scaffold
        description: "Generate handlers that use the storage adapter"
    anti-patterns:
      - title: "Missing find criteria filtering"
        description: "Find method ignores criteria parameter — returns all records regardless."
        bad: |
          async find(relation) {
            return this.db.all('SELECT * FROM store WHERE relation = ?', relation);
          }
        good: |
          async find(relation, criteria?) {
            let results = this.db.all('SELECT * FROM store WHERE relation = ?', relation);
            if (criteria) {
              results = results.filter(r =>
                Object.entries(criteria).every(([k, v]) => r[k] === v)
              );
            }
            return results;
          }

  # ─── TransportAdapterScaffoldGen: transport-adapter-scaffold ─
  transport-adapter-scaffold:
    concept: TransportAdapterScaffoldGen
    steps:
      - action: register
        title: "Register Generator"
        prose: "Self-register with PluginRegistry so KindSystem can track TransportConfig → TransportAdapter transformations. Registration is also handled automatically by register-generator-kinds.sync."
      - action: preview
        title: "Preview Changes"
        prose: "Dry-run the generation using Emitter content-addressing to classify each output file as new, changed, or unchanged. No files are written."
      - action: generate
        title: "Generate Transport Adapter"
        prose: "Generate a transport adapter implementation for the specified protocol (HTTP, WebSocket, Worker, or in-process) with invoke, query, and health methods. Sync rules then cascade: transport-adapter-scaffold-emit.sync routes files through Emitter, transport-adapter-scaffold-record-cache.sync records output in BuildCache, and transport-adapter-scaffold-observer.sync tracks the run in GenerationPlan."
    checklists:
      generate:
        - "Protocol is valid (http, websocket, worker, in-process)?"
        - "Adapter implements invoke(), query(), and health()?"
        - "HTTP adapter uses fetch with proper error handling?"
        - "WebSocket adapter manages connection lifecycle?"
        - "Worker adapter handles message passing?"
        - "In-process adapter dispatches to registered handlers?"
        - "All files written through Emitter (not directly to disk)?"
        - "Source provenance attached to each file?"
        - "Generation step recorded in GenerationPlan?"
    design-principles:
      - title: "Protocol Transparency"
        rule: "Concept handlers call invoke/query without knowing the transport. Swapping from HTTP to WebSocket requires no handler changes."
      - title: "Health Monitoring"
        rule: "Every adapter provides a health() method that returns latency and status — enables the framework to detect and route around failures."
      - title: "Connection Lifecycle"
        rule: "Stateful transports (WebSocket, Worker) manage their own connection lifecycle — connect on first use, reconnect on failure, clean up on dispose."
    references:
      - path: references/transport-adapter-guide.md
        label: "Transport adapter implementation guide"
        tier: reference
        content: |
          # Transport Adapter Guide

          How to implement transport adapters for different protocols.

          ## Transport Interface

          ```typescript
          interface ConceptTransport {
            invoke(concept: string, action: string,
                   input: Record<string, unknown>): Promise<Record<string, unknown>>;
            query(concept: string, relation: string,
                  criteria?: Record<string, unknown>): Promise<Record<string, unknown>[]>;
            health(): Promise<{ ok: boolean; latencyMs: number }>;
          }
          ```

          ## Protocol Comparison

          | Protocol | Bidirectional | Latency | Best For |
          |----------|--------------|---------|----------|
          | http | No | Medium | REST APIs, microservices |
          | websocket | Yes | Low | Real-time, subscriptions |
          | worker | No | Very Low | Same-machine parallelism |
          | in-process | N/A | None | Testing, monoliths |

          ## HTTP Adapter

          ```typescript
          async invoke(concept, action, input) {
            const url = `${this.baseUrl}/concepts/${concept}/${action}`;
            const response = await fetch(url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(input),
            });
            return response.json();
          }
          ```

          ## WebSocket Adapter

          Uses request/response correlation with message IDs:
          1. Send `{ id, concept, action, input }` as JSON
          2. Receive `{ id, result }` — match by ID
          3. Resolve the pending promise

          ## When to Use Each

          - **Same runtime**: Use `in-process` — zero overhead
          - **Same machine**: Use `worker` — parallel execution
          - **Same network**: Use `http` — simple and reliable
          - **Real-time**: Use `websocket` — bidirectional streaming
    validation-commands:
      - label: "Generate a transport adapter"
        command: "npx tsx tools/copf-cli/src/index.ts scaffold transport --name ApiTransport --protocol http"
      - label: "Run scaffold generator tests"
        command: "npx vitest run tests/scaffold-generators.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Input | Type | Purpose |
        |-------|------|---------|
        | name | String | Adapter class name (PascalCase) |
        | protocol | String | Protocol (http, websocket, worker, in-process) |
        | baseUrl | String | Base URL for HTTP/WS (default: http://localhost:3000) |
    related-workflows:
      - name: deployment-config
        description: "Configure transport adapters in deploy manifests"
      - name: storage-adapter-scaffold
        description: "Generate storage adapters alongside transport adapters"
    anti-patterns:
      - title: "Missing health check"
        description: "Transport adapter has no health() method — framework can't detect failures."
        bad: |
          class MyTransport {
            async invoke(...) { ... }
            async query(...) { ... }
            // No health()!
          }
        good: |
          class MyTransport {
            async invoke(...) { ... }
            async query(...) { ... }
            async health() {
              const start = Date.now();
              try {
                await fetch(`${this.baseUrl}/health`);
                return { ok: true, latencyMs: Date.now() - start };
              } catch {
                return { ok: false, latencyMs: Date.now() - start };
              }
            }
          }

  # ─── CoifComponentScaffoldGen: coif-component-scaffold ─
  coif-component-scaffold:
    concept: CoifComponentScaffoldGen
    steps:
      - action: register
        title: "Register Generator"
        prose: "Self-register with PluginRegistry so KindSystem can track ComponentConfig → CoifComponent transformations. Registration is also handled automatically by register-generator-kinds.sync."
      - action: preview
        title: "Preview Changes"
        prose: "Dry-run the generation using Emitter content-addressing to classify each output file as new, changed, or unchanged. No files are written."
      - action: generate
        title: "Generate COIF Component"
        prose: "Generate a complete headless component scaffold including widget specification (FSM), anatomy definition (parts contract), machine implementation, and kit manifest. Sync rules then cascade: coif-component-scaffold-emit.sync routes files through Emitter, coif-component-scaffold-record-cache.sync records output in BuildCache, and coif-component-scaffold-observer.sync tracks the run in GenerationPlan."
    checklists:
      generate:
        - "Component name is PascalCase?"
        - "Parts list defines all structural elements?"
        - "States define all machine states?"
        - "Events define all transitions?"
        - "Anatomy lists all parts and slots?"
        - "Machine implementation has spawn, send, connect, destroy actions?"
        - "Kit manifest declares dependencies on coif-core and coif-component?"
        - "All files written through Emitter (not directly to disk)?"
        - "Source provenance attached to each file?"
        - "Generation step recorded in GenerationPlan?"
    design-principles:
      - title: "Behavior-Rendering Separation"
        rule: "Widget specs define behavior (states, transitions, guards). Rendering is handled by framework adapters. They agree only on part names (anatomy)."
      - title: "Finite State Machine Discipline"
        rule: "Every component is a finite state machine with explicit states, events, transitions, and guards. No implicit state."
      - title: "Anatomy Contract"
        rule: "The anatomy defines named parts (root, trigger, content, etc.) that both the machine and renderer reference. This is the only coupling point."
      - title: "Props API via connect()"
        rule: "The machine's connect() action transforms internal state into framework-neutral props objects — one per anatomy part."
    references:
      - path: references/coif-component-guide.md
        label: "COIF headless component architecture"
        tier: reference
        content: |
          # COIF Component Architecture

          How headless components work in the Concept-Oriented Interface Framework.

          ## Pipeline

          ```
          Concept Spec → Binding → UISchema → Element Tree
                                                    ↓
                                        Widget Registry (query)
                                                    ↓
                                        Machine (spawn + FSM)
                                                    ↓
                                        connect() → Props API
                                                    ↓
                                        Framework Adapter (React, Vue, etc.)
          ```

          ## Widget Specification

          ```
          widget Dialog {
            anatomy {
              part root
              part trigger
              part backdrop
              part content
              part title
              part description
              part closeTrigger
            }

            machine {
              initial: closed

              state closed {
                on open -> open
              }
              state open {
                on close -> closed
                on escape -> closed
              }
            }

            config {
              closeOnEsc: true
              closeOnOutsideClick: true
              modal: true
            }

            connect {
              rootProps { role: "dialog"; aria-modal: context.modal }
              triggerProps { onClick: actions.open }
              contentProps { data-state: context.state }
              closeTriggerProps { onClick: actions.close }
            }

            accessibility {
              role: "dialog"
              aria-modal: true
              aria-labelledby: titleId
              aria-describedby: descriptionId
            }
          }
          ```

          ## Standard Components

          | Component | Parts | States | Pattern |
          |-----------|-------|--------|---------|
          | Button | root | idle, pressed, disabled | Simple trigger |
          | Dialog | root, trigger, backdrop, content, title, close | closed, open | Overlay |
          | Tabs | root, list, trigger, content, indicator | idle, focused | Selection |
          | Accordion | root, item, trigger, content | collapsed, expanded | Disclosure |
          | Menu | root, trigger, content, item, separator | closed, open | Popup |
          | Tooltip | root, trigger, content, arrow | hidden, visible | Overlay |
          | Select | root, trigger, content, item, indicator | closed, open | Selection |
          | Slider | root, track, range, thumb | idle, dragging | Range |
    validation-commands:
      - label: "Generate a COIF component scaffold"
        command: "npx tsx tools/copf-cli/src/index.ts scaffold component --name Dialog --parts root,trigger,content --states closed,open"
      - label: "Run scaffold generator tests"
        command: "npx vitest run tests/scaffold-generators.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Input | Type | Purpose |
        |-------|------|---------|
        | name | String | PascalCase component name |
        | parts | list String | Anatomy part names (root, trigger, content, etc.) |
        | slots | list String | Named slot insertion points |
        | states | list String | FSM state names |
        | events | list String | FSM event names |
        | a11y | { role, ariaProps } | Accessibility configuration |

        **Output Files:**
        | File | Purpose |
        |------|---------|
        | `{name}-widget.concept` | Widget FSM specification |
        | `{name}-anatomy.concept` | Parts contract definition |
        | `kit.yaml` | Kit manifest with dependencies |
        | `{name}-machine.impl.ts` | Machine handler implementation |
    related-workflows:
      - name: coif-theme-scaffold
        description: "Generate themes to style the component"
      - name: concept-scaffold
        description: "Generate concept specs for custom component concepts"
      - name: kit-scaffold
        description: "Generate kit manifests for component libraries"
    anti-patterns:
      - title: "Rendering logic in widget spec"
        description: "Widget spec includes CSS, HTML, or framework-specific code — violates behavior-rendering separation."
        bad: |
          widget Dialog {
            render {
              <div class="dialog-overlay">  # HTML in spec!
                <div class="dialog-content">...</div>
              </div>
            }
          }
        good: |
          widget Dialog {
            anatomy {
              part root        # Just names — rendering
              part backdrop    # is the adapter's job
              part content
            }
          }
      - title: "Implicit state transitions"
        description: "Component changes state without explicit events — makes behavior unpredictable."
        bad: |
          machine {
            state open {
              # Implicitly closes after 5 seconds — not declarative!
              after 5000ms -> closed
            }
          }
        good: |
          machine {
            state open {
              on close -> closed
              on timeout -> closed  # Explicit event
            }
          }

  # ─── CoifThemeScaffoldGen: coif-theme-scaffold ─────
  coif-theme-scaffold:
    concept: CoifThemeScaffoldGen
    steps:
      - action: register
        title: "Register Generator"
        prose: "Self-register with PluginRegistry so KindSystem can track ThemeConfig → CoifTheme transformations. Registration is also handled automatically by register-generator-kinds.sync."
      - action: preview
        title: "Preview Changes"
        prose: "Dry-run the generation using Emitter content-addressing to classify each output file as new, changed, or unchanged. No files are written."
      - action: generate
        title: "Generate COIF Theme"
        prose: "Generate a complete design system theme scaffold including palette configuration (OKLCH color scales with WCAG contrast), typography scale (modular ratio), motion definitions (with reduced-motion support), elevation scale (shadow layers), and light/dark theme manifests. Sync rules then cascade: coif-theme-scaffold-emit.sync routes files through Emitter, coif-theme-scaffold-record-cache.sync records output in BuildCache, and coif-theme-scaffold-observer.sync tracks the run in GenerationPlan."
    checklists:
      generate:
        - "Theme name is kebab-case?"
        - "Primary color generates full 50-950 scale?"
        - "Palette has semantic roles (primary, secondary, error, etc.)?"
        - "WCAG contrast ratios meet AA standard (4.5:1 normal, 3:1 large)?"
        - "Typography uses modular ratio scale?"
        - "Motion respects prefers-reduced-motion?"
        - "Elevation scale covers 0-5 levels?"
        - "Light and dark themes are generated (if mode=both)?"
        - "All files written through Emitter (not directly to disk)?"
        - "Source provenance attached to each file?"
        - "Generation step recorded in GenerationPlan?"
    design-principles:
      - title: "Token-Based Design"
        rule: "Every visual value is a named design token — no hardcoded colors, sizes, or shadows anywhere in component code."
      - title: "WCAG Compliance"
        rule: "Every color pair must meet WCAG 2.1 AA contrast (4.5:1 normal text, 3:1 large text). The generator validates at generation time."
      - title: "Reduced Motion Respect"
        rule: "All motion durations collapse to 0ms when prefers-reduced-motion is active. This is built into the motion token system, not opt-in."
      - title: "Theme Layering"
        rule: "Themes are layered: base + variants. Multiple variants can be active simultaneously, resolved by priority then activation order."
    references:
      - path: references/coif-theme-guide.md
        label: "COIF design system and theme architecture"
        tier: reference
        content: |
          # COIF Theme Architecture

          How the design system works in the Concept-Oriented Interface Framework.

          ## Token Hierarchy

          ```
          Primitive Tokens     →  Semantic Tokens    →  Component Tokens
          color.blue.500           color.primary          button.background
          font.size.base           font.body              input.fontSize
          spacing.4                spacing.md             card.padding
          ```

          ## Palette Generation

          Colors are generated from a seed hue using OKLCH perceptual color space:

          ```json
          {
            "primary": {
              "seed": "220",
              "scale": {
                "50": "hsl(220, 65%, 97%)",
                "100": "hsl(220, 65%, 93%)",
                "500": "hsl(220, 65%, 50%)",
                "900": "hsl(220, 65%, 18%)",
                "950": "hsl(220, 65%, 12%)"
              },
              "roles": {
                "default": "500",
                "hover": "600",
                "active": "700",
                "subtle": "100"
              }
            }
          }
          ```

          ## Typography Scale

          Uses modular ratio (default: major third, 1.25):

          | Name | Scale Factor | Size (16px base) |
          |------|-------------|------------------|
          | xs | 0.64 | 10.24px |
          | sm | 0.80 | 12.80px |
          | base | 1.00 | 16.00px |
          | lg | 1.25 | 20.00px |
          | xl | 1.56 | 25.00px |
          | 2xl | 1.95 | 31.25px |
          | 3xl | 2.44 | 39.06px |

          ## Motion System

          ```json
          {
            "durations": {
              "instant": "0ms",
              "fast": "100ms",
              "normal": "200ms",
              "slow": "300ms"
            },
            "reducedMotion": {
              "respectPreference": true,
              "fallbackDuration": "0ms"
            }
          }
          ```

          ## Elevation Scale

          | Level | Use Case | Shadow |
          |-------|----------|--------|
          | 0 | Flat | none |
          | 1 | Raised (card) | subtle |
          | 2 | Floating (dropdown) | medium |
          | 3 | Overlay (popover) | strong |
          | 4 | Modal (dialog) | heavy |
          | 5 | Top (toast) | maximum |

          ## WCAG Contrast Requirements

          | Standard | Normal Text | Large Text |
          |----------|------------|------------|
          | AA | 4.5:1 | 3:1 |
          | AAA | 7:1 | 4.5:1 |
    validation-commands:
      - label: "Generate a COIF theme scaffold"
        command: "npx tsx tools/copf-cli/src/index.ts scaffold theme --name ocean --primary 220 --font 'Inter, sans-serif'"
      - label: "Run scaffold generator tests"
        command: "npx vitest run tests/scaffold-generators.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Input | Type | Purpose |
        |-------|------|---------|
        | name | String | Theme name (kebab-case) |
        | primaryColor | String | Primary color hue or hex value |
        | secondaryColor | String | Secondary color hue or hex |
        | fontFamily | String | Primary font stack |
        | baseSize | Int | Base font size in pixels (default: 16) |
        | scale | Float | Modular ratio (default: 1.25 major third) |
        | borderRadius | String | Default border radius |
        | mode | String | light, dark, or both (default: both) |

        **Output Files:**
        | File | Purpose |
        |------|---------|
        | `kit.yaml` | Theme kit manifest |
        | `themes/{name}-light.json` | Light theme tokens |
        | `themes/{name}-dark.json` | Dark theme tokens |
        | `tokens/palette.json` | Color scale configuration |
        | `tokens/typography.json` | Type scale and font stacks |
        | `tokens/motion.json` | Animation timing and easing |
        | `tokens/elevation.json` | Shadow scale |
    related-workflows:
      - name: coif-component-scaffold
        description: "Generate components to use the theme tokens"
      - name: kit-scaffold
        description: "Generate kit manifests for theme packages"
    anti-patterns:
      - title: "Hardcoded colors in components"
        description: "Component uses raw hex values instead of design tokens."
        bad: |
          .button { background: #3b82f6; color: #ffffff; }
        good: |
          .button {
            background: var(--color-primary);
            color: var(--color-on-primary);
          }
      - title: "Ignoring reduced motion"
        description: "Animations play regardless of prefers-reduced-motion setting."
        bad: |
          .dialog { transition: transform 300ms ease; }
        good: |
          .dialog {
            transition: transform var(--motion-duration-slow) var(--motion-ease-default);
          }
          @media (prefers-reduced-motion: reduce) {
            .dialog { transition-duration: 0ms; }
          }

# ─── ANNOTATIONS ─────────────────────────────────────
# Rich metadata for skills and CLI: tool permissions,
# argument templates, code examples, references, and
# trigger descriptions.

annotations:
  SpecParser:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when designing, creating, or validating concept specs following
        Jackson's methodology. Covers purpose articulation, state design,
        action design, invariant writing, and spec syntax validation.
      intro-template: >
        Parse and validate concept spec **$ARGUMENTS** to verify syntax,
        structure, and adherence to Jackson's concept design methodology.
      companion-docs:
        - path: examples/design-a-concept.md
          label: "End-to-end concept design walkthrough"
          content: |
            # Walkthrough: Designing a Concept from Scratch

            This walkthrough shows how to design a `Bookmark` concept
            following Jackson's methodology.

            ## Step 1: Articulate the Purpose

            > What is this concept for?

            ```
            purpose { Allow users to save and organize references to items. }
            ```

            - One sentence, imperative present tense.
            - No implementation details (no "stores in database").

            ## Step 2: Design the State

            Start from the purpose. A bookmark needs:
            - A collection of bookmarks
            - Which user owns it
            - Which item it references
            - Optional: a label

            ```
            state {
              bookmarks: set B
              owner: B -> U
              item: B -> I
              label: B -> option String
              created: B -> String
            }
            ```

            ## Step 3: Design the Actions

            What can users do with bookmarks?

            ```
            actions {
              action add(item: I, label: option String) {
                -> ok(bookmark: B) { Bookmark created. }
                -> duplicate(item: I) { Item already bookmarked. }
              }
              action remove(bookmark: B) {
                -> ok { Bookmark removed. }
                -> notFound(bookmark: B) { Bookmark does not exist. }
              }
              action list(owner: U) {
                -> ok(bookmarks: list B) { User's bookmarks returned. }
              }
            }
            ```

            ## Step 4: Write Invariants

            ```
            invariants {
              after add(item) -> ok(bookmark) {
                then { bookmark in bookmarks; item(bookmark) = item }
              }
              after remove(bookmark) -> ok {
                then { bookmark not in bookmarks }
              }
            }
            ```

            ## Step 5: Validate

            ```bash
            copf check specs/bookmark.concept
            ```
      example-walkthroughs:
        - path: examples/design-a-concept.md
          label: "Design a concept from scratch (Bookmark example)"
    parse:
      examples:
        - label: "Parse a concept file"
          language: typescript
          code: |
            import { parseConceptFile } from './parser';
            const ast = parseConceptFile(source);
        - label: "Parse from CLI"
          language: bash
          code: "copf check specs/my-concept.concept"
      references:
        - path: references/concept-grammar.md
          label: "Full concept grammar specification"

  SchemaGen:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when generating ConceptManifests from parsed ASTs, implementing
        concept handlers, or inspecting the schema that drives code generation.
      intro-template: >
        Generate a ConceptManifest from **$ARGUMENTS** that provides typed
        action signatures, state schemas, and invariant test values for
        code generation.
      companion-docs:
        - path: examples/implement-a-handler.md
          label: "End-to-end handler implementation walkthrough"
          content: |
            # Walkthrough: Implementing a Concept Handler

            This walkthrough shows how to implement a handler for the
            `User` concept from spec to working code.

            ## Step 1: Generate the Manifest

            ```bash
            copf generate specs/user.concept
            ```

            This produces `generated/manifests/user.manifest.json` with typed
            action signatures.

            ## Step 2: Create the Handler File

            ```typescript
            // implementations/user.impl.ts
            import type { ConceptHandler, ConceptStorage } from '@copf/kernel';

            interface UserState {
              name: string;
              email: string;
            }

            export const userHandler: ConceptHandler<UserState> = {
              async create(input, storage) {
                // Check for duplicate
                for (const [id, user] of await storage.entries()) {
                  if (user.name === input.name) {
                    return { variant: 'duplicate', name: input.name };
                  }
                }
                // Create
                const id = crypto.randomUUID();
                await storage.set(id, { name: input.name, email: input.email });
                return { variant: 'ok', user: id };
              },

              async delete(input, storage) {
                if (!await storage.has(input.user)) {
                  return { variant: 'notFound', user: input.user };
                }
                await storage.delete(input.user);
                return { variant: 'ok' };
              },
            };
            ```

            ## Step 3: Verify Against Manifest

            Every variant declared in the spec must have a code path:
            - `create → ok` ✓
            - `create → duplicate` ✓
            - `delete → ok` ✓
            - `delete → notFound` ✓

            ## Step 4: Run Tests

            ```bash
            npx vitest run tests/user.test.ts
            ```
      example-walkthroughs:
        - path: examples/implement-a-handler.md
          label: "Implement a concept handler (User example)"
    generate:
      examples:
        - label: "Generate manifest from AST"
          language: typescript
          code: |
            import { schemaGenHandler } from './schema-gen.impl';
            const result = await schemaGenHandler.generate(
              { conceptAst: JSON.stringify(ast) }, storage
            );
        - label: "Generate from CLI"
          language: bash
          code: "copf generate specs/my-concept.concept"
      references:
        - path: references/type-mapping.md
          label: "Spec-to-TypeScript type mapping rules"

  SyncParser:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when parsing and validating .sync files against loaded concept
        manifests. Catches variable binding errors, missing concept references,
        and parameter mismatches at parse time.
      intro-template: >
        Parse sync file **$ARGUMENTS** and validate its structure, variable
        bindings, and concept references against loaded manifests.
      companion-docs:
        - path: examples/validate-a-sync.md
          label: "Sync validation walkthrough"
          content: |
            # Walkthrough: Validating a Sync File

            This walkthrough shows how to validate a sync file and fix
            common errors caught by the parser.

            ## Step 1: Write the Sync

            ```
            sync WelcomeEmail [eager] {
              when { User/create => ok[user: ?u] }
              where { User: { ?u email: ?email } }
              then { Email/send[to: ?email, template: "welcome"] }
            }
            ```

            ## Step 2: Parse and Validate

            ```bash
            copf compile-syncs syncs/welcome-email.sync
            ```

            ## Step 3: Fix Common Errors

            **Unbound variable:**
            ```
            ERROR: Variable ?email in then-clause is not bound
            FIX: Add a where-clause to bind ?email from User state
            ```

            **Missing concept reference:**
            ```
            ERROR: Concept 'Emaill' not found in loaded manifests
            FIX: Check spelling — should be 'Email'
            ```

            **Parameter mismatch:**
            ```
            ERROR: Email/send expects 'to' (String) but got 'to' (Int)
            FIX: Ensure variable type matches action parameter type
            ```
    parse:
      examples:
        - label: "Parse a sync file"
          language: typescript
          code: |
            import { syncParserHandler } from './sync-parser.impl';
            const result = await syncParserHandler.parse(
              { source: syncSource, manifests: loadedManifests }, storage
            );
        - label: "Parse from CLI"
          language: bash
          code: "copf compile-syncs syncs/my-sync.sync"
      references:
        - path: references/sync-design.md
          label: "Sync language reference"

  SyncCompiler:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when compiling parsed sync ASTs into executable registrations
        that the sync engine can evaluate at runtime.
      intro-template: >
        Compile sync rules in **$ARGUMENTS** into executable registrations
        for the sync engine.
      companion-docs:
        - path: examples/write-a-sync-chain.md
          label: "Sync chain composition walkthrough"
          content: |
            # Walkthrough: Writing a Sync Chain

            This walkthrough shows how to compose syncs into a chain
            where each sync reacts to the previous one's completion.

            ## The Scenario

            When a user registers:
            1. Create their profile (eager)
            2. Send a welcome email (eventual)
            3. Notify the admin (eventual)

            ## Step 1: Registration → Profile

            ```
            sync CreateProfile [eager] {
              when { User/create => ok[user: ?u] }
              then { Profile/create[owner: ?u] }
            }
            ```

            ## Step 2: Profile → Welcome Email

            ```
            sync WelcomeEmail [eventual] {
              when { Profile/create => ok[profile: ?p] }
              where { Profile: { ?p owner: ?u } }
              where { User: { ?u email: ?email, name: ?name } }
              then { Email/send[to: ?email, template: "welcome", data: ?name] }
            }
            ```

            ## Step 3: Registration → Admin Notification

            ```
            sync NotifyAdmin [eventual] {
              when { User/create => ok[user: ?u] }
              where { User: { ?u name: ?name } }
              then { Notification/create[type: "new-user", message: ?name] }
            }
            ```

            ## Key Points

            - Each sync sees only the completion it reacts to.
            - Sync 2 reacts to Profile/create, not to User/create.
            - Sync 3 runs independently from Sync 2.
            - Eager syncs run in the same transaction. Eventual syncs are queued.
      example-walkthroughs:
        - path: examples/write-a-sync-chain.md
          label: "Compose a sync chain (registration flow)"
    compile:
      examples:
        - label: "Compile sync rules"
          language: bash
          code: "copf compile-syncs --dir ./syncs"
        - label: "Compile programmatically"
          language: typescript
          code: |
            import { syncCompilerHandler } from './sync-compiler.impl';
            const result = await syncCompilerHandler.compile(
              { sync: parsedSync, ast: syncAst }, storage
            );
      references:
        - path: references/sync-patterns.md
          label: "Reusable sync templates and patterns"

  FlowTrace:
    concept:
      tool-permissions: [Read, Bash]
      argument-template: "<flow-id>"
      trigger-description: >
        Use when debugging action flows, tracing causal chains through
        concept actions and sync firings, or diagnosing why an expected
        sync did not trigger.
      intro-template: >
        Build a debug trace for flow **$ARGUMENTS** showing the causal
        chain of concept actions, sync firings, and data propagation.
      companion-docs:
        - path: examples/debug-a-flow.md
          label: "Flow debugging walkthrough"
          content: |
            # Walkthrough: Debugging a Flow

            This walkthrough shows how to use FlowTrace to debug
            a sync that didn't fire as expected.

            ## The Problem

            A welcome email should be sent when a user registers,
            but no email is being sent.

            ## Step 1: Find the Flow ID

            ```bash
            copf trace --recent
            ```

            Output shows recent flows. Find the User/create flow.

            ## Step 2: Build the Trace

            ```bash
            copf trace abc-123
            ```

            ```
            Flow abc-123
            ├─ User/create => ok [user: u1]        2ms
            │  └─ [sync: CreateProfile] eager
            │     └─ Profile/create => ok [p: p1]   1ms
            └─ total: 3ms
            ```

            ## Step 3: Diagnose

            The WelcomeEmail sync is missing from the trace. Check:

            1. **Is it registered?** — Check `syncs/welcome-email.sync` exists.
            2. **Does the pattern match?** — The sync watches
               `Profile/create => ok`, which DID fire. Check variable bindings.
            3. **Is it eventual?** — Eventual syncs execute asynchronously.
               Check the async queue for pending jobs.

            ## Step 4: Fix

            The sync had a typo in the variant name (`sucess` → `ok`).
            After fixing, the trace shows the complete chain.
    build:
      examples:
        - label: "Build trace from flow ID"
          language: bash
          code: "copf trace <flow-id>"
        - label: "Build trace programmatically"
          language: typescript
          code: |
            import { flowTraceHandler } from './flow-trace.impl';
            const result = await flowTraceHandler.build(
              { flowId: 'abc-123' }, storage
            );

  Builder:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when compiling, testing, and packaging concept implementations
        across languages. Coordinates build operations and routes to
        language-specific providers (SwiftBuilder, TypeScriptBuilder,
        RustBuilder, SolidityBuilder).
      intro-template: >
        Build concept **$ARGUMENTS** for the configured language targets,
        routing to the appropriate provider and storing content-addressed
        artifacts.
      companion-docs:
        - path: examples/build-all-targets.md
          label: "Multi-target build walkthrough"
          content: |
            # Walkthrough: Building All Targets

            This walkthrough shows how to build a concept for multiple
            language targets using the deploy manifest.

            ## Step 1: Configure Build Targets

            ```yaml
            # app.deploy.yaml
            build:
              targets:
                - language: swift
                  platform: linux-arm64
                  mode: release
                  config:
                    version: ">=5.10"
                    package-format: framework

                - language: typescript
                  platform: node-20
                  mode: release
                  config:
                    version: ">=5.7"
                    bundler: esbuild
                    package-format: npm
            ```

            ## Step 2: Build

            ```bash
            copf build ./app.deploy.yaml
            ```

            The build layer:
            1. Resolves toolchains (once per language)
            2. Builds each concept for each target (in parallel)
            3. Stores artifacts in content-addressed storage

            ## Step 3: Check Results

            ```bash
            copf build history --concept password
            ```

            ## Executor Strategies

            Configure how builds execute in the manifest:

            ```yaml
            executor:
              swift:
                type: local        # Direct invocation
              typescript:
                type: container    # Docker-based
              rust:
                type: remote       # Remote build service
                endpoint: https://build.internal/rust
            ```
    build:
      examples:
        - label: "Build a concept"
          language: bash
          code: "copf build ./app.deploy.yaml --concept password --language swift"
        - label: "Build all targets"
          language: bash
          code: "copf build ./app.deploy.yaml"
    buildAll:
      examples:
        - label: "Build all concepts for all targets"
          language: bash
          code: "copf build ./app.deploy.yaml"
    test:
      examples:
        - label: "Run tests for a concept"
          language: bash
          code: "copf build test --concept password --language swift"
    history:
      examples:
        - label: "Show build history"
          language: bash
          code: "copf build history --concept password"

  Toolchain:
    concept:
      tool-permissions: [Read, Grep, Glob, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when resolving, validating, or listing compiler toolchains
        for the build layer. Routes resolution to language-specific
        providers (SwiftToolchain, TypeScriptToolchain, RustToolchain,
        SolidityToolchain).
      intro-template: >
        Resolve toolchain for **$ARGUMENTS**, validating compiler
        availability, version constraints, and platform capabilities.
      companion-docs:
        - path: examples/resolve-toolchains.md
          label: "Toolchain resolution walkthrough"
          content: |
            # Walkthrough: Resolving Toolchains

            This walkthrough shows how toolchain resolution works
            for a multi-language build.

            ## Step 1: List Installed Toolchains

            ```bash
            copf toolchain list
            ```
            ```
            Language     Platform       Version   Path                  Status
            swift        linux-arm64    5.10.1    /usr/bin/swiftc       ok
            typescript   node-20        5.7.2     /usr/local/bin/tsc    ok
            rust         linux-x86_64   1.78.0    /usr/local/bin/rustc  ok
            solidity     evm-shanghai   0.8.25    /usr/local/bin/solc   ok
            ```

            ## Step 2: Resolve with Constraints

            ```bash
            copf toolchain resolve swift --platform linux-arm64 --version ">=5.10"
            ```
            ```
            Resolved: swift 5.10.1
            Path: /usr/bin/swiftc
            Capabilities: macros, swift-testing, cross-compile
            ```

            ## Step 3: Validate Before Build

            ```bash
            copf toolchain validate
            ```

            Checks all previously resolved toolchains are still
            valid (exist at path, version unchanged).

            ## Capability-Based Decisions

            Builder checks capabilities to determine build modes:
            - "incremental" → enable incremental compilation
            - "wasm-target" → WASM output available
            - "cross-compile" → cross-platform builds supported
    resolve:
      examples:
        - label: "Resolve Swift toolchain"
          language: bash
          code: "copf toolchain resolve swift --platform linux-arm64 --version '>=5.10'"
        - label: "Resolve programmatically"
          language: typescript
          code: |
            import { toolchainHandler } from './toolchain.impl';
            const result = await toolchainHandler.resolve(
              { language: 'swift', platform: 'linux-arm64', versionConstraint: '>=5.10' },
              storage,
            );
    validate:
      examples:
        - label: "Validate all toolchains"
          language: bash
          code: "copf toolchain validate"
    list:
      examples:
        - label: "List all resolved toolchains"
          language: bash
          code: "copf toolchain list"
        - label: "List by language"
          language: bash
          code: "copf toolchain list --language swift"

  DeploymentValidator:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when configuring deployment manifests that map concepts to
        runtimes, assign syncs to engines, set up transport adapters,
        and validate capability requirements.
      intro-template: >
        Validate deployment manifest **$ARGUMENTS** against compiled
        concepts and syncs, checking runtime mappings, engine assignments,
        and transport configuration.
      companion-docs:
        - path: examples/configure-deployment.md
          label: "Deployment configuration walkthrough"
          content: |
            # Walkthrough: Configuring a Deployment

            This walkthrough shows how to set up a deployment manifest
            for a two-runtime application.

            ## The Application

            - **API runtime**: User, Article, Comment concepts
            - **Worker runtime**: Email, Notification concepts
            - Syncs cross the boundary (e.g., WelcomeEmail)

            ## Step 1: Define Runtimes

            ```yaml
            runtimes:
              api:
                type: node
                concepts: [User, Article, Comment]
                capabilities: [storage-postgres, transport-http]
              worker:
                type: node
                concepts: [Email, Notification]
                capabilities: [storage-redis, transport-amqp]
            ```

            ## Step 2: Assign Sync Engines

            ```yaml
            engines:
              default:
                type: in-process
                syncs: [CreateProfile, UpdateCache]
              async:
                type: queue
                syncs: [WelcomeEmail, NotifyOnComment]
            ```

            ## Step 3: Configure Transport

            ```yaml
            transports:
              api-to-worker:
                type: http
                from: api
                to: worker
                endpoint: http://worker:3001
            ```

            ## Step 4: Validate

            ```bash
            copf deploy --validate deploy.yaml
            ```
    validate:
      examples:
        - label: "Validate deployment manifest"
          language: bash
          code: "copf deploy --validate app.deploy.yaml"
      references:
        - path: references/deployment-guide.md
          label: "Deployment configuration guide"
        - path: references/transport-adapters.md
          label: "Transport adapter reference"

  Migration:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when concept schemas have changed and stored state needs to
        be migrated to match the new version. Covers migration planning,
        dry-run validation, and execution.
      intro-template: >
        Plan and apply schema migration for **$ARGUMENTS**, transforming
        stored state from the previous version to the current spec version.
      companion-docs:
        - path: examples/run-a-migration.md
          label: "Migration execution walkthrough"
          content: |
            # Walkthrough: Running a Migration

            This walkthrough shows how to migrate a concept after
            adding a new required field.

            ## The Change

            Adding a `displayName` field to the User concept:

            ```
            state {
              users: set U
              name: U -> String
              email: U -> String
              displayName: U -> String   # NEW
            }
            ```

            ## Step 1: Check Status

            ```bash
            copf migrate --status
            ```
            ```
            User: v1 (stored) → v2 (spec) — MIGRATION NEEDED
            Article: v1 (stored) → v1 (spec) — up to date
            ```

            ## Step 2: Plan

            ```bash
            copf migrate --plan
            ```
            ```
            Migration plan for User v1 → v2:
              1. ADD FIELD displayName (String)
                 Default: compute from name field
            ```

            ## Step 3: Dry Run

            ```bash
            copf migrate --dry-run
            ```

            ## Step 4: Apply

            ```bash
            copf migrate --apply
            ```
    plan:
      examples:
        - label: "Plan a migration"
          language: bash
          code: "copf migrate --plan"
    apply:
      examples:
        - label: "Apply migration"
          language: bash
          code: "copf migrate --apply"

  ProjectScaffold:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when starting a new COPF project from scratch. Creates the
        standard directory structure, example concept spec, and
        configuration files.
      intro-template: >
        Scaffold a new COPF project named **$ARGUMENTS** with the standard
        directory layout, example concept, and configuration files.
      companion-docs:
        - path: templates/concept-template.md
          label: "Concept spec starter template"
          content: |
            # Concept Spec Template

            Use this template when creating a new concept spec file.

            ```
            concept Name [T] {

              purpose {
                One to three sentences describing what this concept is for.
                Use imperative present tense. No implementation details.
              }

              state {
                items: set T
                // Add relations on T:
                // name: T -> String        (required field)
                // label: T -> option String (optional field)
                // tags: T -> list String    (multi-valued)
              }

              actions {
                action create(/* params */) {
                  -> ok(item: T) { Created successfully. }
                  // Add error variants as needed:
                  // -> duplicate(name: String) { Name already taken. }
                  // -> invalid(reason: String) { Validation failed. }
                }

                action delete(item: T) {
                  -> ok { Deleted successfully. }
                  -> notFound(item: T) { Item does not exist. }
                }
              }

              invariants {
                after create(/* params */) -> ok(item) {
                  then { item in items }
                }
                after delete(item) -> ok {
                  then { item not in items }
                }
              }
            }
            ```
    scaffold:
      examples:
        - label: "Scaffold a new project"
          language: bash
          code: "copf init my-app"
        - label: "Scaffold with custom template"
          language: bash
          code: "copf init my-app --template minimal"

  DevServer:
    concept:
      tool-permissions: [Read, Bash]
      argument-template: "--port <port>"
      trigger-description: >
        Use when developing concepts and syncs iteratively. The dev server
        watches for file changes and recompiles automatically, providing
        a fast feedback loop.
      intro-template: >
        Start a development server that watches concept specs and syncs for
        changes and auto-recompiles on save.
      companion-docs:
        - path: examples/dev-iteration-cycle.md
          label: "Development iteration cycle walkthrough"
          content: |
            # Walkthrough: Development Iteration Cycle

            This walkthrough shows a typical edit-validate-test cycle
            using the dev server.

            ## Step 1: Start the Dev Server

            ```bash
            copf dev --port 3000
            ```

            ```
            COPF dev server started on port 3000
            Watching: specs/, syncs/, implementations/
            Parsed 5 concepts, compiled 3 syncs — all valid
            ```

            ## Step 2: Edit a Concept

            Add a new action to `specs/user.concept`:

            ```
            action updateEmail(user: U, email: String) {
              -> ok { Email updated. }
              -> notFound(user: U) { User not found. }
            }
            ```

            Save → dev server output:
            ```
            [hot] user.concept changed
            [parse] User: valid ✓
            [generate] user.manifest.json updated
            [type] user.d.ts updated
            ```

            ## Step 3: Add a Sync

            Create `syncs/email-updated.sync`:

            ```
            sync NotifyEmailChange [eventual] {
              when { User/updateEmail => ok }
              where { User: { ?u email: ?email } }
              then { Email/send[to: ?email, template: "email-changed"] }
            }
            ```

            Save → dev server output:
            ```
            [hot] email-updated.sync changed
            [compile] NotifyEmailChange: valid ✓
            ```

            ## Step 4: Implement the Handler

            Add the handler method in `implementations/user.impl.ts`,
            then run tests to verify.
    start:
      examples:
        - label: "Start dev server"
          language: bash
          code: "copf dev --port 3000"
    status:
      examples:
        - label: "Check dev server status"
          language: bash
          code: "copf dev status"
    stop:
      examples:
        - label: "Stop dev server"
          language: bash
          code: "copf dev stop"

  CacheCompiler:
    concept:
      tool-permissions: [Read, Bash]
      argument-template: "--cache"
      trigger-description: >
        Use when building pre-compiled artifacts for deployment or to
        speed up startup. Parses all specs, generates manifests, compiles
        syncs, and writes cache files.
      intro-template: >
        Build pre-compiled cache artifacts from all concept specs and sync
        rules for faster startup and deployment.
      companion-docs:
        - path: examples/build-for-production.md
          label: "Production build walkthrough"
          content: |
            # Walkthrough: Building for Production

            This walkthrough shows how to build a production-ready
            cache from your concept specs and syncs.

            ## Step 1: Validate Everything

            ```bash
            copf check           # Validate all specs
            copf compile-syncs   # Validate all syncs
            ```

            ## Step 2: Build the Cache

            ```bash
            copf compile --cache --verbose
            ```

            ```
            Building cache...
            [cache] user.concept → manifests/user.manifest.json (new)
            [cache] article.concept → manifests/article.manifest.json (new)
            [cache] create-profile.sync → syncs/create-profile.compiled.js (new)
            [cache] types → types/user.d.ts, types/article.d.ts (new)
            Cache built: 4 manifests, 2 syncs, 4 type files
            ```

            ## Step 3: Deploy

            Include `.copf-cache/` in your deployment:

            ```dockerfile
            COPY .copf-cache/ /app/.copf-cache/
            ```

            The runtime loads pre-compiled artifacts on startup,
            skipping the parse/compile step entirely.
    compile:
      examples:
        - label: "Build cache"
          language: bash
          code: "copf compile --cache"
        - label: "Build cache with verbose output"
          language: bash
          code: "copf compile --cache --verbose"

  KitManager:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when creating, validating, testing, or managing concept kits.
        Covers the full kit lifecycle from scaffolding to publishing.
      intro-template: >
        Manage kit **$ARGUMENTS** — scaffold, validate, test, and publish
        reusable concept packages.
      companion-docs:
        - path: examples/create-a-kit.md
          label: "Kit creation walkthrough"
          content: |
            # Walkthrough: Creating a Kit

            This walkthrough shows how to create, validate, and test
            a reusable concept kit.

            ## Step 1: Scaffold

            ```bash
            copf kit init auth-kit
            ```

            Creates:
            ```
            auth-kit/
            ├── kit.yaml
            ├── concepts/
            │   └── example.concept
            ├── syncs/
            └── tests/
            ```

            ## Step 2: Add Concepts

            Move your concept specs into `concepts/`:

            ```bash
            cp specs/user.concept auth-kit/concepts/
            cp specs/password.concept auth-kit/concepts/
            cp specs/session.concept auth-kit/concepts/
            ```

            ## Step 3: Update kit.yaml

            ```yaml
            kit:
              name: auth
              version: 1.0.0
              description: Authentication and identity management

            concepts:
              - concepts/user.concept
              - concepts/password.concept
              - concepts/session.concept

            syncs:
              required:
                - syncs/validate-session.sync
            ```

            ## Step 4: Validate and Test

            ```bash
            copf kit validate ./auth-kit
            copf kit test ./auth-kit
            ```
      example-walkthroughs:
        - path: examples/create-a-kit.md
          label: "Create a reusable kit (auth example)"
    init:
      examples:
        - label: "Create a new kit"
          language: bash
          code: "copf kit init my-kit"
    validate:
      examples:
        - label: "Validate a kit"
          language: bash
          code: "copf kit validate ./kits/my-kit"
    test:
      examples:
        - label: "Test a kit"
          language: bash
          code: "copf kit test ./kits/my-kit"
    list:
      examples:
        - label: "List active kits"
          language: bash
          code: "copf kit list"
    checkOverrides:
      examples:
        - label: "Check sync overrides"
          language: bash
          code: "copf kit check-overrides ./kits/my-kit"

  Emitter:
    concept:
      tool-permissions: [Read, Grep, Glob, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when writing generated files, auditing for drift, tracing
        source provenance, or cleaning orphaned outputs.
      intro-template: >
        Manage generated file output for **$ARGUMENTS** with content-addressed
        writes, source traceability, and drift detection.
    write:
      examples:
        - label: "Write a single file"
          language: typescript
          code: |
            const result = await emitterHandler.write(
              { path: 'generated/user.types.ts', content: typesCode, formatHint: 'typescript' },
              storage,
            );
    writeBatch:
      examples:
        - label: "Batch write generated files"
          language: typescript
          code: |
            const result = await emitterHandler.writeBatch(
              { files: [{ path: 'user.types.ts', content: types }, { path: 'user.handler.ts', content: handler }] },
              storage,
            );
    audit:
      examples:
        - label: "Audit generated directory"
          language: bash
          code: "copf emitter audit ./generated"
    trace:
      examples:
        - label: "Trace source provenance"
          language: bash
          code: "copf emitter trace ./generated/user.types.ts"
    affected:
      examples:
        - label: "Show impact of changing a source file"
          language: bash
          code: "copf emitter affected ./specs/app/user.concept"
    clean:
      examples:
        - label: "Remove orphaned files"
          language: bash
          code: "copf emitter clean ./generated"

  BuildCache:
    concept:
      tool-permissions: [Read, Grep, Glob, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when checking cache validity, recording generation results,
        or invalidating stale entries for incremental rebuilds.
      intro-template: >
        Manage incremental build cache for **$ARGUMENTS** with hash-based
        invalidation and per-step granularity.
    check:
      examples:
        - label: "Check if step is cached"
          language: typescript
          code: |
            const result = await buildCacheHandler.check(
              { stepKey: 'framework:TypeScriptGen:article', inputHash: hash, deterministic: true },
              storage,
            );
            if (result.variant === 'unchanged') { /* skip generation */ }
    status:
      examples:
        - label: "Show cache status"
          language: bash
          code: "copf build-cache status"
    staleSteps:
      examples:
        - label: "List stale cache entries"
          language: bash
          code: "copf build-cache stale-steps"

  Resource:
    concept:
      tool-permissions: [Read, Grep, Glob, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when tracking input files, detecting changes, or querying
        which resources are currently registered.
      intro-template: >
        Track input resources for **$ARGUMENTS** with content-addressed
        digests and change classification.
    upsert:
      examples:
        - label: "Track a concept spec file"
          language: typescript
          code: |
            const result = await resourceHandler.upsert(
              { locator: 'specs/app/article.concept', kind: 'concept-spec', digest: contentHash },
              storage,
            );
    list:
      examples:
        - label: "List all tracked resources"
          language: bash
          code: "copf resource list"
        - label: "List only concept specs"
          language: bash
          code: "copf resource list --kind concept-spec"

  KindSystem:
    concept:
      tool-permissions: [Read, Grep, Glob, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when inspecting the IR kind taxonomy, finding transform paths
        between kinds, or querying which generators consume or produce a kind.
      intro-template: >
        Inspect the generation pipeline topology for **$ARGUMENTS** showing
        IR kinds, transform edges, and routing paths.
    graph:
      examples:
        - label: "Show full kind graph"
          language: bash
          code: "copf kind-system graph"
    route:
      examples:
        - label: "Find path from source to artifact"
          language: bash
          code: "copf kind-system route --from ConceptDSL --to TypeScriptFiles"
    consumers:
      examples:
        - label: "What consumes ConceptManifest?"
          language: bash
          code: "copf kind-system consumers --kind ConceptManifest"
    producers:
      examples:
        - label: "What produces TypeScriptFiles?"
          language: bash
          code: "copf kind-system producers --kind TypeScriptFiles"

  GenerationPlan:
    concept:
      tool-permissions: [Read, Grep, Glob, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when checking the status of a generation run, viewing run
        summaries, or browsing generation history.
      intro-template: >
        View generation run tracking for **$ARGUMENTS** with step-by-step
        status, aggregate summaries, and run history.
    status:
      examples:
        - label: "Show current run status"
          language: bash
          code: "copf generation-plan status"
    summary:
      examples:
        - label: "Show run summary"
          language: bash
          code: "copf generation-plan summary"
    history:
      examples:
        - label: "Show last 5 runs"
          language: bash
          code: "copf generation-plan history --limit 5"

  KitScaffoldGen:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "--name <kit-name>"
      trigger-description: >
        Use when creating a new COPF kit from scratch. Generates a kit.yaml
        manifest with concept declarations, sync tier groupings, type parameter
        alignment, and directory structure stubs.
      intro-template: >
        Scaffold a new COPF kit named **$ARGUMENTS** with a kit.yaml manifest,
        concept spec stubs, and sync directory structure.
      companion-docs:
        - path: examples/scaffold-a-kit.md
          label: "End-to-end kit scaffolding walkthrough"
          content: |
            # Walkthrough: Scaffolding a New Kit

            This walkthrough creates an `auth` kit with User, Session, and
            Password concepts.

            ## Step 1: Generate the Kit Scaffold

            ```bash
            copf scaffold kit --name auth --concepts User,Session,Password
            ```

            Output:
            ```
            Created auth/kit.yaml
            Created auth/user.concept (stub)
            Created auth/session.concept (stub)
            Created auth/password.concept (stub)
            Created auth/syncs/.gitkeep
            ```

            ## Step 2: Edit the Concept Stubs

            Open `auth/user.concept` and replace the TODO with your design:

            ```
            concept User [U] {
              purpose { Manage user identity and profile information. }
              state {
                users: set U
                name: U -> String
                email: U -> String
              }
              actions {
                action create(name: String, email: String) {
                  -> ok(user: U) { User created. }
                  -> duplicate(email: String) { Email already registered. }
                }
              }
            }
            ```

            ## Step 3: Add Type Alignment

            Edit `auth/kit.yaml` to align type parameters:

            ```yaml
            concepts:
              User:
                params: { U: { as: user-ref } }
              Session:
                params:
                  S: { as: session-ref }
                  U: { as: user-ref }  # Same user-ref!
            ```

            ## Step 4: Validate

            ```bash
            copf kit validate ./kits/auth
            ```
    register:
      examples:
        - label: "Register the kit scaffold generator"
          language: typescript
          code: |
            const result = await kitScaffoldGenHandler.register({}, storage);
            // { variant: 'ok', name: 'KitScaffoldGen', inputKind: 'KitConfig', ... }
    generate:
      examples:
        - label: "Generate a basic kit"
          language: bash
          code: "copf scaffold kit --name auth --concepts User,Session,Password"
        - label: "Generate a domain kit with infrastructure"
          language: bash
          code: "copf scaffold kit --name web3 --concepts Token,Wallet --domain"
        - label: "Generate programmatically"
          language: typescript
          code: |
            import { kitScaffoldGenHandler } from './kit-scaffold-gen.impl';
            const result = await kitScaffoldGenHandler.generate({
              name: 'auth',
              description: 'Authentication and identity management.',
              concepts: ['User', 'Session', 'Password'],
              syncs: [
                { name: 'ValidateSession', tier: 'required' },
                { name: 'RefreshExpired', tier: 'recommended' },
              ],
            }, storage);
      references:
        - path: references/kit-manifest-schema.md
          label: "Kit manifest schema reference"

  DeployScaffoldGen:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "--app <app-name>"
      trigger-description: >
        Use when creating a new deployment manifest for a COPF application.
        Generates deploy.yaml with runtime configurations, infrastructure
        declarations, concept-to-runtime assignments, and build settings.
      intro-template: >
        Scaffold a deploy.yaml manifest for application **$ARGUMENTS** with
        runtime configs, infrastructure, and concept assignments.
      companion-docs:
        - path: examples/scaffold-deploy.md
          label: "Deployment manifest scaffolding walkthrough"
          content: |
            # Walkthrough: Scaffolding a Deployment Manifest

            This walkthrough creates a deploy manifest for a multi-runtime
            application.

            ## Step 1: Generate the Deploy Scaffold

            ```bash
            copf scaffold deploy --app conduit \
              --runtimes api:node:http:postgresql,worker:node:sqs:redis \
              --iac terraform
            ```

            ## Step 2: Assign Concepts to Runtimes

            Edit `deploy/conduit.deploy.yaml`:

            ```yaml
            concepts:
              User:
                spec: ./specs/app/user.concept
                implementations:
                  - language: typescript
                    runtime: api
                    storage: postgresql
              Email:
                spec: ./specs/app/email.concept
                implementations:
                  - language: typescript
                    runtime: worker
                    storage: redis
            ```

            ## Step 3: Add Sync Assignments

            ```yaml
            syncs:
              - path: ./syncs/welcome-email.sync
                engine: engine
                annotations: [eventual]
            ```

            ## Step 4: Validate

            ```bash
            copf deploy --validate deploy/conduit.deploy.yaml
            ```
    register:
      examples:
        - label: "Register the deploy scaffold generator"
          language: typescript
          code: |
            const result = await deployScaffoldGenHandler.register({}, storage);
    generate:
      examples:
        - label: "Generate a basic deploy manifest"
          language: bash
          code: "copf scaffold deploy --app my-app"
        - label: "Generate with custom runtimes"
          language: bash
          code: "copf scaffold deploy --app conduit --iac terraform"
        - label: "Generate programmatically"
          language: typescript
          code: |
            import { deployScaffoldGenHandler } from './deploy-scaffold-gen.impl';
            const result = await deployScaffoldGenHandler.generate({
              appName: 'conduit',
              runtimes: [
                { name: 'api', type: 'node', transport: 'http', storage: 'postgresql' },
                { name: 'worker', type: 'node', transport: 'sqs', storage: 'redis' },
              ],
              concepts: [
                { name: 'User', runtime: 'api' },
                { name: 'Article', runtime: 'api' },
              ],
              iacProvider: 'terraform',
            }, storage);
      references:
        - path: references/deploy-manifest-schema.md
          label: "Deploy manifest schema reference"

  InterfaceScaffoldGen:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "--name <interface-name>"
      trigger-description: >
        Use when creating a new interface generation manifest. Generates
        interface.yaml with target configurations for REST, GraphQL, gRPC,
        CLI, MCP, and Claude Skills, plus SDK settings and spec outputs.
      intro-template: >
        Scaffold an interface.yaml for **$ARGUMENTS** with target configs,
        SDK settings, and per-concept overrides.
      companion-docs:
        - path: examples/scaffold-interface.md
          label: "Interface manifest scaffolding walkthrough"
          content: |
            # Walkthrough: Scaffolding an Interface Manifest

            This walkthrough creates an interface manifest for a REST +
            GraphQL API with TypeScript and Python SDKs.

            ## Step 1: Generate the Interface Scaffold

            ```bash
            copf scaffold interface --name conduit-api \
              --targets rest,graphql \
              --sdks typescript,python \
              --concepts User,Article,Comment
            ```

            ## Step 2: Customize Target Settings

            Edit `conduit-api.interface.yaml`:

            ```yaml
            targets:
              rest:
                basePath: /api/v1
                framework: hono
              graphql:
                path: /graphql
                relay: true
                subscriptions: true
            ```

            ## Step 3: Add Per-Concept Overrides

            ```yaml
            concepts:
              User:
                rest:
                  basePath: /api/v1/users
                graphql:
                  typeName: User
              Article:
                rest:
                  basePath: /api/v1/articles
            ```

            ## Step 4: Generate Interfaces

            ```bash
            copf interface generate --manifest conduit-api.interface.yaml
            ```
    register:
      examples:
        - label: "Register the interface scaffold generator"
          language: typescript
          code: |
            const result = await interfaceScaffoldGenHandler.register({}, storage);
    generate:
      examples:
        - label: "Generate a REST + GraphQL interface"
          language: bash
          code: "copf scaffold interface --name my-api --targets rest,graphql --sdks typescript"
        - label: "Generate a full-stack interface"
          language: bash
          code: "copf scaffold interface --name my-api --targets rest,graphql,grpc,cli,mcp,claude-skills --sdks typescript,python,go"
      references:
        - path: references/interface-manifest-schema.md
          label: "Interface manifest schema reference"

  ConceptScaffoldGen:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "--name <ConceptName>"
      trigger-description: >
        Use when creating a new concept specification from scratch. Generates
        a .concept file with purpose, state, actions, variants, invariants,
        and a register() action following Jackson's methodology.
      intro-template: >
        Scaffold a concept spec for **$ARGUMENTS** with state declarations,
        typed action signatures, and a register() action.
      companion-docs:
        - path: examples/scaffold-concept.md
          label: "Concept spec scaffolding walkthrough"
          content: |
            # Walkthrough: Scaffolding a Concept Spec

            This walkthrough creates a `Bookmark` concept from inputs.

            ## Step 1: Generate the Concept Scaffold

            ```bash
            copf scaffold concept --name Bookmark \
              --param B \
              --purpose "Allow users to save and organize references to items." \
              --actions add,remove,list
            ```

            ## Step 2: Refine State Fields

            Edit `bookmark.concept`:

            ```
            state {
              bookmarks: set B
              owner: B -> U        # who owns it
              item: B -> I         # what it references
              label: B -> option String
            }
            ```

            ## Step 3: Refine Action Signatures

            ```
            action add(item: I, label: option String) {
              -> ok(bookmark: B) { Bookmark created. }
              -> duplicate(item: I) { Item already bookmarked. }
            }
            ```

            ## Step 4: Add Invariants

            ```
            invariant {
              after add(item: i) -> ok(bookmark: b)
              then add(item: i) -> duplicate(item: i)
            }
            ```

            ## Step 5: Validate

            ```bash
            copf check specs/app/bookmark.concept
            ```
    register:
      examples:
        - label: "Register the concept scaffold generator"
          language: typescript
          code: |
            const result = await conceptScaffoldGenHandler.register({}, storage);
    generate:
      examples:
        - label: "Generate a basic concept"
          language: bash
          code: "copf scaffold concept --name User --actions create,update,delete"
        - label: "Generate with custom state"
          language: bash
          code: "copf scaffold concept --name Article --param A --category domain"
      references:
        - path: references/concept-spec-guide.md
          label: "Concept specification writing guide"

  SyncScaffoldGen:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "--name <SyncName>"
      trigger-description: >
        Use when creating a new sync rule to connect concepts. Generates a
        .sync file with when/where/then clauses from trigger and effect
        configurations.
      intro-template: >
        Scaffold a sync rule **$ARGUMENTS** with trigger patterns, guard
        conditions, and effect actions.
      companion-docs:
        - path: examples/scaffold-sync.md
          label: "Sync rule scaffolding walkthrough"
          content: |
            # Walkthrough: Scaffolding a Sync Rule

            This walkthrough creates a sync that auto-creates a profile
            when a user is created.

            ## Step 1: Generate the Sync Scaffold

            ```bash
            copf scaffold sync --name CreateProfile \
              --from User/create \
              --to Profile/init \
              --tier required
            ```

            ## Step 2: Refine the Pattern

            Edit `create-profile.sync`:

            ```
            sync CreateProfile [eager]
              purpose { Auto-create a profile when a user registers. }
            when {
              User/create: [
                name: ?name;
                email: ?email
              ] => ok(user: ?u)
            }
            then {
              Profile/init: [
                owner: ?u;
                displayName: ?name
              ]
            }
            ```

            ## Step 3: Add Guard Conditions (optional)

            ```
            where {
              not(query(Profile/find: [owner: ?u] as ?existing))
            }
            ```

            ## Step 4: Validate

            ```bash
            copf sync validate syncs/create-profile.sync
            ```
    register:
      examples:
        - label: "Register the sync scaffold generator"
          language: typescript
          code: |
            const result = await syncScaffoldGenHandler.register({}, storage);
    generate:
      examples:
        - label: "Generate a simple sync"
          language: bash
          code: "copf scaffold sync --name CreateProfile --from User/create --to Profile/init"
        - label: "Generate an eager sync"
          language: bash
          code: "copf scaffold sync --name ValidateOrder --tier required --eager"
      references:
        - path: references/sync-rule-guide.md
          label: "Sync rule writing guide"

  HandlerScaffoldGen:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "--concept <ConceptName>"
      trigger-description: >
        Use when implementing a concept handler in TypeScript. Generates a
        .impl.ts handler with register(), typed action methods, input extraction,
        storage patterns, and a conformance test file.
      intro-template: >
        Scaffold a TypeScript handler for concept **$ARGUMENTS** with typed
        actions, storage patterns, and a conformance test.
      companion-docs:
        - path: examples/scaffold-handler.md
          label: "Handler implementation scaffolding walkthrough"
          content: |
            # Walkthrough: Scaffolding a Handler

            This walkthrough creates a handler for the `Bookmark` concept.

            ## Step 1: Generate the Handler Scaffold

            ```bash
            copf scaffold handler --concept Bookmark \
              --actions add:url:String,remove:bookmark:String,list:owner:String
            ```

            Output:
            ```
            Created implementations/typescript/framework/bookmark.impl.ts
            Created tests/bookmark.conformance.test.ts
            ```

            ## Step 2: Implement Action Logic

            Edit `bookmark.impl.ts` — replace TODO comments:

            ```typescript
            async add(input, storage) {
              const url = input.url as string;
              if (!url) return { variant: 'error', message: 'url required' };

              const existing = await storage.find('bookmarks', { url });
              if (existing.length > 0) return { variant: 'duplicate', url };

              const id = crypto.randomUUID();
              await storage.put('bookmarks', id, { id, url, created: new Date().toISOString() });
              return { variant: 'ok', bookmark: id };
            },
            ```

            ## Step 3: Run Conformance Test

            ```bash
            npx vitest run tests/bookmark.conformance.test.ts
            ```
    register:
      examples:
        - label: "Register the handler scaffold generator"
          language: typescript
          code: |
            const result = await handlerScaffoldGenHandler.register({}, storage);
    generate:
      examples:
        - label: "Generate a handler"
          language: bash
          code: "copf scaffold handler --concept User --actions create,update,delete"
        - label: "Generate with test only"
          language: bash
          code: "copf scaffold handler --concept Article"
      references:
        - path: references/handler-implementation-guide.md
          label: "Handler implementation patterns"

  StorageAdapterScaffoldGen:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "--name <AdapterName> --backend <backend>"
      trigger-description: >
        Use when adding a new storage backend to a COPF application. Generates
        a ConceptStorage adapter implementation with put, get, find, del, and
        delMany methods for the specified backend.
      intro-template: >
        Scaffold a **$ARGUMENTS** storage adapter implementing the ConceptStorage
        interface with all five required methods.
      companion-docs:
        - path: examples/scaffold-storage-adapter.md
          label: "Storage adapter scaffolding walkthrough"
          content: |
            # Walkthrough: Scaffolding a Storage Adapter

            This walkthrough creates a PostgreSQL storage adapter.

            ## Step 1: Generate the Adapter Scaffold

            ```bash
            copf scaffold storage --name AppStorage --backend postgresql
            ```

            ## Step 2: Configure Connection

            Edit the constructor in `app-storage-storage.ts`:

            ```typescript
            constructor(connectionString: string) {
              this.pool = new Pool({ connectionString });
            }
            ```

            ## Step 3: Wire into Deploy Manifest

            ```yaml
            # deploy.yaml
            infrastructure:
              storage:
                postgresql:
                  type: postgresql
                  config:
                    host: localhost
                    port: 5432
                    database: myapp
            ```

            ## Supported Backends

            | Backend | Package | Best For |
            |---------|---------|----------|
            | sqlite | better-sqlite3 | Single-node, embedded |
            | postgresql | pg | Production, multi-node |
            | redis | redis | Caching, sessions |
            | dynamodb | @aws-sdk/client-dynamodb | Serverless |
            | memory | (none) | Tests, prototypes |
    register:
      examples:
        - label: "Register the storage adapter scaffold generator"
          language: typescript
          code: |
            const result = await storageAdapterScaffoldGenHandler.register({}, storage);
    generate:
      examples:
        - label: "Generate a PostgreSQL adapter"
          language: bash
          code: "copf scaffold storage --name AppStorage --backend postgresql"
        - label: "Generate a Redis adapter"
          language: bash
          code: "copf scaffold storage --name CacheStorage --backend redis"
        - label: "Generate an in-memory adapter"
          language: bash
          code: "copf scaffold storage --name TestStorage --backend memory"
      references:
        - path: references/storage-adapter-guide.md
          label: "Storage adapter implementation guide"

  TransportAdapterScaffoldGen:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "--name <AdapterName> --protocol <protocol>"
      trigger-description: >
        Use when adding a new transport protocol to a COPF application.
        Generates a transport adapter with invoke, query, and health methods
        for the specified protocol.
      intro-template: >
        Scaffold a **$ARGUMENTS** transport adapter with invoke, query, and
        health methods for cross-runtime communication.
      companion-docs:
        - path: examples/scaffold-transport-adapter.md
          label: "Transport adapter scaffolding walkthrough"
          content: |
            # Walkthrough: Scaffolding a Transport Adapter

            This walkthrough creates an HTTP transport adapter.

            ## Step 1: Generate the Adapter Scaffold

            ```bash
            copf scaffold transport --name ApiTransport --protocol http
            ```

            ## Step 2: Configure Base URL

            ```typescript
            const transport = new ApiTransport('http://api-server:3000');
            ```

            ## Step 3: Wire into Deploy Manifest

            ```yaml
            # deploy.yaml
            infrastructure:
              transports:
                http:
                  type: http
                  config:
                    port: 3000
                    timeout: 5000
            ```

            ## Protocol Comparison

            | Protocol | Bidirectional | Latency | Best For |
            |----------|--------------|---------|----------|
            | http | No | Medium | REST APIs |
            | websocket | Yes | Low | Real-time |
            | worker | No | Very Low | Same-machine |
            | in-process | N/A | None | Tests |
    register:
      examples:
        - label: "Register the transport adapter scaffold generator"
          language: typescript
          code: |
            const result = await transportAdapterScaffoldGenHandler.register({}, storage);
    generate:
      examples:
        - label: "Generate an HTTP adapter"
          language: bash
          code: "copf scaffold transport --name ApiTransport --protocol http"
        - label: "Generate a WebSocket adapter"
          language: bash
          code: "copf scaffold transport --name RealtimeTransport --protocol websocket"
        - label: "Generate an in-process adapter"
          language: bash
          code: "copf scaffold transport --name TestTransport --protocol in-process"
      references:
        - path: references/transport-adapter-guide.md
          label: "Transport adapter implementation guide"

  CoifComponentScaffoldGen:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "--name <ComponentName>"
      trigger-description: >
        Use when creating a new COIF headless component. Generates a complete
        component scaffold including widget specification (FSM), anatomy
        definition (parts contract), machine implementation, and kit manifest.
      intro-template: >
        Scaffold a COIF headless component **$ARGUMENTS** with widget FSM,
        anatomy parts, machine implementation, and kit manifest.
      companion-docs:
        - path: examples/scaffold-coif-component.md
          label: "COIF component scaffolding walkthrough"
          content: |
            # Walkthrough: Scaffolding a COIF Component

            This walkthrough creates a `Dialog` headless component.

            ## Step 1: Generate the Component Scaffold

            ```bash
            copf scaffold component --name Dialog \
              --parts root,trigger,backdrop,content,title,closeTrigger \
              --states closed,open \
              --events open,close,escape
            ```

            Output:
            ```
            Created coif-dialog/dialog-widget.concept
            Created coif-dialog/dialog-anatomy.concept
            Created coif-dialog/kit.yaml
            Created coif-dialog/dialog-machine.impl.ts
            ```

            ## Step 2: Add Accessibility

            Edit `dialog-widget.concept`:

            ```
            accessibility {
              role: "dialog"
              aria-modal: true
              aria-labelledby: titleId
              aria-describedby: descriptionId
            }
            ```

            ## Step 3: Customize the Machine

            Add guards and transition side effects in
            `dialog-machine.impl.ts`:

            ```typescript
            // Add escape key handler
            if (event === 'escape' && machine.config?.closeOnEsc !== false) {
              // ... transition to closed
            }
            ```

            ## Step 4: Register with Widget Catalog

            The generated widget auto-registers via the coif-component
            kit's Widget/register action.

            ## Standard Component Library

            | Component | Parts | States |
            |-----------|-------|--------|
            | Button | root | idle, pressed |
            | Dialog | root, trigger, backdrop, content | closed, open |
            | Tabs | root, list, trigger, content | idle, focused |
            | Accordion | root, item, trigger, content | collapsed, expanded |
            | Menu | root, trigger, content, item | closed, open |
            | Select | root, trigger, content, item | closed, open |
            | Tooltip | root, trigger, content | hidden, visible |
    register:
      examples:
        - label: "Register the component scaffold generator"
          language: typescript
          code: |
            const result = await coifComponentScaffoldGenHandler.register({}, storage);
    generate:
      examples:
        - label: "Generate a dialog component"
          language: bash
          code: "copf scaffold component --name Dialog --parts root,trigger,content --states closed,open"
        - label: "Generate a tabs component"
          language: bash
          code: "copf scaffold component --name Tabs --parts root,list,trigger,content,indicator --states idle,focused,selected --events focus,select,blur"
      references:
        - path: references/coif-component-guide.md
          label: "COIF headless component architecture"

  CoifThemeScaffoldGen:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "--name <theme-name>"
      trigger-description: >
        Use when creating a new COIF design system theme. Generates palette
        configuration, typography scale, motion definitions, elevation scale,
        and light/dark theme manifests with WCAG accessibility compliance.
      intro-template: >
        Scaffold a COIF design system theme **$ARGUMENTS** with palette tokens,
        typography scale, motion transitions, and elevation shadows.
      companion-docs:
        - path: examples/scaffold-coif-theme.md
          label: "COIF theme scaffolding walkthrough"
          content: |
            # Walkthrough: Scaffolding a COIF Theme

            This walkthrough creates an `ocean` design system theme.

            ## Step 1: Generate the Theme Scaffold

            ```bash
            copf scaffold theme --name ocean \
              --primary 220 \
              --font "Inter, sans-serif" \
              --base-size 16 \
              --scale 1.25
            ```

            Output:
            ```
            Created theme-ocean/kit.yaml
            Created theme-ocean/themes/ocean-light.json
            Created theme-ocean/themes/ocean-dark.json
            Created theme-ocean/tokens/palette.json
            Created theme-ocean/tokens/typography.json
            Created theme-ocean/tokens/motion.json
            Created theme-ocean/tokens/elevation.json
            ```

            ## Step 2: Customize Colors

            Edit `tokens/palette.json` to adjust semantic roles:

            ```json
            {
              "primary": {
                "roles": {
                  "default": "500",
                  "hover": "600",
                  "active": "700"
                }
              }
            }
            ```

            ## Step 3: Check WCAG Contrast

            The palette generator ensures AA compliance (4.5:1 for
            normal text, 3:1 for large text). Verify:

            ```
            Primary 500 on white background → 4.6:1 ✓ (AA pass)
            Primary 500 on dark background → 7.2:1 ✓ (AAA pass)
            ```

            ## Step 4: Customize Typography

            Edit `tokens/typography.json`:

            ```json
            {
              "presets": {
                "heading-1": { "size": "39.06px", "weight": 700 },
                "body": { "size": "16px", "weight": 400 }
              }
            }
            ```

            ## Token Hierarchy

            ```
            Primitive          → Semantic          → Component
            color.blue.500       color.primary        button.bg
            font.size.base       font.body            input.fontSize
            spacing.4            spacing.md           card.padding
            ```
    register:
      examples:
        - label: "Register the theme scaffold generator"
          language: typescript
          code: |
            const result = await coifThemeScaffoldGenHandler.register({}, storage);
    generate:
      examples:
        - label: "Generate a theme with defaults"
          language: bash
          code: "copf scaffold theme --name ocean"
        - label: "Generate a custom theme"
          language: bash
          code: "copf scaffold theme --name brand --primary '#3b82f6' --font 'Inter, sans-serif' --base-size 18"
        - label: "Generate light-only theme"
          language: bash
          code: "copf scaffold theme --name print --mode light"
      references:
        - path: references/coif-theme-guide.md
          label: "COIF design system and theme architecture"

# ─── PER-CONCEPT CLI OVERRIDES ──────────────────────
# CLI-specific: positional args, custom command names.

concept-overrides:
  SpecParser:
    cli:
      actions:
        parse:
          command: check
          params:
            source:
              positional: true

  ProjectScaffold:
    cli:
      actions:
        scaffold:
          command: init
          params:
            name:
              positional: true

  KitManager:
    cli:
      actions:
        init:
          params:
            name:
              positional: true
        validate:
          params:
            path:
              positional: true
        test:
          params:
            path:
              positional: true

  Emitter:
    cli:
      command-group: emitter
      description: "Manage generated file output, traceability, and drift detection."
      actions:
        write:
          description: "Write a single generated file"
          args:
            path:
              positional: true
          flags:
            content:
              type: string
              required: true
              description: "File content to write"
            formatHint:
              type: string
              required: false
              short: f
              description: "Formatter to apply (e.g., prettier, rustfmt)"
        writeBatch:
          command: write-batch
          description: "Atomically write a batch of generated files"
        format:
          description: "Format a generated file"
          args:
            path:
              positional: true
        clean:
          description: "Remove orphaned generated files"
          args:
            outputDir:
              positional: true
          flags:
            currentManifest:
              type: string
              required: false
              description: "Path to current manifest listing expected files"
          examples:
            - description: "Clean generated directory"
              command: "copf emitter clean ./generated"
        manifest:
          description: "List all tracked output files"
          args:
            outputDir:
              positional: true
          examples:
            - description: "List outputs in generated/"
              command: "copf emitter manifest ./generated"
        trace:
          description: "Show which sources produced an output file"
          args:
            outputPath:
              positional: true
          examples:
            - description: "Trace provenance of a generated file"
              command: "copf emitter trace ./generated/user.types.ts"
        affected:
          description: "Show what outputs change if a source changes"
          args:
            sourcePath:
              positional: true
          examples:
            - description: "Impact analysis for a concept spec"
              command: "copf emitter affected ./specs/app/user.concept"
        audit:
          description: "Check generated files for drift from expected output"
          args:
            outputDir:
              positional: true
          examples:
            - description: "Audit generated directory"
              command: "copf emitter audit ./generated"

  BuildCache:
    cli:
      command-group: build-cache
      description: "Manage incremental build cache for generation pipeline."
      actions:
        check:
          description: "Check if a generation step is cached"
          flags:
            stepKey:
              type: string
              required: true
              short: k
              description: "Unique step identifier (generator:concept)"
            inputHash:
              type: string
              required: true
              description: "Hash of current input"
            deterministic:
              type: boolean
              required: false
              description: "Whether generator is deterministic"
        record:
          description: "Record a generation result in the cache"
        invalidate:
          description: "Invalidate a single cache entry"
          flags:
            stepKey:
              type: string
              required: true
              short: k
              description: "Step key to invalidate"
        invalidateBySource:
          command: invalidate-by-source
          description: "Invalidate all steps that used a source file"
          args:
            sourceLocator:
              positional: true
          examples:
            - description: "Invalidate after concept change"
              command: "copf build-cache invalidate-by-source specs/app/article.concept"
        invalidateByKind:
          command: invalidate-by-kind
          description: "Invalidate all steps producing a given IR kind"
          args:
            kindName:
              positional: true
          examples:
            - description: "Invalidate all TypeScript generation"
              command: "copf build-cache invalidate-by-kind TypeScriptFiles"
        invalidateAll:
          command: invalidate-all
          description: "Clear the entire build cache"
          examples:
            - description: "Full cache reset"
              command: "copf build-cache invalidate-all"
        status:
          description: "Show all cache entries with staleness indicators"
          examples:
            - description: "View cache status"
              command: "copf build-cache status"
        staleSteps:
          command: stale-steps
          description: "List step keys that need regeneration"
          examples:
            - description: "Find stale entries"
              command: "copf build-cache stale-steps"

  Resource:
    cli:
      command-group: resource
      description: "Track input resources with content-addressed digests."
      actions:
        upsert:
          description: "Register or update a tracked input resource"
          args:
            locator:
              positional: true
          flags:
            kind:
              type: string
              required: true
              short: k
              description: "Resource kind (concept-spec, sync-spec, etc.)"
            digest:
              type: string
              required: true
              description: "Content hash of the resource"
        get:
          description: "Look up a tracked resource"
          args:
            locator:
              positional: true
        list:
          description: "List all tracked input resources"
          flags:
            kind:
              type: string
              required: false
              short: k
              description: "Filter by resource kind"
          examples:
            - description: "List all tracked resources"
              command: "copf resource list"
            - description: "List only concept specs"
              command: "copf resource list --kind concept-spec"
        remove:
          description: "Stop tracking a resource"
          args:
            locator:
              positional: true
        diff:
          description: "Classify a content change between two digests"
          args:
            locator:
              positional: true

  KindSystem:
    cli:
      command-group: kind-system
      description: "Inspect the IR kind taxonomy and pipeline topology."
      actions:
        define:
          description: "Register a new IR kind"
          args:
            name:
              positional: true
          flags:
            category:
              type: string
              required: true
              short: c
              description: "Kind category (source, model, artifact)"
              choices: [source, model, artifact]
        connect:
          description: "Declare a transform edge between two kinds"
          flags:
            from:
              type: string
              required: true
              description: "Source kind"
            to:
              type: string
              required: true
              description: "Target kind"
            relation:
              type: string
              required: true
              description: "Transform relation (normalizes_to, compiles_to, etc.)"
            transformName:
              type: string
              required: false
              short: t
              description: "Name of the transform/generator"
        route:
          description: "Find shortest transform path between two kinds"
          flags:
            from:
              type: string
              required: true
              description: "Source kind"
            to:
              type: string
              required: true
              description: "Target kind"
          examples:
            - description: "Route from source to TypeScript"
              command: "copf kind-system route --from ConceptDSL --to TypeScriptFiles"
        validate:
          description: "Validate a transform edge"
        dependents:
          description: "List all downstream kinds from a given kind"
          args:
            kind:
              positional: true
          examples:
            - description: "What depends on ConceptManifest?"
              command: "copf kind-system dependents ConceptManifest"
        producers:
          description: "Show what transforms produce a given kind"
          args:
            kind:
              positional: true
          examples:
            - description: "What produces TypeScriptFiles?"
              command: "copf kind-system producers TypeScriptFiles"
        consumers:
          description: "Show what transforms consume a given kind"
          args:
            kind:
              positional: true
          examples:
            - description: "What consumes ConceptManifest?"
              command: "copf kind-system consumers ConceptManifest"
        graph:
          description: "Show the full kind taxonomy graph"
          examples:
            - description: "Display kind graph"
              command: "copf kind-system graph"

  GenerationPlan:
    cli:
      command-group: generation-plan
      description: "Track and inspect generation runs."
      actions:
        begin:
          description: "Mark a new generation run as started"
        recordStep:
          command: record-step
          description: "Record a step outcome in the current run"
          flags:
            stepKey:
              type: string
              required: true
              short: k
              description: "Step identifier"
            status:
              type: string
              required: true
              description: "Step outcome (done, cached, failed)"
            cached:
              type: boolean
              required: false
              description: "Whether the step was a cache hit"
        complete:
          description: "Mark the current generation run as finished"
        status:
          description: "Show step-by-step status of a generation run"
          examples:
            - description: "Show current run status"
              command: "copf generation-plan status"
        summary:
          description: "Show aggregate statistics for a generation run"
          examples:
            - description: "Show run summary"
              command: "copf generation-plan summary"
        history:
          description: "Show recent generation runs"
          flags:
            limit:
              type: string
              required: false
              short: n
              description: "Maximum number of runs to show"
              default: "10"
          examples:
            - description: "Show last 5 runs"
              command: "copf generation-plan history --limit 5"
            - description: "Show last 10 runs"
              command: "copf generation-plan history"

  # ─── Scaffold Generators CLI ─────────────────────────
  # All scaffold generators live under `copf scaffold <type>`.
  # They share a common pattern: --name for the output name,
  # type-specific flags for configuration, and --output for
  # the target directory.
  #
  # Pipeline integration: Each generator exposes preview and generate
  # actions. Sync rules automatically cascade from generate to wire
  # Emitter/writeBatch, BuildCache/record, and GenerationPlan/recordStep.

  KitScaffoldGen:
    cli:
      command-group: scaffold
      subcommand: kit
      description: "Generate kit manifest (kit.yaml) and directory structure."
      actions:
        preview:
          command: preview
          description: "Dry-run: compute output files without writing. Uses Emitter content-addressing to show what would change."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "Kit name (kebab-case)"
            concepts:
              type: string
              required: false
              short: c
              description: "Comma-separated PascalCase concept names"
        generate:
          command: kit
          description: "Scaffold a new COPF kit with kit.yaml, concept stubs, and sync directories."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "Kit name (kebab-case)"
            description:
              type: string
              required: false
              short: d
              description: "Kit description"
            concepts:
              type: string
              required: false
              short: c
              description: "Comma-separated PascalCase concept names"
            syncs:
              type: string
              required: false
              description: "Comma-separated sync declarations (Name:tier)"
            dependencies:
              type: string
              required: false
              description: "Comma-separated kit dependencies"
            domain:
              type: boolean
              required: false
              description: "Include infrastructure section for domain kit"
            output:
              type: string
              required: false
              short: o
              description: "Output directory (default: ./kits/<name>)"
          examples:
            - description: "Scaffold a basic kit"
              command: "copf scaffold kit --name auth --concepts User,Session,Password"
            - description: "Scaffold a domain kit with infrastructure"
              command: "copf scaffold kit --name web3 --concepts Token,Wallet --domain"
            - description: "Scaffold with syncs"
              command: "copf scaffold kit --name auth --concepts User --syncs ValidateSession:required,RefreshExpired:recommended"

  DeployScaffoldGen:
    cli:
      command-group: scaffold
      subcommand: deploy
      description: "Generate deployment manifest (deploy.yaml)."
      actions:
        preview:
          command: preview
          description: "Dry-run: compute output files without writing. Uses Emitter content-addressing to show what would change."
          flags:
            app:
              type: string
              required: true
              description: "Application name"
        generate:
          command: deploy
          description: "Scaffold a deploy.yaml with runtimes, infrastructure, and concept assignments."
          flags:
            app:
              type: string
              required: true
              description: "Application name"
            version:
              type: string
              required: false
              short: v
              description: "Semver version (default: 0.1.0)"
            runtimes:
              type: string
              required: false
              short: r
              description: "Runtime declarations (name:type:transport:storage, comma-separated)"
            concepts:
              type: string
              required: false
              short: c
              description: "Concept assignments (Name:runtime, comma-separated)"
            iac:
              type: string
              required: false
              description: "IaC provider (terraform, cloudformation, pulumi, docker-compose)"
              default: "terraform"
            output:
              type: string
              required: false
              short: o
              description: "Output directory (default: ./deploy)"
          examples:
            - description: "Scaffold a basic deploy manifest"
              command: "copf scaffold deploy --app my-app"
            - description: "Scaffold with custom runtimes"
              command: "copf scaffold deploy --app conduit --runtimes api:node:http:postgresql,worker:node:sqs:redis --iac terraform"
            - description: "Scaffold with concept assignments"
              command: "copf scaffold deploy --app conduit --concepts User:api,Article:api,Email:worker"

  InterfaceScaffoldGen:
    cli:
      command-group: scaffold
      subcommand: interface
      description: "Generate interface manifest (interface.yaml)."
      actions:
        preview:
          command: preview
          description: "Dry-run: compute output files without writing. Uses Emitter content-addressing to show what would change."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "Interface name"
            targets:
              type: string
              required: false
              short: t
              description: "Comma-separated targets"
        generate:
          command: interface
          description: "Scaffold an interface.yaml with targets, SDKs, and concept overrides."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "Interface name"
            targets:
              type: string
              required: false
              short: t
              description: "Comma-separated targets (rest, graphql, grpc, cli, mcp, claude-skills)"
              default: "rest"
            sdks:
              type: string
              required: false
              short: s
              description: "Comma-separated SDK languages (typescript, python, go, rust, java, swift)"
              default: "typescript"
            concepts:
              type: string
              required: false
              short: c
              description: "Comma-separated concept names for per-concept overrides"
            openapi:
              type: boolean
              required: false
              description: "Generate OpenAPI spec (default: true)"
              default: "true"
            asyncapi:
              type: boolean
              required: false
              description: "Generate AsyncAPI spec (default: false)"
              default: "false"
            output:
              type: string
              required: false
              short: o
              description: "Output directory"
          examples:
            - description: "Scaffold a REST + GraphQL interface"
              command: "copf scaffold interface --name my-api --targets rest,graphql --sdks typescript,python"
            - description: "Scaffold a full-stack interface"
              command: "copf scaffold interface --name my-api --targets rest,graphql,grpc,cli,mcp,claude-skills"

  ConceptScaffoldGen:
    cli:
      command-group: scaffold
      subcommand: concept
      description: "Generate concept specification (.concept) file."
      actions:
        preview:
          command: preview
          description: "Dry-run: compute output files without writing. Uses Emitter content-addressing to show what would change."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "PascalCase concept name"
        generate:
          command: concept
          description: "Scaffold a .concept file with state, actions, and register()."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "PascalCase concept name"
            param:
              type: string
              required: false
              short: p
              description: "Type parameter letter (default: T)"
              default: "T"
            purpose:
              type: string
              required: false
              description: "Purpose description"
            category:
              type: string
              required: false
              description: "Annotation category (domain, devtools, etc.)"
            actions:
              type: string
              required: false
              short: a
              description: "Comma-separated action names"
            output:
              type: string
              required: false
              short: o
              description: "Output directory (default: ./specs/app)"
          examples:
            - description: "Scaffold a basic concept"
              command: "copf scaffold concept --name User --actions create,update,delete"
            - description: "Scaffold with custom type parameter"
              command: "copf scaffold concept --name Article --param A --category domain"
            - description: "Scaffold with purpose"
              command: "copf scaffold concept --name Bookmark --purpose 'Save and organize references.'"

  SyncScaffoldGen:
    cli:
      command-group: scaffold
      subcommand: sync
      description: "Generate synchronization rule (.sync) file."
      actions:
        preview:
          command: preview
          description: "Dry-run: compute output files without writing. Uses Emitter content-addressing to show what would change."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "PascalCase sync name"
        generate:
          command: sync
          description: "Scaffold a .sync file with when/where/then clauses."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "PascalCase sync name"
            from:
              type: string
              required: false
              description: "Trigger source (Concept/action)"
            to:
              type: string
              required: false
              description: "Effect target (Concept/action)"
            tier:
              type: string
              required: false
              short: t
              description: "Sync tier (required, recommended)"
              default: "recommended"
            eager:
              type: boolean
              required: false
              description: "Fire immediately (default: true)"
              default: "true"
            output:
              type: string
              required: false
              short: o
              description: "Output directory (default: ./syncs)"
          examples:
            - description: "Scaffold a sync between two concepts"
              command: "copf scaffold sync --name CreateProfile --from User/create --to Profile/init"
            - description: "Scaffold a required sync"
              command: "copf scaffold sync --name ValidateOrder --tier required"

  HandlerScaffoldGen:
    cli:
      command-group: scaffold
      subcommand: handler
      description: "Generate TypeScript concept handler (.impl.ts) and conformance test."
      actions:
        preview:
          command: preview
          description: "Dry-run: compute output files without writing. Uses Emitter content-addressing to show what would change."
          flags:
            concept:
              type: string
              required: true
              short: c
              description: "PascalCase concept name"
        generate:
          command: handler
          description: "Scaffold a .impl.ts handler with register(), typed actions, and a conformance test."
          flags:
            concept:
              type: string
              required: true
              short: c
              description: "PascalCase concept name"
            actions:
              type: string
              required: false
              short: a
              description: "Comma-separated action signatures (name:param1:Type1,name:param2:Type2)"
            input-kind:
              type: string
              required: false
              description: "KindSystem input kind"
            output-kind:
              type: string
              required: false
              description: "KindSystem output kind"
            output:
              type: string
              required: false
              short: o
              description: "Output directory (default: ./implementations/typescript)"
          examples:
            - description: "Scaffold a handler"
              command: "copf scaffold handler --concept User --actions create:name:String,update:name:String,delete:id:String"
            - description: "Scaffold with kind metadata"
              command: "copf scaffold handler --concept Bookmark --input-kind BookmarkInput --output-kind BookmarkResult"

  StorageAdapterScaffoldGen:
    cli:
      command-group: scaffold
      subcommand: storage
      description: "Generate ConceptStorage adapter for a persistence backend."
      actions:
        preview:
          command: preview
          description: "Dry-run: compute output files without writing. Uses Emitter content-addressing to show what would change."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "Adapter class name (PascalCase)"
            backend:
              type: string
              required: true
              short: b
              description: "Backend type"
              choices: [sqlite, postgresql, redis, dynamodb, memory]
        generate:
          command: storage
          description: "Scaffold a ConceptStorage adapter with put, get, find, del, and delMany methods."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "Adapter class name (PascalCase)"
            backend:
              type: string
              required: true
              short: b
              description: "Backend type"
              choices: [sqlite, postgresql, redis, dynamodb, memory]
            output:
              type: string
              required: false
              short: o
              description: "Output directory"
          examples:
            - description: "Generate a PostgreSQL adapter"
              command: "copf scaffold storage --name AppStorage --backend postgresql"
            - description: "Generate a Redis adapter"
              command: "copf scaffold storage --name CacheStorage --backend redis"
            - description: "Generate an in-memory adapter for tests"
              command: "copf scaffold storage --name TestStorage --backend memory"

  TransportAdapterScaffoldGen:
    cli:
      command-group: scaffold
      subcommand: transport
      description: "Generate transport adapter for a communication protocol."
      actions:
        preview:
          command: preview
          description: "Dry-run: compute output files without writing. Uses Emitter content-addressing to show what would change."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "Adapter class name (PascalCase)"
            protocol:
              type: string
              required: true
              short: p
              description: "Protocol type"
              choices: [http, websocket, worker, in-process]
        generate:
          command: transport
          description: "Scaffold a transport adapter with invoke, query, and health methods."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "Adapter class name (PascalCase)"
            protocol:
              type: string
              required: true
              short: p
              description: "Protocol type"
              choices: [http, websocket, worker, in-process]
            base-url:
              type: string
              required: false
              description: "Base URL (for http/websocket)"
              default: "http://localhost:3000"
            output:
              type: string
              required: false
              short: o
              description: "Output directory"
          examples:
            - description: "Generate an HTTP adapter"
              command: "copf scaffold transport --name ApiTransport --protocol http"
            - description: "Generate a WebSocket adapter"
              command: "copf scaffold transport --name RealtimeTransport --protocol websocket --base-url ws://localhost:3000"
            - description: "Generate an in-process adapter for tests"
              command: "copf scaffold transport --name TestTransport --protocol in-process"

  CoifComponentScaffoldGen:
    cli:
      command-group: scaffold
      subcommand: component
      description: "Generate COIF headless component (widget, anatomy, machine, kit)."
      actions:
        preview:
          command: preview
          description: "Dry-run: compute output files without writing. Uses Emitter content-addressing to show what would change."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "PascalCase component name"
            parts:
              type: string
              required: false
              short: p
              description: "Comma-separated anatomy part names"
        generate:
          command: component
          description: "Scaffold a complete COIF headless component with FSM, anatomy, and machine."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "PascalCase component name"
            parts:
              type: string
              required: false
              short: p
              description: "Comma-separated anatomy part names"
              default: "root,trigger,content"
            slots:
              type: string
              required: false
              description: "Comma-separated slot names"
            states:
              type: string
              required: false
              short: s
              description: "Comma-separated FSM state names"
              default: "idle,active"
            events:
              type: string
              required: false
              short: e
              description: "Comma-separated FSM event names"
              default: "open,close"
            role:
              type: string
              required: false
              description: "ARIA role for accessibility"
              default: "widget"
            output:
              type: string
              required: false
              short: o
              description: "Output directory"
          examples:
            - description: "Generate a dialog component"
              command: "copf scaffold component --name Dialog --parts root,trigger,backdrop,content,title,closeTrigger --states closed,open --events open,close,escape"
            - description: "Generate a tabs component"
              command: "copf scaffold component --name Tabs --parts root,list,trigger,content,indicator --states idle,focused,selected --events focus,select,blur"
            - description: "Generate with slots"
              command: "copf scaffold component --name Card --parts root,header,body,footer --slots header,footer"

  CoifThemeScaffoldGen:
    cli:
      command-group: scaffold
      subcommand: theme
      description: "Generate COIF design system theme (palette, typography, motion, elevation)."
      actions:
        preview:
          command: preview
          description: "Dry-run: compute output files without writing. Uses Emitter content-addressing to show what would change."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "Theme name (kebab-case)"
        generate:
          command: theme
          description: "Scaffold a complete design system theme with WCAG-compliant tokens."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "Theme name (kebab-case)"
            primary:
              type: string
              required: false
              short: p
              description: "Primary color hue (0-360) or hex value"
            secondary:
              type: string
              required: false
              description: "Secondary color hue or hex value"
            font:
              type: string
              required: false
              short: f
              description: "Primary font family stack"
              default: "system-ui, -apple-system, sans-serif"
            base-size:
              type: string
              required: false
              description: "Base font size in pixels"
              default: "16"
            scale:
              type: string
              required: false
              description: "Modular ratio for type scale"
              default: "1.25"
            border-radius:
              type: string
              required: false
              description: "Default border radius"
              default: "0.375rem"
            mode:
              type: string
              required: false
              short: m
              description: "Theme mode"
              choices: [light, dark, both]
              default: "both"
            output:
              type: string
              required: false
              short: o
              description: "Output directory"
          examples:
            - description: "Generate a theme with defaults"
              command: "copf scaffold theme --name ocean"
            - description: "Generate a custom theme"
              command: "copf scaffold theme --name brand --primary 220 --font 'Inter, sans-serif' --base-size 18"
            - description: "Generate a light-only theme"
              command: "copf scaffold theme --name print --mode light"
            - description: "Generate a dark theme"
              command: "copf scaffold theme --name midnight --mode dark --primary '#6366f1'"
