# CLEF DevTools — Interface Generation Manifest
#
# Generates Claude Skills and CLI commands from
# framework concept specs. Uses workflow and annotation
# metadata to produce rich, step-based skills that
# match the hand-written originals.
#
# Usage:
#   clef interface generate --manifest examples/devtools/devtools.interface.yaml

interface:
  name: clef-devtools
  version: 0.2.0

# ─── GENERATION TARGETS ──────────────────────────────
targets:
  claude-skills:
    name: clef-devtools
    grouping: per-concept
    outputDir: ./.claude/skills

  cli:
    name: clef
    outputDir: ./cli/src

# ─── CONCEPT SPECS ───────────────────────────────────
# Framework concepts that map to CLI commands and skills.
# Each concept has corresponding actions in its .concept spec.
concepts:
  - specs/framework/spec-parser.concept
  - specs/framework/schema-gen.concept
  - specs/framework/sync-parser.concept
  - specs/framework/sync-compiler.concept
  - specs/framework/flow-trace.concept
  - specs/framework/deployment-validator.concept
  - specs/framework/project-scaffold.concept
  - specs/framework/dev-server.concept
  - specs/framework/suite-manager.concept
  # (Generation and deploy kit concepts removed during restructure)
  # Scaffold generator concepts
  - specs/framework/suite-scaffold-gen.concept
  - specs/framework/deploy-scaffold-gen.concept
  - specs/framework/interface-scaffold-gen.concept
  - specs/framework/concept-scaffold-gen.concept
  - specs/framework/sync-scaffold-gen.concept
  - specs/framework/handler-scaffold-gen.concept
  - specs/framework/storage-adapter-scaffold-gen.concept
  - specs/framework/transport-adapter-scaffold-gen.concept
  - specs/framework/surface-component-scaffold-gen.concept
  - specs/framework/surface-theme-scaffold-gen.concept
  # Interface kit orchestration (bind/)
  - bind/interface/concepts/generator.concept
  - bind/interface/concepts/projection.concept
  - bind/interface/concepts/api-surface.concept
  # (Test kit concepts removed during restructure)
  # Symbol kit (score/)
  - score/symbol/symbol.concept
  - score/symbol/symbol-occurrence.concept
  - score/symbol/scope-graph.concept
  - score/symbol/symbol-relationship.concept
  # Semantic kit (score/)
  - score/semantic/concept-entity.concept
  - score/semantic/action-entity.concept
  - score/semantic/variant-entity.concept
  - score/semantic/state-field.concept
  - score/semantic/sync-entity.concept
  - score/semantic/widget-entity.concept
  - score/semantic/anatomy-part-entity.concept
  - score/semantic/widget-state-entity.concept
  - score/semantic/widget-prop-entity.concept
  - score/semantic/theme-entity.concept
  - score/semantic/interactor-entity.concept
  - score/semantic/runtime-flow.concept
  - score/semantic/runtime-coverage.concept
  - score/semantic/performance-profile.concept
  - score/semantic/error-correlation.concept
  # Analysis kit (score/)
  - score/analysis/dependence-graph.concept
  - score/analysis/data-flow-path.concept
  - score/analysis/program-slice.concept
  - score/analysis/analysis-rule.concept
  # Discovery kit (score/)
  - score/discovery/semantic-embedding.concept
  # Versioning kit (repertoire/)
  - repertoire/versioning/branch.concept
  - repertoire/versioning/change-stream.concept
  - repertoire/versioning/content-hash.concept
  - repertoire/versioning/dag-history.concept
  - repertoire/versioning/diff.concept
  - repertoire/versioning/merge.concept
  - repertoire/versioning/patch.concept
  - repertoire/versioning/ref.concept
  - repertoire/versioning/retention-policy.concept
  - repertoire/versioning/schema-evolution.concept
  - repertoire/versioning/temporal-version.concept
  # Collaboration kit (repertoire/)
  - repertoire/collaboration/attribution.concept
  - repertoire/collaboration/causal-clock.concept
  - repertoire/collaboration/conflict-resolution.concept
  - repertoire/collaboration/inline-annotation.concept
  - repertoire/collaboration/pessimistic-lock.concept
  - repertoire/collaboration/replica.concept
  - repertoire/collaboration/signature.concept
  # Interface suite additional (bind/)
  - bind/interface/concepts/action-guide.concept
  - bind/interface/concepts/enrichment-renderer.concept

# ─── OUTPUT CONFIGURATION ────────────────────────────
output:
  dir: ./generated/devtools
  formatting:
    typescript: prettier
  clean: true

# ─── WORKFLOWS ───────────────────────────────────────
# Define ordered, annotated workflows for skill targets.
# Each workflow maps a concept to a step-by-step guide.

workflows:

  # ─── SpecParser: concept-validator ─────────────────
  concept-validator:
    concept: SpecParser
    steps:
      - action: parse
        title: "Parse and Validate"
        prose: "Parse all .concept specs in the project and report syntax or structural errors."
    checklists:
      parse:
        - "Has purpose block?"
        - "Actions have at least one variant?"
        - "Invariants reference valid actions?"
        - "Type parameters declared and used?"
        - "Variant descriptions explain outcomes, not just echo variant names?"
    design-principles:
      - title: "Spec as Source of Truth"
        rule: "The .concept file is the single authoritative definition — all generated code, tests, and documentation derive from it."
      - title: "Fail Fast on Ambiguity"
        rule: "Parser rejects specs with ambiguous state relations or incomplete action signatures rather than guessing intent."
    references:
      - path: references/concept-grammar.md
        label: "Concept grammar reference"
        tier: reference
        content: |
          # Concept Grammar Reference

          Complete grammar for `.concept` specification files.

          ## Top-Level Structure

          ```
          concept Name [TypeParam, ...] {
            purpose { ... }
            state { ... }
            actions { ... }
            invariants { ... }
          }
          ```

          ## Purpose Block

          ```
          purpose { Free-text description in imperative present tense. }
          ```

          One to three sentences. No implementation details.

          ## State Block

          ```
          state {
            items: set T            # Primary collection
            name: T -> String       # Total function (every T has one)
            email: T -> option String  # Partial (may be absent)
            tags: T -> list String  # Multi-valued
          }
          ```

          **Relation types:**
          | Syntax | Meaning | TypeScript |
          |--------|---------|-----------|
          | `set T` | Collection of T | `Map<id, T>` |
          | `T -> V` | Total function | Required field |
          | `T -> option V` | Partial function | Optional field |
          | `T -> list V` | Multi-valued | Array field |

          ## Actions Block

          ```
          actions {
            action create(name: String, email: String) {
              -> ok(item: T) { New item registered with the provided name and email. }
              -> duplicate(name: String) { Another item already has this name. }
            }
          }
          ```

          - Each action has a name, typed parameters, and one or more **variants**.
          - Variants use `->` arrow syntax: `-> variantName(bindings) { prose }`.
          - At least one variant is required per action.

          **Parameter types:** `String`, `Int`, `Bool`, `T` (type param), `list T`, `option T`.

          ## Invariants Block

          ```
          invariants {
            after create(name) -> ok(item) {
              then { item in items; name(item) = name }
            }
            after delete(item) -> ok {
              then { item not in items }
            }
          }
          ```

          - `after action -> variant { then { assertions } }` — post-condition.
          - Assertions: `field(item) = value`, `item in collection`, `item not in collection`.

          ## Type Parameters

          Declared in brackets after concept name: `concept Name [T, U]`.
          Used throughout state and action signatures. Resolved by syncs at composition time.
      - path: references/jackson-methodology.md
        label: "Jackson's concept design methodology"
        tier: reference
        content: |
          # Jackson's Concept Design Methodology

          Summary of Daniel Jackson's software concept design methodology
          as applied in CLEF.

          ## Five Core Principles

          ### 1. Singularity
          Each concept serves exactly one purpose. If the purpose statement
          contains "and", it should be split into separate concepts.

          ### 2. Independence
          A concept never references another concept directly — no imports,
          no shared types, no cross-concept calls. Concepts communicate only
          through type parameters and syncs.

          ### 3. Sufficiency
          The concept's state and actions are sufficient to fulfill its purpose.
          Every use case implied by the purpose can be served by the declared actions.

          ### 4. Necessity
          Every piece of state is needed by at least one action. Every action
          serves the concept's purpose. No dead state or unused actions.

          ### 5. Invariant Completeness
          Key properties of the concept are captured as formal invariants.
          Invariants document what must always be true after each action completes.

          ## Design Workflow

          1. **Articulate purpose** — Write 1-3 sentences describing what the
             concept is for, not how it works.
          2. **Design state** — Start with the primary collection (`items: set T`),
             then add relations that serve the actions.
          3. **Design actions** — Define verbs with typed parameters and return
             variants. Each variant represents a distinct outcome.
          4. **Write invariants** — For each action+variant, state what must be
             true afterward. This catches design gaps early.
          5. **Validate** — Run `clef check` to verify syntax, completeness, and
             consistency.

          ## Common Concept Patterns

          | Pattern | State Shape | Example |
          |---------|-------------|---------|
          | Entity CRUD | `items: set T; fields: T -> Type` | User, Article |
          | Relationship | `links: set L; from: L -> A; to: L -> B` | Friendship, Membership |
          | Workflow | `items: set T; status: T -> Status` | Order, Approval |
          | Guard | `(no primary state)` | Password, RateLimit |
    validation-commands:
      - label: "Parse and validate all concept specs"
        command: "npx tsx cli/src/index.ts check"
      - label: "Run parser tests"
        command: "npx vitest run tests/spec-parser.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | parse | `clef check <file>` | Validate concept spec syntax and structure |
    related-workflows:
      - name: concept-designer
        description: "Design new concepts following Jackson's methodology"
      - name: implementation-builder
        description: "Write handlers that implement concept actions"
      - name: sync-designer
        description: "Write syncs that connect concepts together"
    anti-patterns:
      - title: "Missing purpose block"
        description: "Concept spec has no purpose — impossible to evaluate design quality."
        bad: |
          concept User [U] {
            state { users: set U; name: U -> String }
            actions { action create(name: String) { -> ok(user: U) { Created. } } }
          }
        good: |
          concept User [U] {
            purpose { Manage user identity and profile information. }
            state { users: set U; name: U -> String }
            actions { action create(name: String) { -> ok(user: U) { New user registered. } } }
          }
      - title: "Terse or echo variant descriptions"
        description: "Variant descriptions that echo the variant name or use a single generic word — they tell the reader nothing about the actual outcome."
        bad: |
          action create(name: String) {
            -> ok(user: U) { Created. }
            -> duplicate(name: String) { Name taken. }
            -> error(message: String) { Failed. }
          }
        good: |
          action create(name: String) {
            -> ok(user: U) { New user registered and ready for authentication setup. }
            -> duplicate(name: String) { A user with this name already exists. }
            -> error(message: String) { Creation failed due to a storage or validation error. }
          }
      - title: "Untyped action parameters"
        description: "Action parameters lack types — generated code will use 'any'."
        bad: |
          action create(name, email) { -> ok(user: U) { Created. } }
        good: |
          action create(name: String, email: String) { -> ok(user: U) { New user registered. } }

  # ─── SpecParser: concept-designer ──────────────────
  concept-designer:
    concept: SpecParser
    steps:
      - action: parse
        title: "Articulate the Purpose"
        prose: "The purpose answers: What is this concept for? Write 1-3 sentences in imperative present tense."
    checklists:
      parse:
        - "Single purpose — no 'and also'?"
        - "Describes why, not what?"
        - "A user would understand it without seeing the implementation?"
    design-principles:
      - title: "Singularity"
        rule: "Each concept serves exactly one purpose — if the purpose has 'and', it's two concepts."
      - title: "Independence"
        rule: "A concept never references another concept's types or calls another concept's actions directly — use type parameters and syncs."
      - title: "Sufficiency & Necessity"
        rule: "Every state field is needed by at least one action, and every action can be served from the declared state."
      - title: "Description Quality"
        rule: "Every variant description must explain the outcome in domain terms — never echo the variant name ('Created.') or use vague text ('Failed.'). Error variants explain what went wrong; ok variants explain what is now true."
    references:
      - path: references/jackson-methodology.md
        label: "Jackson's full methodology"
        tier: reference
        content: |
          # Jackson's Concept Design Methodology

          Summary of Daniel Jackson's software concept design methodology
          as applied in CLEF.

          ## Five Core Principles

          ### 1. Singularity
          Each concept serves exactly one purpose. If the purpose statement
          contains "and", it should be split into separate concepts.

          ### 2. Independence
          A concept never references another concept directly — no imports,
          no shared types, no cross-concept calls. Concepts communicate only
          through type parameters and syncs.

          ### 3. Sufficiency
          The concept's state and actions are sufficient to fulfill its purpose.
          Every use case implied by the purpose can be served by the declared actions.

          ### 4. Necessity
          Every piece of state is needed by at least one action. Every action
          serves the concept's purpose. No dead state or unused actions.

          ### 5. Invariant Completeness
          Key properties of the concept are captured as formal invariants.
          Invariants document what must always be true after each action completes.

          ## Design Workflow

          1. **Articulate purpose** — Write 1-3 sentences describing what the
             concept is for, not how it works.
          2. **Design state** — Start with the primary collection (`items: set T`),
             then add relations that serve the actions.
          3. **Design actions** — Define verbs with typed parameters and return
             variants. Each variant represents a distinct outcome.
          4. **Write invariants** — For each action+variant, state what must be
             true afterward. This catches design gaps early.
          5. **Validate** — Run `clef check` to verify syntax, completeness, and
             consistency.

          ## Common Concept Patterns

          | Pattern | State Shape | Example |
          |---------|-------------|---------|
          | Entity CRUD | `items: set T; fields: T -> Type` | User, Article |
          | Relationship | `links: set L; from: L -> A; to: L -> B` | Friendship, Membership |
          | Workflow | `items: set T; status: T -> Status` | Order, Approval |
          | Guard | `(no primary state)` | Password, RateLimit |
      - path: references/concept-catalog.md
        label: "Reusable concept catalog"
        tier: reference
        content: |
          # Reusable Concept Catalog

          Common concepts that appear across applications. Use as starting
          points — adapt state and actions to your specific purpose.

          ## Identity & Access

          | Concept | Purpose | Key Actions |
          |---------|---------|-------------|
          | User | Manage user identity | create, update, delete, find |
          | Password | Verify credentials | set, check, reset |
          | Session | Track authenticated sessions | start, end, validate |
          | Role | Assign permissions to users | grant, revoke, check |

          ## Content

          | Concept | Purpose | Key Actions |
          |---------|---------|-------------|
          | Article | Manage authored content | create, publish, archive |
          | Tag | Categorize items with labels | add, remove, find |
          | Comment | Attach discussion to items | post, edit, delete |

          ## Commerce

          | Concept | Purpose | Key Actions |
          |---------|---------|-------------|
          | Cart | Collect items for purchase | add, remove, clear |
          | Order | Track purchase lifecycle | place, fulfill, cancel |
          | Payment | Process financial transactions | charge, refund |
          | Invoice | Record financial obligations | issue, pay, void |

          ## Communication

          | Concept | Purpose | Key Actions |
          |---------|---------|-------------|
          | Email | Send transactional messages | send, schedule, cancel |
          | Notification | Alert users of events | create, read, dismiss |

          ## Composition Notes

          These concepts are designed to be independent. Wire them together
          using syncs:

          ```
          sync WelcomeEmail [eager] {
            when { User/create => ok[user: ?u] }
            where { User: { ?u email: ?email } }
            then { Email/send[to: ?email, template: "welcome"] }
          }
          ```
    anti-patterns:
      - title: "Kitchen-sink concept"
        description: "Concept has multiple unrelated purposes — split into separate concepts."
        bad: |
          concept UserAuth [U] {
            purpose { Manage users AND authenticate them. }
          }
        good: |
          concept User [U] { purpose { Manage user identity. } }
          concept Password [U] { purpose { Verify credentials for a user. } }
      - title: "Leaky independence"
        description: "Concept references another concept's types or calls another concept's actions — use type parameters instead."
        bad: |
          concept Order [O] {
            state { customer: O -> User }
          }
        good: |
          concept Order [O, U] {
            state { customer: O -> U }
          }
      - title: "Echo descriptions"
        description: "Variant descriptions that just restate the variant name in slightly different words — they add no information for the reader."
        bad: |
          action publish(item: T) {
            -> ok(item: T) { Published. }
            -> notFound() { Not found. }
            -> unauthorized() { Unauthorized. }
          }
        good: |
          action publish(item: T) {
            -> ok(item: T) { Item is now publicly visible and indexed for search. }
            -> notFound() { No item exists with the given identifier. }
            -> unauthorized() { Current user lacks publish permission for this item. }
          }
    validation-commands:
      - label: "Validate the new concept spec"
        command: "npx tsx cli/src/index.ts check"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Section | What to Write | Key Question |
        |---------|---------------|--------------|
        | purpose | 1-3 sentences | What is this concept for? |
        | state | Relations on type params | What does the concept remember? |
        | actions | Verbs with variants | What can users do? |
        | invariants | after/then assertions | What must always be true? |
    related-workflows:
      - name: concept-validator
        description: "Parse and validate concept specs for syntax errors"
      - name: sync-designer
        description: "Write syncs that connect concepts together"
      - name: implementation-builder
        description: "Write TypeScript handlers for concept actions"
    content-sections:
      - heading: "State Design Principles"
        body: |
          State is what the concept remembers. Start from the purpose — every
          piece of state must serve at least one action. Use the primary
          collection pattern (`items: set T`) and derive everything else as
          relations on T. Avoid storing derived data that can be computed.
        afterStep: 1

  # ─── SyncCompiler: sync-designer ───────────────────
  sync-designer:
    concept: SyncCompiler
    steps:
      - action: compile
        title: "Compile Sync Rules"
        prose: "Compile .sync files that wire concepts together through pattern matching on completions."
    checklists:
      compile:
        - "Sync references valid concept actions?"
        - "Variable bindings are consistent across when/where/then?"
        - "Where-clause queries are well-formed?"
        - "Sync mode (eager vs eventual) matches intent?"
        - "Purpose clause explains the causal chain, not just the sync name?"
    design-principles:
      - title: "Completion Chaining"
        rule: "Syncs compose through completions, never by referencing other syncs — each sync reacts to what happened, not who caused it."
      - title: "Concept Independence"
        rule: "Syncs wire concepts together without the concepts knowing about each other — concepts never import or reference each other."
      - title: "Pattern Exhaustiveness"
        rule: "Every when-clause variant that a sync matches should be explicitly listed — don't rely on fallthrough behavior."
      - title: "Purpose Clause Quality"
        rule: "Every sync must have a purpose clause that explains the causal chain — 'When X happens, do Y because Z'. Never just restate the sync name or omit the purpose entirely."
    references:
      - path: references/sync-design.md
        label: "Sync language and patterns"
        tier: reference
        content: |
          # Sync Language Reference

          Syncs wire concepts together by reacting to completions. A sync
          never calls another sync — it only sees concept action completions.

          ## Sync Declaration

          ```
          sync Name [mode] {
            when { ... }
            where { ... }    # optional
            filter(...)      # optional
            then { ... }
          }
          ```

          **Modes:**
          - `eager` — Executes synchronously within the same transaction.
            Use for data consistency (e.g., creating related records).
          - `eventual` — Queued for async execution. Use for side effects
            (e.g., sending emails, updating caches).

          ## When Clause

          Pattern matches on a concept action completion:

          ```
          when { Concept/action => variant[binding: ?var, ...] }
          ```

          - `Concept/action` — The concept and action to watch.
          - `=> variant` — Which return variant to match.
          - `[binding: ?var]` — Extract values from the completion into variables.

          ## Where Clause

          Queries concept state to bind additional variables:

          ```
          where { Concept: { ?item field: ?value } }
          ```

          - `?item` — Binds to items in the concept's primary collection.
          - `field: ?value` — Binds the field value to a variable.

          ## Filter Clause

          Guards execution with a boolean condition:

          ```
          filter(?count > 0)
          filter(?status = "active")
          ```

          ## Then Clause

          Invokes a target concept action with bound variables:

          ```
          then { Concept/action[param: ?var, ...] }
          ```

          All variables in then must be bound in when or where.

          ## Variable Binding Rules

          1. Variables start with `?` — e.g., `?user`, `?email`.
          2. A variable must be bound (in when or where) before use in then.
          3. Variables are scoped to a single sync — no cross-sync sharing.
      - path: references/sync-patterns.md
        label: "Reusable sync templates"
        tier: reference
        content: |
          # Reusable Sync Patterns

          Common sync patterns for wiring concepts together.

          ## CRUD Chain

          When one entity is created, create related records:

          ```
          sync CreateProfile [eager] {
            when { User/create => ok[user: ?u] }
            then { Profile/create[owner: ?u] }
          }
          ```

          ## Auth-Gated Action

          Validate authentication before allowing an action:

          ```
          sync AuthGate [eager] {
            when { Session/validate => ok[token: ?t] }
            where { Session: { ?t userId: ?uid } }
            then { Article/create[author: ?uid] }
          }
          ```

          ## Notification on Event

          Send async notification when something happens:

          ```
          sync NotifyOnOrder [eventual] {
            when { Order/place => ok[order: ?o] }
            where { Order: { ?o customer: ?c } }
            where { User: { ?c email: ?email } }
            then { Email/send[to: ?email, template: "order-placed"] }
          }
          ```

          ## Cache Invalidation

          Invalidate cache when source data changes:

          ```
          sync InvalidateUserCache [eager] {
            when { User/update => ok[user: ?u] }
            then { Cache/invalidate[key: ?u, namespace: "user"] }
          }
          ```

          ## Cascade Delete

          Clean up related data when a parent is deleted:

          ```
          sync CascadeDelete [eager] {
            when { User/delete => ok[user: ?u] }
            then { Profile/deleteByOwner[owner: ?u] }
          }
          ```

          ## Guarded Sync

          Only fire when a condition is met:

          ```
          sync HighValueOrder [eventual] {
            when { Order/place => ok[order: ?o] }
            where { Order: { ?o total: ?amount } }
            filter(?amount > 1000)
            then { Alert/create[type: "high-value", ref: ?o] }
          }
          ```
    anti-patterns:
      - title: "Sync referencing sync"
        description: "One sync tries to trigger another sync directly instead of reacting to a completion."
        bad: |
          sync BadChain [eager] {
            when { MySyncA/complete => ok }
            then { ConceptB/doThing }
          }
        good: |
          sync GoodChain [eager] {
            when { ConceptA/create => ok[item: ?x] }
            then { ConceptB/process[item: ?x] }
          }
      - title: "Missing or restated purpose"
        description: "Sync has no purpose clause, or the purpose just restates the sync name — readers can't understand why the sync exists."
        bad: |
          sync CreateProfile [eager] {
            when { User/create => ok[user: ?u] }
            then { Profile/create[owner: ?u] }
          }
        good: |
          sync CreateProfile [eager]
            purpose: "Initialize an empty profile automatically when a new user registers"
          {
            when { User/create => ok[user: ?u] }
            then { Profile/create[owner: ?u] }
          }
      - title: "Overly broad pattern match"
        description: "Sync matches all variants of an action instead of the specific one it needs."
        bad: |
          sync TooWide [eager] {
            when { User/register => [user: ?u] }
            then { Email/send[to: ?u] }
          }
        good: |
          sync Precise [eager] {
            when { User/register => ok[user: ?u] }
            then { Email/send[to: ?u] }
          }
    validation-commands:
      - label: "Compile all sync rules"
        command: "npx tsx cli/src/index.ts compile-syncs"
      - label: "Run sync compiler tests"
        command: "npx vitest run tests/sync-compiler.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Clause | Purpose | Example |
        |--------|---------|---------|
        | when | Pattern match on completion | `ConceptA/action => ok[field: ?var]` |
        | where | Query concept state | `ConceptB: { ?item state.field: ?val }` |
        | then | Invoke target action | `ConceptC/action[param: ?var]` |
        | filter | Guard condition | `filter(?val > 0)` |
    related-workflows:
      - name: concept-designer
        description: "Design concepts that syncs connect"
      - name: implementation-builder
        description: "Write handlers for concept actions"
      - name: concept-validator
        description: "Validate concept specs before writing syncs"
    content-sections:
      - heading: "Completion Chaining Pattern"
        body: |
          Syncs compose through completions, not references. A typical
          authenticated CRUD flow chains like this:

          1. `User/login => ok[session: ?s]`
          2. → `Auth/validate[session: ?s] => ok[token: ?t]`
          3. → `Article/create[author: ?t] => ok[article: ?a]`

          Each sync sees only the completion it reacts to — no sync
          knows about the others in the chain.
        afterStep: 1

  # ─── SchemaGen: implementation-builder ─────────────
  implementation-builder:
    concept: SchemaGen
    steps:
      - action: generate
        title: "Generate Schema from Spec"
        prose: "Generate ConceptManifest from parsed AST. The manifest provides typed action signatures for implementation."
    checklists:
      generate:
        - "All action parameters have types?"
        - "Return variants match spec declarations?"
        - "State relations are correctly grouped?"
        - "Type parameters are resolved?"
    design-principles:
      - title: "One Handler per Action"
        rule: "Each action in the concept spec maps to exactly one async method in the implementation handler."
      - title: "Variant Completeness"
        rule: "Every return variant declared in the spec must have a corresponding code path in the handler — no missing branches."
      - title: "Storage Sovereignty"
        rule: "Each concept owns its storage exclusively — no shared databases, no cross-concept state access."
    references:
      - path: references/implementation-patterns.md
        label: "Implementation patterns and storage"
        tier: reference
        content: |
          # Implementation Patterns

          Patterns for writing concept handler implementations.

          ## Handler Structure

          Each concept gets one handler file. Each action maps to one async method:

          ```typescript
          export const userHandler: ConceptHandler<UserState> = {
            async create(input, storage) {
              const id = generateId();
              await storage.set(id, { name: input.name, email: input.email });
              return { variant: 'ok', user: id };
            },

            async delete(input, storage) {
              const exists = await storage.has(input.user);
              if (!exists) return { variant: 'notFound', user: input.user };
              await storage.delete(input.user);
              return { variant: 'ok' };
            },
          };
          ```

          ## Storage Patterns

          **Key-value storage** — Every concept gets isolated key-value storage:
          - `storage.get(key)` — Read a record
          - `storage.set(key, value)` — Write a record
          - `storage.has(key)` — Check existence
          - `storage.delete(key)` — Remove a record
          - `storage.list()` — List all keys

          **Storage sovereignty** — A concept only accesses its own storage.
          Never import or reference another concept's storage.

          ## Return Variants

          Every code path must return one of the declared variants:

          ```typescript
          // Spec declares: -> ok(item: T), -> duplicate(name: String)
          async create(input, storage) {
            const existing = await findByName(input.name, storage);
            if (existing) {
              return { variant: 'duplicate', name: input.name };
            }
            // ... create logic
            return { variant: 'ok', item: id };
          }
          ```

          **Rules:**
          - Every variant from the spec must have a code path.
          - Return object must include `variant` field plus declared bindings.
          - No undeclared variants — the runtime rejects unknown variants.

          ## Error Handling

          - Use variants for expected outcomes (not found, duplicate, invalid).
          - Throw exceptions only for unexpected failures (storage errors, bugs).
          - The runtime wraps thrown exceptions as `error` completions automatically.
      - path: references/type-mapping.md
        label: "Spec-to-TypeScript type mapping rules"
        tier: reference
        content: |
          # Spec-to-TypeScript Type Mapping

          Rules for mapping concept spec types to TypeScript types in
          generated manifests and handler interfaces.

          ## Primitive Types

          | Spec Type | TypeScript Type | Notes |
          |-----------|----------------|-------|
          | `String` | `string` | |
          | `Int` | `number` | Integer values |
          | `Bool` | `boolean` | |
          | `Float` | `number` | Floating point |

          ## Collection Types

          | Spec Type | TypeScript Type | Notes |
          |-----------|----------------|-------|
          | `set T` | `Map<string, T>` | Primary collection keyed by ID |
          | `list T` | `T[]` | Ordered array |
          | `option T` | `T \| undefined` | Nullable/optional |

          ## Relation Types

          | Spec Syntax | TypeScript Type | Meaning |
          |-------------|----------------|---------|
          | `T -> String` | `string` (required field) | Total function |
          | `T -> option String` | `string \| undefined` | Partial function |
          | `T -> list String` | `string[]` | Multi-valued |
          | `T -> set U` | `Set<U>` | Set-valued |

          ## Type Parameters

          Type parameters (`[T, U]`) become generic type arguments.
          In generated code, they resolve to `string` (ID references)
          unless a concrete type is provided by the sync wiring.

          ## Action Signatures

          ```
          // Spec:
          action create(name: String, count: Int) {
            -> ok(item: T) { ... }
          }

          // Generated TypeScript:
          create(input: { name: string; count: number }, storage: Storage)
            : Promise<{ variant: 'ok'; item: string } | ...>
          ```
    validation-commands:
      - label: "Generate manifests from specs"
        command: "npx tsx cli/src/index.ts generate"
      - label: "Run schema generation tests"
        command: "npx vitest run tests/schema-gen.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Spec Type | TypeScript Type | Notes |
        |-----------|----------------|-------|
        | String | string | Direct mapping |
        | Int | number | Direct mapping |
        | Bool | boolean | Direct mapping |
        | list T | T[] | Array mapping |
        | option T | T \| undefined | Optional mapping |
        | set T | Set<T> or Map | Primary collection |
    related-workflows:
      - name: concept-designer
        description: "Design concepts before implementing them"
      - name: concept-validator
        description: "Validate specs before generating schemas"
      - name: sync-designer
        description: "Wire implemented concepts together with syncs"
    anti-patterns:
      - title: "Cross-concept storage access"
        description: "Handler reads or writes another concept's storage — violates sovereignty."
        bad: |
          async create(input, storage) {
            const user = await userStorage.get(input.userId); // Wrong!
            // ...
          }
        good: |
          async create(input, storage) {
            // userId is passed in — concept doesn't know where it came from
            const item = { id: generateId(), owner: input.userId };
            await storage.set(item.id, item);
            return { variant: 'ok', item: item.id };
          }

  # ─── SyncParser: sync-validator ────────────────────
  sync-validator:
    concept: SyncParser
    steps:
      - action: parse
        title: "Parse and Validate Sync Files"
        prose: "Parse .sync files into structured ASTs and validate variable bindings, concept references, and action signatures against loaded manifests."
    checklists:
      parse:
        - "Sync file has valid when/then structure?"
        - "All concept references resolve to loaded manifests?"
        - "Variable bindings are consistent across clauses?"
        - "Action parameters match concept action signatures?"
        - "Sync mode (eager/eventual) is declared?"
    design-principles:
      - title: "Manifest-Aware Validation"
        rule: "Sync validation cross-references concept manifests to verify that referenced actions and parameters actually exist."
      - title: "Early Error Detection"
        rule: "Catch variable binding mismatches and type errors at parse time, not at runtime when the sync fires."
    references:
      - path: references/sync-design.md
        label: "Sync language reference"
        tier: reference
        content: |
          # Sync Language Reference

          Syncs wire concepts together by reacting to completions. A sync
          never calls another sync — it only sees concept action completions.

          ## Sync Declaration

          ```
          sync Name [mode] {
            when { ... }
            where { ... }    # optional
            filter(...)      # optional
            then { ... }
          }
          ```

          **Modes:**
          - `eager` — Synchronous, same transaction. Use for data consistency.
          - `eventual` — Queued async. Use for side effects.

          ## When Clause

          ```
          when { Concept/action => variant[binding: ?var, ...] }
          ```

          ## Where Clause

          ```
          where { Concept: { ?item field: ?value } }
          ```

          ## Filter Clause

          ```
          filter(?count > 0)
          ```

          ## Then Clause

          ```
          then { Concept/action[param: ?var, ...] }
          ```

          ## Variable Binding Rules

          1. Variables start with `?`.
          2. Must be bound in when or where before use in then.
          3. Scoped to a single sync.
      - path: references/sync-patterns.md
        label: "Common sync patterns and templates"
        tier: reference
        content: |
          # Common Sync Patterns

          ## CRUD Chain
          ```
          sync CreateProfile [eager] {
            when { User/create => ok[user: ?u] }
            then { Profile/create[owner: ?u] }
          }
          ```

          ## Notification
          ```
          sync NotifyOnOrder [eventual] {
            when { Order/place => ok[order: ?o] }
            where { Order: { ?o customer: ?c } }
            where { User: { ?c email: ?email } }
            then { Email/send[to: ?email, template: "order-placed"] }
          }
          ```

          ## Cache Invalidation
          ```
          sync InvalidateCache [eager] {
            when { User/update => ok[user: ?u] }
            then { Cache/invalidate[key: ?u, namespace: "user"] }
          }
          ```

          ## Guarded Sync
          ```
          sync HighValue [eventual] {
            when { Order/place => ok[order: ?o] }
            where { Order: { ?o total: ?amount } }
            filter(?amount > 1000)
            then { Alert/create[type: "high-value", ref: ?o] }
          }
          ```
    validation-commands:
      - label: "Parse all sync files"
        command: "npx tsx cli/src/index.ts compile-syncs"
      - label: "Run sync parser tests"
        command: "npx vitest run tests/sync-parser.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Element | Syntax | Purpose |
        |---------|--------|---------|
        | Sync declaration | `sync Name [mode] { ... }` | Define a synchronization rule |
        | When clause | `Concept/action => variant[bindings]` | Pattern match on completion |
        | Where clause | `Concept: { ?item field: ?val }` | Query concept state |
        | Then clause | `Concept/action[params]` | Invoke target action |
    related-workflows:
      - name: sync-designer
        description: "Compile validated sync rules into executables"
      - name: concept-validator
        description: "Validate concept specs referenced by syncs"
    anti-patterns:
      - title: "Unbound variable in then-clause"
        description: "Then-clause uses a variable not bound in when or where — will fail at runtime."
        bad: |
          sync Broken [eager] {
            when { User/create => ok[user: ?u] }
            then { Email/send[to: ?email] }
          }
        good: |
          sync Working [eager] {
            when { User/create => ok[user: ?u] }
            where { User: { ?u email: ?email } }
            then { Email/send[to: ?email] }
          }

  # ─── FlowTrace: trace-debugger ────────────────────
  trace-debugger:
    concept: FlowTrace
    steps:
      - action: build
        title: "Build Execution Trace"
        prose: "Build a trace from a flow ID showing which concepts were invoked, what syncs fired, and data flow between them."
      - action: render
        title: "Render Trace Output"
        prose: "Render the trace tree as a human-readable output with timing, success/failure status, and data flow arrows."
    checklists:
      build:
        - "Flow ID exists in action log?"
        - "All causal links followed (action → sync → action)?"
        - "Timing data captured for each node?"
      render:
        - "Tree indentation correct?"
        - "Failed nodes highlighted?"
        - "Data flow arrows show variable propagation?"
    design-principles:
      - title: "Causal Completeness"
        rule: "The trace shows the complete causal chain — every action that fired because of the initial trigger, not just the immediate effects."
      - title: "Non-Intrusive"
        rule: "Tracing reads the action log — it never modifies runtime behavior or adds overhead to normal execution."
    references:
      - path: references/debugging.md
        label: "Debugging with FlowTrace"
        tier: reference
        content: |
          # Debugging with FlowTrace

          FlowTrace builds causal execution trees from the action log,
          showing every concept action and sync firing triggered by
          an initial action.

          ## Reading a Trace

          ```
          Flow abc-123
          ├─ User/create => ok [user: u1]        2ms
          │  ├─ [sync: CreateProfile] eager
          │  │  └─ Profile/create => ok [profile: p1]  1ms
          │  └─ [sync: WelcomeEmail] eventual
          │     └─ Email/send => ok               45ms
          └─ total: 48ms
          ```

          **Reading the tree:**
          - Root node is the initial action.
          - Indented children are syncs that fired from the parent.
          - `[sync: Name]` shows which sync rule triggered the action.
          - Timing shows per-node and total duration.

          ## Common Debugging Scenarios

          ### Sync didn't fire
          1. Check the when-clause variant matches the actual completion.
          2. Verify variable bindings — a misspelled binding silently fails.
          3. Check sync mode — eventual syncs execute asynchronously.

          ### Unexpected cascade
          1. Look for broad pattern matches (missing variant name).
          2. Check if multiple syncs react to the same completion.
          3. Look for circular chains: A→B→C→A.

          ### Slow execution
          1. Look for deep nesting (long sync chains).
          2. Check eventual syncs for slow external calls.
          3. Look for N+1 patterns in where-clause queries.

          ## Trace Commands

          | Command | Purpose |
          |---------|---------|
          | `clef trace <flow-id>` | Build and display a trace |
          | `clef trace <flow-id> --json` | Output trace as JSON |
          | `clef trace --recent` | Show last 10 flow traces |
    validation-commands:
      - label: "Build a trace"
        command: "npx tsx cli/src/index.ts trace <flow-id>"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | build | `clef trace <flow-id>` | Build trace from a flow ID |
        | render | (automatic) | Render trace as tree output |
    related-workflows:
      - name: sync-designer
        description: "Design the syncs whose execution traces debug"
      - name: concept-validator
        description: "Validate specs before debugging runtime issues"
      - name: dev-workflow
        description: "Run the dev server to generate flow IDs for tracing"
  # ─── DeploymentValidator: deployment-config ────────
  deployment-config:
    concept: DeploymentValidator
    steps:
      - action: validate
        title: "Validate Deployment Manifest"
        prose: "Validate that deployment manifests correctly map concepts to runtimes, assign syncs to engines, and satisfy capability requirements."
    checklists:
      validate:
        - "Every concept mapped to a runtime?"
        - "Sync engine assignments cover all syncs?"
        - "Transport adapters match concept locations?"
        - "Capability requirements satisfied by target runtimes?"
    design-principles:
      - title: "Declarative Deployment"
        rule: "The deployment manifest declares intent (what runs where), not imperative steps — the framework resolves transport and engine assignments."
      - title: "Capability Matching"
        rule: "Each runtime declares capabilities (storage types, transport protocols) and the validator checks that every concept's needs are met."
    references:
      - path: references/deployment-guide.md
        label: "Deployment configuration guide"
        tier: reference
        content: |
          # Deployment Configuration Guide

          A deployment manifest maps concepts to runtimes, assigns syncs
          to engines, and configures transport between runtimes.

          ## Manifest Structure

          ```yaml
          deployment:
            name: my-app
            version: 1.0.0

          runtimes:
            api:
              type: node
              concepts: [User, Article, Comment]
              capabilities: [storage-postgres, transport-http]
            worker:
              type: node
              concepts: [Email, Notification]
              capabilities: [storage-redis, transport-amqp]

          engines:
            default:
              type: in-process
              syncs: [CreateProfile, UpdateCache]
            async:
              type: queue
              syncs: [WelcomeEmail, NotifyOnComment]

          transports:
            api-to-worker:
              type: http
              from: api
              to: worker
              endpoint: http://worker:3001
          ```

          ## Runtime Configuration

          Each runtime declares:
          - **type** — Execution environment (node, deno, edge)
          - **concepts** — Which concepts run in this runtime
          - **capabilities** — Available storage and transport types

          ## Engine Assignment

          Sync engines execute sync rules. Types:
          - `in-process` — Runs within the concept's runtime. For eager syncs.
          - `queue` — Uses a message queue. For eventual syncs.
          - `distributed` — Cross-runtime engine. For multi-runtime syncs.

          ## Validation Rules

          The validator checks:
          1. Every concept is assigned to exactly one runtime.
          2. Every sync is assigned to an engine.
          3. Cross-runtime syncs have a transport adapter configured.
          4. Runtime capabilities satisfy concept requirements.
      - path: references/transport-adapters.md
        label: "Transport adapter configuration"
        tier: reference
        content: |
          # Transport Adapter Reference

          Transport adapters enable cross-runtime communication when
          concepts in different runtimes need to interact through syncs.

          ## Adapter Types

          | Type | Use Case | Latency |
          |------|----------|---------|
          | `http` | REST-based communication | Medium |
          | `websocket` | Bidirectional real-time | Low |
          | `amqp` | Message queue (RabbitMQ) | Medium |
          | `in-process` | Same runtime (no transport) | None |

          ## HTTP Adapter

          ```yaml
          transports:
            api-to-worker:
              type: http
              from: api
              to: worker
              endpoint: http://worker:3001
              timeout: 5000
              retries: 3
          ```

          ## WebSocket Adapter

          ```yaml
          transports:
            realtime:
              type: websocket
              from: api
              to: client
              path: /ws
          ```

          ## AMQP Adapter

          ```yaml
          transports:
            async-bridge:
              type: amqp
              from: api
              to: worker
              url: amqp://rabbitmq:5672
              exchange: clef-events
              queue: worker-tasks
          ```

          ## When to Use Transports

          - **Same runtime**: No transport needed. Syncs run in-process.
          - **Two runtimes, same machine**: Use `http` or `in-process` IPC.
          - **Distributed**: Use `amqp` for reliability or `websocket` for
            low-latency bidirectional communication.
    validation-commands:
      - label: "Validate deployment manifest"
        command: "npx tsx cli/src/index.ts deploy --validate"
      - label: "Run deployment validator tests"
        command: "npx vitest run tests/deployment-validator.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Section | Purpose | Required |
        |---------|---------|----------|
        | runtimes | Map concepts to execution environments | Yes |
        | engines | Assign sync engines to sync groups | Yes |
        | transports | Configure cross-runtime communication | If multi-runtime |
        | capabilities | Declare runtime capabilities | Recommended |
    related-workflows:
      - name: concept-validator
        description: "Validate concept specs before deployment"
      - name: cache-build
        description: "Pre-compile artifacts for faster deployment"
      - name: kit-lifecycle
        description: "Manage suites that bundle deployed concepts"
    anti-patterns:
      - title: "Missing transport for cross-runtime sync"
        description: "Two concepts in different runtimes connected by a sync but no transport adapter configured."
        bad: |
          runtimes:
            api: { concepts: [User] }
            worker: { concepts: [Email] }
          syncs:
            - SendWelcome  # User -> Email, but no transport!
        good: |
          runtimes:
            api: { concepts: [User] }
            worker: { concepts: [Email] }
          transports:
            api-to-worker: { type: http, from: api, to: worker }
          syncs:
            - SendWelcome  # Now has a transport path

  # ─── ProjectScaffold: project-initializer ──────────
  project-initializer:
    concept: ProjectScaffold
    steps:
      - action: scaffold
        title: "Scaffold New Project"
        prose: "Create a new CLEF project directory with specs, syncs, implementations, and configuration files."
    checklists:
      scaffold:
        - "Project name is valid (kebab-case, no conflicts)?"
        - "Directory structure created correctly?"
        - "Example concept spec is parseable?"
        - "Configuration files have sensible defaults?"
    design-principles:
      - title: "Minimal Viable Structure"
        rule: "Scaffold the minimum needed to run `clef check` and `clef generate` — don't overload with unused templates."
      - title: "Convention Over Configuration"
        rule: "Project follows standard directory layout (specs/, syncs/, implementations/) so tools work without configuration."
    references:
      - path: references/project-structure.md
        label: "Standard project directory layout"
        tier: reference
        content: |
          # Standard Project Directory Layout

          A CLEF project follows a convention-over-configuration directory
          structure. Tools expect this layout to work without extra config.

          ## Directory Tree

          ```
          my-app/
          ├── specs/                 # Concept specifications
          │   ├── user.concept
          │   ├── article.concept
          │   └── comment.concept
          ├── syncs/                 # Synchronization rules
          │   ├── create-profile.sync
          │   └── welcome-email.sync
          ├── implementations/       # Handler code
          │   ├── user.handler.ts
          │   ├── article.handler.ts
          │   └── comment.handler.ts
          ├── kits/                  # Reusable concept packages
          │   └── auth-kit/
          │       ├── suite.yaml
          │       ├── concepts/
          │       └── syncs/
          ├── tests/                 # Conformance and integration tests
          │   ├── user.test.ts
          │   └── syncs.test.ts
          ├── generated/             # Auto-generated output (do not edit)
          │   ├── manifests/
          │   └── types/
          ├── deploy.yaml            # Deployment manifest
          └── clef.config.yaml       # Project configuration
          ```

          ## Key Directories

          | Directory | Purpose | File Types |
          |-----------|---------|------------|
          | `specs/` | Concept definitions | `.concept` |
          | `syncs/` | Sync rules | `.sync` |
          | `implementations/` | Handler code | `.handler.ts` |
          | `kits/` | Reusable packages | `suite.yaml` + subdirs |
          | `generated/` | Auto-generated (gitignored) | `.ts`, `.json` |
          | `tests/` | Tests | `.test.ts` |

          ## Configuration File

          ```yaml
          # clef.config.yaml
          project:
            name: my-app
            version: 0.1.0
          specs:
            dir: ./specs
          syncs:
            dir: ./syncs
          output:
            dir: ./generated
          ```
    validation-commands:
      - label: "Validate scaffolded project"
        command: "npx tsx cli/src/index.ts check"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Directory | Purpose | Contains |
        |-----------|---------|----------|
        | specs/ | Concept specifications | .concept files |
        | syncs/ | Synchronization rules | .sync files |
        | implementations/ | Handler code | .handler.ts files |
        | kits/ | Kit manifests | suite.yaml + concepts + syncs |
    related-workflows:
      - name: concept-designer
        description: "Design concepts for the new project"
      - name: kit-lifecycle
        description: "Bundle concepts into reusable kits"
      - name: dev-workflow
        description: "Start the dev server for the new project"

  # ─── SuiteManager: kit-lifecycle ─────────────────────
  kit-lifecycle:
    concept: SuiteManager
    steps:
      - action: init
        title: "Create Kit"
        prose: "Scaffold a new suite directory with suite.yaml, concept and sync subdirectories, and example files."
      - action: validate
        title: "Validate Kit"
        prose: "Validate a suite manifest, its concept specs, sync definitions, and cross-suite references."
      - action: test
        title: "Test Kit"
        prose: "Run conformance and integration tests for the suite."
      - action: list
        title: "List Active Kits"
        prose: "List all suites used by the current application."
      - action: checkOverrides
        title: "Check Overrides"
        prose: "Verify that application sync overrides reference valid syncs in the target kit."
    checklists:
      init:
        - "Kit name follows naming convention?"
        - "Kit.yaml has required fields (name, version, description)?"
        - "Example concept spec is valid?"
      validate:
        - "All concept specs parse successfully?"
        - "All sync files compile?"
        - "Cross-suite references resolve?"
        - "Type parameters align across concepts?"
      test:
        - "Conformance tests pass?"
        - "Integration tests pass?"
        - "No failing assertions?"
      checkOverrides:
        - "Override references valid syncs?"
        - "Override parameters match original sync signature?"
    design-principles:
      - title: "Kit as Reusable Unit"
        rule: "A suite bundles related concepts and syncs into a single distributable package — like an npm package for CLEF."
      - title: "Cross-Kit Isolation"
        rule: "Concepts in one kit never reference concepts in another suite directly — cross-suite integration happens through syncs and type parameter alignment."
      - title: "Required vs Recommended Syncs"
        rule: "Kit syncs are tiered: required syncs are load-bearing, recommended syncs provide useful defaults, integration syncs wire to other suites."
    references:
      - path: references/suite-structure.md
        label: "Kit manifest and directory structure"
        tier: reference
        content: |
          # Suite Manifest and Directory Structure

          A suite bundles related concepts and syncs into a reusable package.

          ## Kit Directory

          ```
          my-kit/
          ├── suite.yaml              # Kit manifest
          ├── concepts/             # Concept specs
          │   ├── user.concept
          │   └── profile.concept
          ├── syncs/                # Internal syncs
          │   └── create-profile.sync
          ├── implementations/      # Default implementations
          │   ├── user.handler.ts
          │   └── profile.handler.ts
          └── tests/                # Kit tests
              └── conformance.test.ts
          ```

          ## Suite Manifest (suite.yaml)

          ```yaml
          suite:
            name: auth
            version: 1.0.0
            description: Authentication and identity management

          concepts:
            - concepts/user.concept
            - concepts/password.concept
            - concepts/session.concept

          syncs:
            required:
              - syncs/validate-session.sync
            recommended:
              - syncs/create-profile.sync
            integration:
              - syncs/audit-login.sync

          typeParameters:
            User: [U]
            Session: [S, U]

          dependencies: []
          ```

          ## Sync Tiers

          | Tier | Meaning | Override? |
          |------|---------|-----------|
          | `required` | Load-bearing, must be active | No |
          | `recommended` | Useful defaults | Yes |
          | `integration` | Wire to other suites | Yes |

          ## Kit vs Application Syncs

          Kit syncs wire concepts *within* the suite. Application syncs
          wire *across* suites. Applications can override recommended
          and integration syncs but not required syncs.
      - path: references/suite-publishing.md
        label: "Publishing and versioning kits"
        tier: reference
        content: |
          # Publishing and Versioning Kits

          ## Versioning

          Kits follow semantic versioning:
          - **Major** — Breaking changes to concept specs or required syncs.
          - **Minor** — New concepts, new optional syncs, new actions.
          - **Patch** — Bug fixes, documentation, implementation improvements.

          ## Publishing Workflow

          1. **Validate** — `clef suite validate ./kits/my-kit`
          2. **Test** — `clef suite test ./kits/my-kit`
          3. **Version** — Update `suite.yaml` version field.
          4. **Package** — `clef suite pack ./kits/my-kit`
          5. **Publish** — `clef suite publish ./kits/my-kit`

          ## Registry

          Kits are published to a registry (npm-compatible):

          ```bash
          # Publish to default registry
          clef suite publish ./kits/my-kit

          # Publish to custom registry
          clef suite publish ./kits/my-kit --registry https://my-registry.com
          ```

          ## Installing Kits

          ```bash
          clef suite add auth@1.0.0
          ```

          This adds the suite to the project's `clef.config.yaml`:

          ```yaml
          kits:
            - name: auth
              version: 1.0.0
              overrides:
                syncs:
                  - syncs/custom-profile.sync  # Override recommended sync
          ```

          ## Breaking Change Guidelines

          When making a breaking change:
          1. Bump major version.
          2. Document migration steps.
          3. Provide a migration sync if state schema changed.
    anti-patterns:
      - title: "Cross-suite concept reference"
        description: "Kit A's concept imports Kit B's types directly instead of using type parameters."
        bad: |
          # In kit-a/concepts/order.concept
          concept Order [O] {
            state { customer: O -> kit_b.User }  # Direct reference!
          }
        good: |
          # In kit-a/concepts/order.concept
          concept Order [O, U] {
            state { customer: O -> U }  # Type parameter, wired by sync
          }
      - title: "Monolithic kit"
        description: "Kit bundles unrelated concepts — violates the reusable unit principle."
        bad: |
          # suite.yaml
          suite: { name: everything }
          concepts: [User, Article, Payment, Analytics, Email, Notification]
        good: |
          # Split into focused kits
          suite: { name: content }   # concepts: [Article, Tag, Comment]
          suite: { name: commerce }  # concepts: [Payment, Invoice, Refund]
    validation-commands:
      - label: "Validate a suite"
        command: "npx tsx cli/src/index.ts suite validate ./kits/my-kit"
      - label: "Run suite tests"
        command: "npx tsx cli/src/index.ts suite test ./kits/my-kit"
      - label: "List active suites"
        command: "npx tsx cli/src/index.ts suite list"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | init | `clef suite init <name>` | Scaffold a new suite |
        | validate | `clef suite validate <path>` | Validate suite manifest |
        | test | `clef suite test <path>` | Run suite tests |
        | list | `clef suite list` | List active suites |
        | checkOverrides | `clef suite check-overrides <path>` | Verify sync overrides |
    related-workflows:
      - name: concept-designer
        description: "Design concepts to include in the suite"
      - name: sync-designer
        description: "Write syncs that wire kit concepts together"
      - name: deployment-config
        description: "Deploy suites to production runtimes"

  # ─── DevServer: dev-workflow ───────────────────────
  dev-workflow:
    concept: DevServer
    steps:
      - action: start
        title: "Start Dev Server"
        prose: "Start a local development server that watches for changes and auto-recompiles."
      - action: status
        title: "Check Status"
        prose: "Check whether the dev server is running and view uptime stats."
      - action: stop
        title: "Stop Server"
        prose: "Stop the running development server."
    checklists:
      start:
        - "Port is available?"
        - "Specs and syncs directories exist?"
        - "Initial compilation succeeds?"
      status:
        - "Server is responsive?"
        - "Last recompile was successful?"
    design-principles:
      - title: "Watch and Recompile"
        rule: "The dev server watches .concept and .sync files for changes and recompiles automatically — no manual rebuild step."
      - title: "Fast Feedback Loop"
        rule: "Recompilation should complete in under a second for typical projects — parse errors show immediately."
    references:
      - path: references/dev-workflow.md
        label: "Development workflow guide"
        tier: reference
        content: |
          # Development Workflow Guide

          The CLEF dev server provides a fast feedback loop for iterating
          on concept specs and sync rules.

          ## Starting the Dev Server

          ```bash
          clef dev --port 3000
          ```

          The dev server:
          1. Parses all `.concept` files in `specs/`.
          2. Compiles all `.sync` files in `syncs/`.
          3. Generates manifests and types.
          4. Watches for file changes and re-runs on save.

          ## Development Cycle

          1. **Edit a .concept file** — Save triggers reparse + validation.
          2. **Edit a .sync file** — Save triggers recompile + binding check.
          3. **Edit a .handler.ts file** — Save triggers type check against manifest.
          4. **View errors** — Parse/compile errors show in terminal immediately.

          ## Watch Mode Behavior

          | File Change | Action Taken |
          |-------------|-------------|
          | `.concept` modified | Reparse spec, regenerate manifest |
          | `.sync` modified | Recompile sync, recheck bindings |
          | `.handler.ts` modified | Type-check against manifest |
          | `clef.config.yaml` modified | Full restart |

          ## Debugging During Dev

          The dev server assigns flow IDs to every action invocation.
          Use `clef trace <flow-id>` to debug execution chains.

          ## Performance

          - Incremental recompilation: only changed files are reprocessed.
          - Typical recompile time: under 100ms for small-medium projects.
          - Full rebuild on config change or first start.
    validation-commands:
      - label: "Start dev server"
        command: "npx tsx cli/src/index.ts dev --port 3000"
      - label: "Check dev server status"
        command: "npx tsx cli/src/index.ts dev status"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | start | `clef dev --port <port>` | Start dev server |
        | status | `clef dev status` | Check if running |
        | stop | `clef dev stop` | Stop the server |
    related-workflows:
      - name: concept-validator
        description: "Validate specs that the dev server watches"
      - name: trace-debugger
        description: "Debug flows generated during dev server sessions"
      - name: cache-build
        description: "Pre-compile for production after dev iteration"
  # ─── SuiteScaffoldGen: suite-scaffold ──────────────────
  suite-scaffold:
    concept: SuiteScaffoldGen
    steps:
      - action: register
        title: "Register Generator"
        prose: "Self-register with PluginRegistry so KindSystem can track KitConfig → KitManifest transformations. Registration is also handled automatically by register-generator-kinds.sync."
      - action: preview
        title: "Preview Changes"
        prose: "Dry-run the generation using Emitter content-addressing to classify each output file as new, changed, or unchanged. No files are written."
      - action: generate
        title: "Generate Suite Manifest"
        prose: "Generate a suite.yaml manifest with concept declarations, sync tier groupings, type parameter alignment, and directory structure stubs. Sync rules then cascade: suite-scaffold-emit.sync routes files through Emitter, suite-scaffold-record-cache.sync records output in BuildCache, and suite-scaffold-observer.sync tracks the run in GenerationPlan."
    checklists:
      generate:
        - "Kit name is kebab-case?"
        - "Version is valid semver?"
        - "All listed concepts have matching .concept stub files?"
        - "Syncs are grouped by tier (required/recommended/integration)?"
        - "Type parameter `as` tags are kebab-case with -ref suffix?"
        - "Dependencies use semver constraints?"
        - "All files written through Emitter (not directly to disk)?"
        - "Source provenance attached to each file?"
        - "Generation step recorded in GenerationPlan?"
    design-principles:
      - title: "Convention Over Configuration"
        rule: "Generated suite.yaml follows the standard layout — concepts at top, syncs by tier, uses for external references. Tools work without extra configuration."
      - title: "Type Parameter Alignment"
        rule: "Every concept's type parameter has an `as` tag that enables cross-concept type alignment. Concepts sharing the same `as` tag share the same entity type."
      - title: "Sync Tier Discipline"
        rule: "Required syncs protect data integrity. Recommended syncs provide useful defaults. Integration syncs wire to external suites. Never promote a recommended sync to required without justification."
    references:
      - path: references/suite-manifest-schema.md
        label: "Kit manifest (suite.yaml) schema reference"
        tier: reference
        content: |
          # Suite Manifest Schema Reference

          Complete schema for `suite.yaml` manifest files.

          ## Root Structure

          ```yaml
          suite:
            name: my-kit           # kebab-case
            version: 0.1.0         # semver
            description: >         # Multi-line description
              What this suite provides.
          ```

          ## Concepts Section

          ```yaml
          concepts:
            ConceptName:
              spec: ./concept-name.concept
              params:
                T: { as: concept-ref, description: "Reference to a ConceptName" }
          ```

          **Rules:**
          - Concept names are PascalCase
          - File names are kebab-case
          - Type parameters are single capital letters
          - The `as` tag enables cross-concept type alignment

          ## Syncs Section

          ```yaml
          syncs:
            required:
              - path: ./syncs/validate-before-save.sync
                description: "Prevents invalid state — removal causes corruption."
            recommended:
              - path: ./syncs/notify-on-change.sync
                name: NotifyOnChange
                description: "Sends notifications — apps can override or disable."
            integration:
              - path: ./syncs/audit-log.sync
                name: AuditLog
                description: "Logs changes — activated by audit kit."
          ```

          | Tier | Overridable | Disableable | When to Use |
          |------|------------|-------------|-------------|
          | required | No | No | Removal causes data corruption |
          | recommended | Yes | Yes | Useful defaults apps can customize |
          | integration | Yes | Depends | Cross-suite wiring |

          ## Uses Section

          ```yaml
          uses:
            - suite: auth
              concepts:
                - name: User
                  params: { U: { as: user-ref } }
            - suite: storage
              optional: true
              concepts:
                - name: Database
          ```

          ## Infrastructure Section (domain suites only)

          ```yaml
          infrastructure:
            transports:
              - name: http
                path: ./transports/http-transport.ts
            storage:
              - name: sqlite
                path: ./storage/sqlite-storage.ts
            deployTemplates:
              - path: ./deploy-templates/default.deploy.yaml
          ```

          ## Dependencies

          ```yaml
          dependencies:
            - auth: ">=1.0.0"
            - surface-core: ">=0.2.0"
          ```
      - path: references/type-alignment.md
        label: "Cross-concept type parameter alignment"
        tier: reference
        content: |
          # Type Parameter Alignment

          Type parameters connect concepts without violating independence.

          ## How It Works

          1. Concept A declares `params: { U: { as: user-ref } }`
          2. Concept B declares `params: { X: { as: user-ref } }`
          3. Both use `user-ref` — the framework unifies A's `U` with B's `X`

          ## Example

          ```yaml
          concepts:
            User:
              spec: ./user.concept
              params:
                U: { as: user-ref }
            Session:
              spec: ./session.concept
              params:
                S: { as: session-ref }
                U: { as: user-ref }    # Same tag → same entity type
          ```

          Now `Session`'s `U` and `User`'s `U` refer to the same entity,
          enabling syncs to pass user references between them.
    validation-commands:
      - label: "Generate a suite scaffold"
        command: "npx tsx cli/src/index.ts scaffold kit --name my-kit --concepts User,Session"
      - label: "Validate generated kit"
        command: "npx tsx cli/src/index.ts suite validate ./kits/my-kit"
      - label: "Run scaffold generator tests"
        command: "npx vitest run tests/scaffold-generators.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Input | Type | Purpose |
        |-------|------|---------|
        | name | String | Kit name (kebab-case) |
        | description | String | Kit purpose description |
        | concepts | list String | PascalCase concept names |
        | syncs | list {name, tier} | Sync declarations with tiers |
        | dependencies | list String | External kit dependencies |
        | isDomain | Boolean | Include infrastructure section |
    related-workflows:
      - name: kit-lifecycle
        description: "Manage kit versions and dependencies after scaffolding"
      - name: concept-scaffold
        description: "Generate concept specs for the suite's concepts"
      - name: sync-scaffold
        description: "Generate sync rules for the suite's syncs"
    anti-patterns:
      - title: "Missing type parameter alignment"
        description: "Concepts in the same suite lack `as` tags, preventing cross-concept type unification."
        bad: |
          concepts:
            User:
              spec: ./user.concept
              params:
                U: {}
            Session:
              spec: ./session.concept
              params:
                S: {}
        good: |
          concepts:
            User:
              spec: ./user.concept
              params:
                U: { as: user-ref }
            Session:
              spec: ./session.concept
              params:
                S: { as: session-ref }
                U: { as: user-ref }
      - title: "Flat sync list without tiers"
        description: "All syncs listed without tier annotation — impossible to know which are safe to override."
        bad: |
          syncs:
            - syncs/validate.sync
            - syncs/notify.sync
            - syncs/audit.sync
        good: |
          syncs:
            required:
              - path: ./syncs/validate.sync
            recommended:
              - path: ./syncs/notify.sync
                name: Notify

  # ─── DeployScaffoldGen: deploy-scaffold ────────────
  deploy-scaffold:
    concept: DeployScaffoldGen
    steps:
      - action: register
        title: "Register Generator"
        prose: "Self-register with PluginRegistry so KindSystem can track DeployConfig → DeployManifest transformations. Registration is also handled automatically by register-generator-kinds.sync."
      - action: preview
        title: "Preview Changes"
        prose: "Dry-run the generation using Emitter content-addressing to classify each output file as new, changed, or unchanged. No files are written."
      - action: generate
        title: "Generate Deploy Manifest"
        prose: "Generate a deploy.yaml manifest with runtime configurations, infrastructure declarations, concept-to-runtime assignments, and build settings. Sync rules then cascade: deploy-scaffold-emit.sync routes files through Emitter, deploy-scaffold-record-cache.sync records output in BuildCache, and deploy-scaffold-observer.sync tracks the run in GenerationPlan."
    checklists:
      generate:
        - "App name is valid?"
        - "Every runtime has a type and transport?"
        - "Infrastructure storage backends match runtime storage refs?"
        - "Every listed concept has a runtime assignment?"
        - "IaC provider is set (terraform, cloudformation, pulumi, docker-compose)?"
        - "Build section specifies compiler and test runner?"
        - "All files written through Emitter (not directly to disk)?"
        - "Source provenance attached to each file?"
        - "Generation step recorded in GenerationPlan?"
    design-principles:
      - title: "Declarative Over Imperative"
        rule: "The deploy manifest declares intent (what runs where) — the framework resolves transport, storage, and engine assignments."
      - title: "Runtime Isolation"
        rule: "Each concept runs in exactly one runtime. Cross-runtime communication uses transport adapters configured in the infrastructure section."
      - title: "Infrastructure as Code"
        rule: "The IaC provider setting enables `clef deploy` to generate Terraform, CloudFormation, or Pulumi resources from the manifest."
    references:
      - path: references/deploy-manifest-schema.md
        label: "Deploy manifest (deploy.yaml) schema reference"
        tier: reference
        content: |
          # Deploy Manifest Schema Reference

          Complete schema for `deploy.yaml` manifest files.

          ## Root Structure

          ```yaml
          app:
            name: my-app
            version: "0.1.0"
          ```

          ## Runtimes

          ```yaml
          runtimes:
            api:
              type: node
              transport: http
              storage: postgresql
              iac: terraform
              config:
                cpu: 256
                memory: 512
                replicas: 2
            worker:
              type: node
              transport: sqs
              storage: redis
            engine:
              engine: true
              transport: http
          ```

          | Field | Required | Description |
          |-------|----------|-------------|
          | type | Yes | Runtime type (node, deno, edge) |
          | transport | Yes | Communication protocol |
          | storage | No | Persistence backend |
          | iac | No | IaC provider for this runtime |
          | config | No | Resource limits and scaling |

          ## Infrastructure

          ```yaml
          infrastructure:
            storage:
              postgresql:
                type: postgresql
                config:
                  host: localhost
                  port: 5432
            transports:
              http:
                type: http
                config:
                  port: 3000
            iac:
              provider: terraform
          ```

          ## Concepts

          ```yaml
          concepts:
            User:
              spec: ./specs/app/user.concept
              implementations:
                - language: typescript
                  path: ./handlers/ts/app/user.handler.ts
                  runtime: api
                  storage: postgresql
          ```

          ## Build

          ```yaml
          build:
            typescript:
              compiler: tsc
              testRunner: vitest
          ```
    validation-commands:
      - label: "Generate a deploy scaffold"
        command: "npx tsx cli/src/index.ts scaffold deploy --app my-app"
      - label: "Validate deploy manifest"
        command: "npx tsx cli/src/index.ts deploy --validate"
      - label: "Run scaffold generator tests"
        command: "npx vitest run tests/scaffold-generators.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Input | Type | Purpose |
        |-------|------|---------|
        | appName | String | Application name |
        | version | String | Semver version |
        | runtimes | list Runtime | Runtime configs (name, type, transport, storage) |
        | concepts | list Assignment | Concept-to-runtime mappings |
        | iacProvider | String | IaC provider (terraform, cloudformation, pulumi) |
    related-workflows:
      - name: deployment-config
        description: "Validate and refine generated deploy manifests"
      - name: suite-scaffold
        description: "Generate suites referenced by the deploy manifest"
      - name: build-orchestration
        description: "Build concepts for the declared runtimes"
    anti-patterns:
      - title: "Concept without runtime assignment"
        description: "Concept listed in deploy manifest but not assigned to any runtime."
        bad: |
          concepts:
            User:
              spec: ./specs/user.concept
              # No implementations or runtime!
        good: |
          concepts:
            User:
              spec: ./specs/user.concept
              implementations:
                - language: typescript
                  runtime: api
                  storage: postgresql
      - title: "Mismatched storage backends"
        description: "Runtime references a storage backend not declared in infrastructure."
        bad: |
          runtimes:
            api: { storage: mongodb }  # Not in infrastructure!
          infrastructure:
            storage:
              postgresql: { type: postgresql }
        good: |
          runtimes:
            api: { storage: postgresql }
          infrastructure:
            storage:
              postgresql: { type: postgresql }

  # ─── InterfaceScaffoldGen: interface-scaffold ──────
  interface-scaffold:
    concept: InterfaceScaffoldGen
    steps:
      - action: register
        title: "Register Generator"
        prose: "Self-register with PluginRegistry so KindSystem can track InterfaceConfig → InterfaceManifest transformations. Registration is also handled automatically by register-generator-kinds.sync."
      - action: preview
        title: "Preview Changes"
        prose: "Dry-run the generation using Emitter content-addressing to classify each output file as new, changed, or unchanged. No files are written."
      - action: generate
        title: "Generate Interface Manifest"
        prose: "Generate an interface.yaml manifest with target configurations (REST, GraphQL, gRPC, CLI, MCP, Claude Skills), SDK settings, spec outputs, and per-concept overrides. Sync rules then cascade: interface-scaffold-emit.sync routes files through Emitter, interface-scaffold-record-cache.sync records output in BuildCache, and interface-scaffold-observer.sync tracks the run in GenerationPlan."
    checklists:
      generate:
        - "Interface name is valid?"
        - "At least one target is specified?"
        - "Each target has sensible defaults?"
        - "SDK package names are unique per language?"
        - "Per-concept overrides reference valid concepts?"
        - "Grouping strategy is set?"
        - "All files written through Emitter (not directly to disk)?"
        - "Source provenance attached to each file?"
        - "Generation step recorded in GenerationPlan?"
    design-principles:
      - title: "Target Independence"
        rule: "Each target (REST, GraphQL, CLI, etc.) generates independently — they share concept specs but produce separate output trees."
      - title: "Layered Configuration"
        rule: "Configuration flows from global defaults → target defaults → per-concept overrides. Specific settings override general ones."
      - title: "SDK Completeness"
        rule: "Each SDK target should generate a fully-functional client library — types, methods, error handling, and documentation."
    references:
      - path: references/interface-manifest-schema.md
        label: "Interface manifest (interface.yaml) schema reference"
        tier: reference
        content: |
          # Interface Manifest Schema Reference

          Complete schema for `interface.yaml` manifest files.

          ## Root Structure

          ```yaml
          interface:
            name: my-api
            version: "0.1.0"
          ```

          ## Targets

          ```yaml
          targets:
            rest:
              basePath: /api
              framework: hono
              versioning: url
            graphql:
              path: /graphql
              relay: true
              subscriptions: true
            grpc:
              package: app.v1
            cli:
              name: my-cli
              shell: [bash, zsh, fish]
            mcp:
              name: my-mcp-server
              transport: stdio
            claude-skills:
              name: my-skills
              progressive: true
          ```

          ## SDKs

          ```yaml
          sdk:
            typescript:
              packageName: "@app/sdk"
              moduleSystem: esm
            python:
              packageName: app-sdk
              asyncSupport: true
            go:
              modulePath: github.com/org/app-sdk-go
            rust:
              packageName: app-sdk
            java:
              packageName: com.org.app.sdk
            swift:
              packageName: AppSDK
          ```

          ## Specs

          ```yaml
          specs:
            openapi: true
            asyncapi: false
          ```

          ## Per-Concept Overrides

          ```yaml
          concepts:
            User:
              rest:
                basePath: /api/users
              graphql:
                typeName: User
            Article:
              rest:
                basePath: /api/articles
          ```

          ## Output

          ```yaml
          output:
            dir: ./generated/interface
            clean: true
          grouping:
            strategy: per-concept
          ```
    validation-commands:
      - label: "Generate an interface scaffold"
        command: "npx tsx cli/src/index.ts scaffold interface --name my-api --targets rest,graphql"
      - label: "Generate interfaces from manifest"
        command: "npx tsx cli/src/index.ts interface generate --manifest my-api.interface.yaml"
      - label: "Run scaffold generator tests"
        command: "npx vitest run tests/scaffold-generators.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Input | Type | Purpose |
        |-------|------|---------|
        | name | String | Interface name |
        | targets | list String | Target types (rest, graphql, grpc, cli, mcp, claude-skills) |
        | sdks | list String | SDK languages (typescript, python, go, rust, java, swift) |
        | concepts | list String | Concepts with per-concept overrides |
        | openapi | Boolean | Generate OpenAPI spec (default: true) |
        | asyncapi | Boolean | Generate AsyncAPI spec (default: false) |
    related-workflows:
      - name: suite-scaffold
        description: "Generate suites whose concepts the interface exposes"
      - name: concept-scaffold
        description: "Generate concept specs for interface concepts"
      - name: deployment-config
        description: "Deploy the service that hosts the generated interface"
    anti-patterns:
      - title: "Targets without concept overrides"
        description: "All concepts use the same REST base path — collision risk."
        bad: |
          targets:
            rest: { basePath: /api }
          # No per-concept overrides — all concepts share /api
        good: |
          targets:
            rest: { basePath: /api }
          concepts:
            User:
              rest: { basePath: /api/users }
            Article:
              rest: { basePath: /api/articles }

  # ─── ConceptScaffoldGen: concept-scaffold ──────────
  concept-scaffold:
    concept: ConceptScaffoldGen
    steps:
      - action: register
        title: "Register Generator"
        prose: "Self-register with PluginRegistry so KindSystem can track ConceptConfig → ConceptSpec transformations. Registration is also handled automatically by register-generator-kinds.sync."
      - action: preview
        title: "Preview Changes"
        prose: "Dry-run the generation using Emitter content-addressing to classify each output file as new, changed, or unchanged. No files are written."
      - action: generate
        title: "Generate Concept Spec"
        prose: "Generate a .concept specification file with purpose block, typed state declarations, action signatures with variants, and a register() action for PluginRegistry discovery. Sync rules then cascade: concept-scaffold-emit.sync routes files through Emitter, concept-scaffold-record-cache.sync records output in BuildCache, and concept-scaffold-observer.sync tracks the run in GenerationPlan."
    checklists:
      generate:
        - "Concept name is PascalCase?"
        - "Type parameter is a single capital letter?"
        - "Purpose block describes why, not what?"
        - "State fields use correct relation types (set, ->, option, list)?"
        - "Every action has at least one variant?"
        - "register() action is included for PluginRegistry?"
        - "Annotations (@category, @visibility) are present?"
        - "Variant descriptions explain outcomes, not just echo variant names?"
        - "All files written through Emitter (not directly to disk)?"
        - "Source provenance attached to each file?"
        - "Generation step recorded in GenerationPlan?"
    design-principles:
      - title: "Singularity"
        rule: "Each concept serves exactly one purpose — if the purpose has 'and', it's two concepts."
      - title: "Independence"
        rule: "A concept never references another concept's types or calls another concept's actions. Use type parameters and syncs."
      - title: "Sufficiency & Necessity"
        rule: "Every state field is needed by at least one action. Every action serves the concept's purpose. No dead state."
      - title: "Invariant Completeness"
        rule: "Key properties are captured as formal invariants documenting what must be true after each action."
      - title: "Description Quality"
        rule: "Every variant description must explain the outcome in domain terms — never echo the variant name ('Created.') or use vague text ('Failed.'). Error variants explain what went wrong; ok variants explain what is now true."
    references:
      - path: references/concept-spec-guide.md
        label: "Concept specification writing guide"
        tier: reference
        content: |
          # Concept Specification Guide

          How to write well-formed `.concept` files.

          ## Structure

          ```
          @category("domain")
          @visibility("public")
          concept Name [T] {
            purpose { ... }
            state { ... }
            actions { ... }
            invariant { ... }
          }
          ```

          ## State Relations

          | Syntax | Meaning | Example |
          |--------|---------|---------|
          | `set T` | Collection | `users: set U` |
          | `T -> V` | Total function | `name: U -> String` |
          | `T -> option V` | Partial function | `email: U -> option String` |
          | `T -> list V` | Multi-valued | `tags: U -> list String` |

          ## Action Signatures

          ```
          action create(name: String, email: String) {
            description { Create a new user with the given name and email. }
            -> ok(user: U) { New user registered and ready for authentication setup. }
            -> duplicate(email: String) { Another user is already registered with this email address. }
            -> error(message: String) { Creation failed due to a storage or validation error. }
          }
          ```

          **Rules:**
          - Every parameter must have a type
          - At least one variant per action
          - Variant names are lowercase
          - `ok` is the conventional success variant

          ## Register Action

          Every generator concept includes `register()`:

          ```
          action register() {
            -> ok(name: String, inputKind: String, outputKind: String,
                  capabilities: list String) {
              Return static metadata for PluginRegistry.
            }
          }
          ```

          ## Invariants

          ```
          invariant {
            after create(name: "alice") -> ok(user: u)
            then create(name: "alice") -> duplicate(email: _)
          }
          ```
    validation-commands:
      - label: "Generate a concept scaffold"
        command: "npx tsx cli/src/index.ts scaffold concept --name User --actions create,update,delete"
      - label: "Validate generated concept"
        command: "npx tsx cli/src/index.ts check specs/app/user.concept"
      - label: "Run scaffold generator tests"
        command: "npx vitest run tests/scaffold-generators.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Input | Type | Purpose |
        |-------|------|---------|
        | name | String | PascalCase concept name |
        | typeParam | String | Type parameter letter (default: T) |
        | purpose | String | Purpose description |
        | category | String | Annotation category (domain, devtools, etc.) |
        | stateFields | list StateField | State declarations |
        | actions | list ActionDef | Action signatures with variants |
    related-workflows:
      - name: concept-designer
        description: "Design concepts using Jackson's methodology before generating"
      - name: handler-scaffold
        description: "Generate handler implementations for the concept"
      - name: sync-scaffold
        description: "Generate sync rules connecting the concept"
    anti-patterns:
      - title: "Purpose describes implementation"
        description: "Purpose block says how the concept works instead of why it exists."
        bad: |
          purpose {
            Store users in a Map<string, User> and provide CRUD operations
            via async handler methods.
          }
        good: |
          purpose {
            Manage user identity and profile information.
          }
      - title: "Missing variants"
        description: "Action only has ok variant — no error handling path."
        bad: |
          action create(name: String) {
            -> ok(user: U) { Created. }
          }
        good: |
          action create(name: String) {
            -> ok(user: U) { New user registered and ready for profile setup. }
            -> duplicate(name: String) { A user with this name already exists. }
            -> error(message: String) { Creation failed due to a storage or validation error. }
          }
      - title: "Terse or echo descriptions"
        description: "Variant descriptions that echo the variant name or use a single generic word — they tell the reader nothing about the actual outcome."
        bad: |
          action create(name: String) {
            -> ok(user: U) { Created. }
            -> error(message: String) { Failed. }
          }
        good: |
          action create(name: String) {
            -> ok(user: U) { New user registered and ready for authentication setup. }
            -> error(message: String) { Creation failed due to a storage or validation error. }
          }

  # ─── SyncScaffoldGen: sync-scaffold ────────────────
  sync-scaffold:
    concept: SyncScaffoldGen
    steps:
      - action: register
        title: "Register Generator"
        prose: "Self-register with PluginRegistry so KindSystem can track SyncConfig → SyncSpec transformations. Registration is also handled automatically by register-generator-kinds.sync."
      - action: preview
        title: "Preview Changes"
        prose: "Dry-run the generation using Emitter content-addressing to classify each output file as new, changed, or unchanged. No files are written."
      - action: generate
        title: "Generate Sync Rule"
        prose: "Generate a .sync file with when clause (trigger pattern), optional where clause (guard conditions), and then clause (effect actions). Sync rules then cascade: sync-scaffold-emit.sync routes files through Emitter, sync-scaffold-record-cache.sync records output in BuildCache, and sync-scaffold-observer.sync tracks the run in GenerationPlan."
    checklists:
      generate:
        - "Sync name is PascalCase?"
        - "Tier annotation matches intended behavior ([eager], [required], [recommended])?"
        - "When clause references a valid concept/action?"
        - "Variable bindings in where clause use ?prefix?"
        - "Then clause references a valid concept/action?"
        - "Purpose statement explains why the sync exists?"
        - "All files written through Emitter (not directly to disk)?"
        - "Source provenance attached to each file?"
        - "Generation step recorded in GenerationPlan?"
    design-principles:
      - title: "Declarative Wiring"
        rule: "Syncs declare what happens when — they never contain imperative logic, loops, or conditionals beyond pattern matching."
      - title: "Concept Independence"
        rule: "Syncs reference concepts by name but concepts never know about syncs. The sync is the only place where concept names appear together."
      - title: "Pattern Completeness"
        rule: "The when clause must match specific action completions (concept/action with variant). The then clause invokes specific actions."
      - title: "Purpose Clause Quality"
        rule: "Every sync must have a purpose clause that explains the causal chain — 'When X happens, do Y because Z'. Never just restate the sync name or omit the purpose entirely."
    references:
      - path: references/sync-rule-guide.md
        label: "Sync rule writing guide"
        tier: reference
        content: |
          # Sync Rule Guide

          How to write well-formed `.sync` files.

          ## Structure

          ```
          sync SyncName [eager]
            purpose: "Why this sync exists — explain the causal chain."
          when {
            SourceConcept/action: [
              field: ?var
            ] => ok(result: ?value)
          }
          where {
            bind(?var.property as ?local)
            query(OtherConcept/find: [criteria: ?local] as ?results)
            any(?local = "value1"; ?local = "value2")
            not(?local = "forbidden")
          }
          then {
            TargetConcept/action: [
              field: ?var;
              other: ?local
            ]
          }
          ```

          ## When Clause

          Matches completions of concept actions:
          - `Concept/action: [params] => variant(results)`
          - Variables use `?` prefix: `?user`, `?name`
          - Can destructure: `metadata: ?meta`

          ## Where Clause (optional)

          Guard conditions:
          - `bind(?expr as ?local)` — Extract nested values
          - `query(Concept/action: [...] as ?result)` — Query state
          - `any(cond1; cond2)` — OR conditions
          - `not(cond)` — Negation
          - `?a = ?b` — Equality check

          ## Then Clause

          Actions to invoke:
          - `Concept/action: [field: ?var]`
          - Multiple actions allowed
          - Variables from when/where are available

          ## Tier Annotations

          | Annotation | Meaning |
          |-----------|---------|
          | `[eager]` | Fires immediately (same as required) |
          | `[required]` | Cannot be disabled or overridden |
          | `[recommended]` | Can be overridden by application |
    validation-commands:
      - label: "Generate a sync scaffold"
        command: "npx tsx cli/src/index.ts scaffold sync --name CreateProfile --from User/create --to Profile/init"
      - label: "Validate generated sync"
        command: "npx tsx cli/src/index.ts sync validate syncs/create-profile.sync"
      - label: "Run scaffold generator tests"
        command: "npx vitest run tests/scaffold-generators.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Input | Type | Purpose |
        |-------|------|---------|
        | name | String | PascalCase sync name |
        | tier | String | Sync tier (required, recommended) |
        | eager | Boolean | Fire immediately (default: true) |
        | trigger | Trigger | When clause (concept, action, params, variant) |
        | conditions | list Condition | Where clause guards |
        | effects | list Effect | Then clause actions |
    related-workflows:
      - name: sync-designer
        description: "Design syncs using formal patterns before generating"
      - name: concept-scaffold
        description: "Generate concept specs referenced by the sync"
      - name: sync-validator
        description: "Validate compiled syncs"
    anti-patterns:
      - title: "Missing or restated purpose"
        description: "Sync has no purpose clause, or the purpose just restates the sync name — readers can't understand why the sync exists."
        bad: |
          sync CreateProfile [eager]
          when { ... }
          then { Profile/create: [owner: ?u] }
        good: |
          sync CreateProfile [eager]
            purpose: "Initialize an empty profile automatically when a new user registers"
          when { ... }
          then { Profile/create: [owner: ?u] }
      - title: "Sync with imperative logic"
        description: "Sync tries to express conditionals or loops instead of pattern matching."
        bad: |
          # Pseudo-code in sync — not valid!
          if user.isAdmin then
            AdminPanel/grant: [user: ?u]
        good: |
          where {
            bind(?meta.role as ?role)
            any(?role = "admin")
          }
          then {
            AdminPanel/grant: [user: ?u]
          }

  # ─── HandlerScaffoldGen: handler-scaffold ──────────
  handler-scaffold:
    concept: HandlerScaffoldGen
    steps:
      - action: register
        title: "Register Generator"
        prose: "Self-register with PluginRegistry so KindSystem can track HandlerConfig → HandlerImpl transformations. Registration is also handled automatically by register-generator-kinds.sync."
      - action: preview
        title: "Preview Changes"
        prose: "Dry-run the generation using Emitter content-addressing to classify each output file as new, changed, or unchanged. No files are written."
      - action: generate
        title: "Generate Handler Implementation"
        prose: "Generate a TypeScript .handler.ts handler with register() action, typed action methods, input extraction, storage patterns, and an optional conformance test. Sync rules then cascade: handler-scaffold-emit.sync routes files through Emitter, handler-scaffold-record-cache.sync records output in BuildCache, and handler-scaffold-observer.sync tracks the run in GenerationPlan."
    checklists:
      generate:
        - "Handler export name follows convention (camelCase + 'Handler')?"
        - "register() returns correct name, inputKind, outputKind?"
        - "Each action extracts input parameters with correct types?"
        - "Each action returns all declared variants?"
        - "Storage operations use correct relation names?"
        - "Error handling catches and wraps exceptions?"
        - "Conformance test covers register() and each action?"
        - "All files written through Emitter (not directly to disk)?"
        - "Source provenance attached to each file?"
        - "Generation step recorded in GenerationPlan?"
    design-principles:
      - title: "One Handler per Action"
        rule: "Each action in the concept spec maps to exactly one async method in the handler."
      - title: "Variant Completeness"
        rule: "Every return variant declared in the spec must have a corresponding code path — no missing branches."
      - title: "Storage Sovereignty"
        rule: "Each concept owns its storage exclusively — no shared databases, no cross-concept state access."
      - title: "Input Extraction"
        rule: "Extract inputs with `as` casts at the top of each method. Validate required fields before processing."
    references:
      - path: references/handler-implementation-guide.md
        label: "Handler implementation patterns"
        tier: reference
        content: |
          # Handler Implementation Guide

          How to implement CLEF concept handlers in TypeScript.

          ## ConceptHandler Interface

          ```typescript
          interface ConceptHandler {
            [actionName: string]: (
              input: Record<string, unknown>,
              storage: ConceptStorage,
            ) => Promise<{ variant: string; [key: string]: unknown }>;
          }
          ```

          ## Standard Pattern

          ```typescript
          export const myConceptHandler: ConceptHandler = {
            async register() {
              return {
                variant: 'ok',
                name: 'MyConcept',
                inputKind: 'MyInput',
                outputKind: 'MyOutput',
                capabilities: JSON.stringify(['cap1', 'cap2']),
              };
            },

            async create(input, storage) {
              const name = input.name as string;
              if (!name) return { variant: 'error', message: 'name required' };

              try {
                const id = crypto.randomUUID();
                await storage.put('items', id, { id, name });
                return { variant: 'ok', item: id };
              } catch (err) {
                const msg = err instanceof Error ? err.message : String(err);
                return { variant: 'error', message: msg };
              }
            },
          };
          ```

          ## Storage Patterns

          | Operation | Method | Example |
          |-----------|--------|---------|
          | Create/Update | `storage.put(rel, key, value)` | `put('items', id, data)` |
          | Read | `storage.get(rel, key)` | `get('items', id)` |
          | Query | `storage.find(rel, criteria)` | `find('items', { status: 'active' })` |
          | Delete | `storage.del(rel, key)` | `del('items', id)` |
          | Bulk delete | `storage.delMany(rel, criteria)` | `delMany('items', { expired: true })` |

          ## Type Mapping

          | Concept Type | TypeScript Type |
          |-------------|----------------|
          | String | string |
          | Int | number |
          | Bool | boolean |
          | list T | T[] |
          | set T | Map<string, T> |
          | option T | T \| undefined |
    validation-commands:
      - label: "Generate a handler scaffold"
        command: "npx tsx cli/src/index.ts scaffold handler --concept User --actions create,update,delete"
      - label: "Run generated conformance test"
        command: "npx vitest run tests/user.conformance.test.ts"
      - label: "Run scaffold generator tests"
        command: "npx vitest run tests/scaffold-generators.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Input | Type | Purpose |
        |-------|------|---------|
        | conceptName | String | PascalCase concept name |
        | actions | list ActionDef | Action signatures with params and variants |
        | inputKind | String | KindSystem input kind |
        | outputKind | String | KindSystem output kind |
        | capabilities | list String | Generator capabilities |
    related-workflows:
      - name: concept-scaffold
        description: "Generate concept specs before implementing handlers"
      - name: implementation-builder
        description: "Use SchemaGen for more advanced handler generation"
      - name: concept-validator
        description: "Validate concept specs before generating handlers"
    anti-patterns:
      - title: "Missing error variant"
        description: "Handler doesn't return error variant on failure — caller gets an unstructured exception."
        bad: |
          async create(input, storage) {
            const id = crypto.randomUUID();
            await storage.put('items', id, { name: input.name });
            return { variant: 'ok', item: id };
            // Exception propagates raw if storage.put fails!
          }
        good: |
          async create(input, storage) {
            try {
              const id = crypto.randomUUID();
              await storage.put('items', id, { name: input.name });
              return { variant: 'ok', item: id };
            } catch (err) {
              return { variant: 'error', message: String(err) };
            }
          }

  # ─── StorageAdapterScaffoldGen: storage-adapter-scaffold ─
  storage-adapter-scaffold:
    concept: StorageAdapterScaffoldGen
    steps:
      - action: register
        title: "Register Generator"
        prose: "Self-register with PluginRegistry so KindSystem can track StorageConfig → StorageAdapter transformations. Registration is also handled automatically by register-generator-kinds.sync."
      - action: preview
        title: "Preview Changes"
        prose: "Dry-run the generation using Emitter content-addressing to classify each output file as new, changed, or unchanged. No files are written."
      - action: generate
        title: "Generate Storage Adapter"
        prose: "Generate a ConceptStorage adapter implementation for the specified backend (SQLite, PostgreSQL, Redis, DynamoDB, or in-memory) with put, get, find, del, and delMany methods. Sync rules then cascade: storage-adapter-scaffold-emit.sync routes files through Emitter, storage-adapter-scaffold-record-cache.sync records output in BuildCache, and storage-adapter-scaffold-observer.sync tracks the run in GenerationPlan."
    checklists:
      generate:
        - "Backend is valid (sqlite, postgresql, redis, dynamodb, memory)?"
        - "Adapter class implements ConceptStorage interface?"
        - "All five methods (put, get, find, del, delMany) are implemented?"
        - "Constructor accepts backend-specific configuration?"
        - "Find method supports criteria-based filtering?"
        - "Proper serialization (JSON.stringify/parse) for non-native types?"
        - "All files written through Emitter (not directly to disk)?"
        - "Source provenance attached to each file?"
        - "Generation step recorded in GenerationPlan?"
    design-principles:
      - title: "Interface Compliance"
        rule: "Every adapter must implement all five ConceptStorage methods — put, get, find, del, delMany. No optional methods."
      - title: "Backend Transparency"
        rule: "Concept handlers use storage through the interface without knowing which backend is active. Swapping backends requires no handler changes."
      - title: "Relation-Key Namespace"
        rule: "Storage is organized by relation name and key. Each concept uses its own relation names, preventing cross-concept conflicts."
    references:
      - path: references/storage-adapter-guide.md
        label: "Storage adapter implementation guide"
        tier: reference
        content: |
          # Storage Adapter Guide

          How to implement ConceptStorage adapters for different backends.

          ## ConceptStorage Interface

          ```typescript
          interface ConceptStorage {
            put(relation: string, key: string, value: Record<string, unknown>): Promise<void>;
            get(relation: string, key: string): Promise<Record<string, unknown> | null>;
            find(relation: string, criteria?: Record<string, unknown>): Promise<Record<string, unknown>[]>;
            del(relation: string, key: string): Promise<void>;
            delMany(relation: string, criteria: Record<string, unknown>): Promise<number>;
          }
          ```

          ## Backend Comparison

          | Backend | Best For | Persistence | Query Power |
          |---------|----------|-------------|-------------|
          | memory | Tests, prototypes | None | In-memory filter |
          | sqlite | Single-node, embedded | File | SQL |
          | postgresql | Production, multi-node | Server | Full SQL |
          | redis | Caching, sessions | Optional | Key-value |
          | dynamodb | Serverless, high-scale | Managed | Key + query |

          ## SQLite Example

          ```typescript
          class SqliteStorage implements ConceptStorage {
            private db: Database;

            constructor(dbPath: string) {
              this.db = new Database(dbPath);
              this.db.exec(`
                CREATE TABLE IF NOT EXISTS concept_store (
                  relation TEXT NOT NULL,
                  key TEXT NOT NULL,
                  value TEXT NOT NULL,
                  PRIMARY KEY (relation, key)
                )
              `);
            }

            async put(relation, key, value) {
              this.db.prepare(
                'INSERT OR REPLACE INTO concept_store VALUES (?, ?, ?)'
              ).run(relation, key, JSON.stringify(value));
            }
            // ... other methods
          }
          ```
    validation-commands:
      - label: "Generate a storage adapter"
        command: "npx tsx cli/src/index.ts scaffold storage --name AppStorage --backend postgresql"
      - label: "Run scaffold generator tests"
        command: "npx vitest run tests/scaffold-generators.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Input | Type | Purpose |
        |-------|------|---------|
        | name | String | Adapter class name (PascalCase) |
        | backend | String | Backend type (sqlite, postgresql, redis, dynamodb, memory) |

        | Backend | Import | Constructor |
        |---------|--------|-------------|
        | sqlite | better-sqlite3 | `new SqliteStorage(dbPath)` |
        | postgresql | pg | `new PgStorage(connectionString)` |
        | redis | redis | `new RedisStorage(url)` |
        | dynamodb | @aws-sdk/client-dynamodb | `new DynamoStorage(region, table)` |
        | memory | (none) | `new MemoryStorage()` |
    related-workflows:
      - name: deployment-config
        description: "Configure storage backends in deploy manifests"
      - name: handler-scaffold
        description: "Generate handlers that use the storage adapter"
    anti-patterns:
      - title: "Missing find criteria filtering"
        description: "Find method ignores criteria parameter — returns all records regardless."
        bad: |
          async find(relation) {
            return this.db.all('SELECT * FROM store WHERE relation = ?', relation);
          }
        good: |
          async find(relation, criteria?) {
            let results = this.db.all('SELECT * FROM store WHERE relation = ?', relation);
            if (criteria) {
              results = results.filter(r =>
                Object.entries(criteria).every(([k, v]) => r[k] === v)
              );
            }
            return results;
          }

  # ─── TransportAdapterScaffoldGen: transport-adapter-scaffold ─
  transport-adapter-scaffold:
    concept: TransportAdapterScaffoldGen
    steps:
      - action: register
        title: "Register Generator"
        prose: "Self-register with PluginRegistry so KindSystem can track TransportConfig → TransportAdapter transformations. Registration is also handled automatically by register-generator-kinds.sync."
      - action: preview
        title: "Preview Changes"
        prose: "Dry-run the generation using Emitter content-addressing to classify each output file as new, changed, or unchanged. No files are written."
      - action: generate
        title: "Generate Transport Adapter"
        prose: "Generate a transport adapter implementation for the specified protocol (HTTP, WebSocket, Worker, or in-process) with invoke, query, and health methods. Sync rules then cascade: transport-adapter-scaffold-emit.sync routes files through Emitter, transport-adapter-scaffold-record-cache.sync records output in BuildCache, and transport-adapter-scaffold-observer.sync tracks the run in GenerationPlan."
    checklists:
      generate:
        - "Protocol is valid (http, websocket, worker, in-process)?"
        - "Adapter implements invoke(), query(), and health()?"
        - "HTTP adapter uses fetch with proper error handling?"
        - "WebSocket adapter manages connection lifecycle?"
        - "Worker adapter handles message passing?"
        - "In-process adapter dispatches to registered handlers?"
        - "All files written through Emitter (not directly to disk)?"
        - "Source provenance attached to each file?"
        - "Generation step recorded in GenerationPlan?"
    design-principles:
      - title: "Protocol Transparency"
        rule: "Concept handlers call invoke/query without knowing the transport. Swapping from HTTP to WebSocket requires no handler changes."
      - title: "Health Monitoring"
        rule: "Every adapter provides a health() method that returns latency and status — enables the framework to detect and route around failures."
      - title: "Connection Lifecycle"
        rule: "Stateful transports (WebSocket, Worker) manage their own connection lifecycle — connect on first use, reconnect on failure, clean up on dispose."
    references:
      - path: references/transport-adapter-guide.md
        label: "Transport adapter implementation guide"
        tier: reference
        content: |
          # Transport Adapter Guide

          How to implement transport adapters for different protocols.

          ## Transport Interface

          ```typescript
          interface ConceptTransport {
            invoke(concept: string, action: string,
                   input: Record<string, unknown>): Promise<Record<string, unknown>>;
            query(concept: string, relation: string,
                  criteria?: Record<string, unknown>): Promise<Record<string, unknown>[]>;
            health(): Promise<{ ok: boolean; latencyMs: number }>;
          }
          ```

          ## Protocol Comparison

          | Protocol | Bidirectional | Latency | Best For |
          |----------|--------------|---------|----------|
          | http | No | Medium | REST APIs, microservices |
          | websocket | Yes | Low | Real-time, subscriptions |
          | worker | No | Very Low | Same-machine parallelism |
          | in-process | N/A | None | Testing, monoliths |

          ## HTTP Adapter

          ```typescript
          async invoke(concept, action, input) {
            const url = `${this.baseUrl}/concepts/${concept}/${action}`;
            const response = await fetch(url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(input),
            });
            return response.json();
          }
          ```

          ## WebSocket Adapter

          Uses request/response correlation with message IDs:
          1. Send `{ id, concept, action, input }` as JSON
          2. Receive `{ id, result }` — match by ID
          3. Resolve the pending promise

          ## When to Use Each

          - **Same runtime**: Use `in-process` — zero overhead
          - **Same machine**: Use `worker` — parallel execution
          - **Same network**: Use `http` — simple and reliable
          - **Real-time**: Use `websocket` — bidirectional streaming
    validation-commands:
      - label: "Generate a transport adapter"
        command: "npx tsx cli/src/index.ts scaffold transport --name ApiTransport --protocol http"
      - label: "Run scaffold generator tests"
        command: "npx vitest run tests/scaffold-generators.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Input | Type | Purpose |
        |-------|------|---------|
        | name | String | Adapter class name (PascalCase) |
        | protocol | String | Protocol (http, websocket, worker, in-process) |
        | baseUrl | String | Base URL for HTTP/WS (default: http://localhost:3000) |
    related-workflows:
      - name: deployment-config
        description: "Configure transport adapters in deploy manifests"
      - name: storage-adapter-scaffold
        description: "Generate storage adapters alongside transport adapters"
    anti-patterns:
      - title: "Missing health check"
        description: "Transport adapter has no health() method — framework can't detect failures."
        bad: |
          class MyTransport {
            async invoke(...) { ... }
            async query(...) { ... }
            // No health()!
          }
        good: |
          class MyTransport {
            async invoke(...) { ... }
            async query(...) { ... }
            async health() {
              const start = Date.now();
              try {
                await fetch(`${this.baseUrl}/health`);
                return { ok: true, latencyMs: Date.now() - start };
              } catch {
                return { ok: false, latencyMs: Date.now() - start };
              }
            }
          }

  # ─── SurfaceComponentScaffoldGen: surface-component-scaffold ─
  surface-component-scaffold:
    concept: SurfaceComponentScaffoldGen
    steps:
      - action: register
        title: "Register Generator"
        prose: "Self-register with PluginRegistry so KindSystem can track ComponentConfig → CoifComponent transformations. Registration is also handled automatically by register-generator-kinds.sync."
      - action: preview
        title: "Preview Changes"
        prose: "Dry-run the generation using Emitter content-addressing to classify each output file as new, changed, or unchanged. No files are written."
      - action: generate
        title: "Generate Clef Surface Component"
        prose: "Generate a complete headless component scaffold including widget specification (FSM), anatomy definition (parts contract), machine implementation, and suite manifest. Sync rules then cascade: surface-component-scaffold-emit.sync routes files through Emitter, surface-component-scaffold-record-cache.sync records output in BuildCache, and surface-component-scaffold-observer.sync tracks the run in GenerationPlan."
    checklists:
      generate:
        - "Component name is PascalCase?"
        - "Parts list defines all structural elements?"
        - "States define all machine states?"
        - "Events define all transitions?"
        - "Anatomy lists all parts and slots?"
        - "Machine implementation has spawn, send, connect, destroy actions?"
        - "Kit manifest declares dependencies on surface-core and surface-component?"
        - "All files written through Emitter (not directly to disk)?"
        - "Source provenance attached to each file?"
        - "Generation step recorded in GenerationPlan?"
    design-principles:
      - title: "Behavior-Rendering Separation"
        rule: "Widget specs define behavior (states, transitions, guards). Rendering is handled by framework adapters. They agree only on part names (anatomy)."
      - title: "Finite State Machine Discipline"
        rule: "Every component is a finite state machine with explicit states, events, transitions, and guards. No implicit state."
      - title: "Anatomy Contract"
        rule: "The anatomy defines named parts (root, trigger, content, etc.) that both the machine and renderer reference. This is the only coupling point."
      - title: "Props API via connect()"
        rule: "The machine's connect() action transforms internal state into framework-neutral props objects — one per anatomy part."
    references:
      - path: references/surface-component-guide.md
        label: "Clef Surface headless component architecture"
        tier: reference
        content: |
          # Clef Surface Component Architecture

          How headless components work in the Clef Surface.

          ## Pipeline

          ```
          Concept Spec → Binding → UISchema → Element Tree
                                                    ↓
                                        Widget Registry (query)
                                                    ↓
                                        Machine (spawn + FSM)
                                                    ↓
                                        connect() → Props API
                                                    ↓
                                        Framework Adapter (React, Vue, etc.)
          ```

          ## Widget Specification

          ```
          widget Dialog {
            anatomy {
              part root
              part trigger
              part backdrop
              part content
              part title
              part description
              part closeTrigger
            }

            machine {
              initial: closed

              state closed {
                on open -> open
              }
              state open {
                on close -> closed
                on escape -> closed
              }
            }

            config {
              closeOnEsc: true
              closeOnOutsideClick: true
              modal: true
            }

            connect {
              rootProps { role: "dialog"; aria-modal: context.modal }
              triggerProps { onClick: actions.open }
              contentProps { data-state: context.state }
              closeTriggerProps { onClick: actions.close }
            }

            accessibility {
              role: "dialog"
              aria-modal: true
              aria-labelledby: titleId
              aria-describedby: descriptionId
            }
          }
          ```

          ## Standard Components

          | Component | Parts | States | Pattern |
          |-----------|-------|--------|---------|
          | Button | root | idle, pressed, disabled | Simple trigger |
          | Dialog | root, trigger, backdrop, content, title, close | closed, open | Overlay |
          | Tabs | root, list, trigger, content, indicator | idle, focused | Selection |
          | Accordion | root, item, trigger, content | collapsed, expanded | Disclosure |
          | Menu | root, trigger, content, item, separator | closed, open | Popup |
          | Tooltip | root, trigger, content, arrow | hidden, visible | Overlay |
          | Select | root, trigger, content, item, indicator | closed, open | Selection |
          | Slider | root, track, range, thumb | idle, dragging | Range |
    validation-commands:
      - label: "Generate a Clef Surface component scaffold"
        command: "npx tsx cli/src/index.ts scaffold component --name Dialog --parts root,trigger,content --states closed,open"
      - label: "Run scaffold generator tests"
        command: "npx vitest run tests/scaffold-generators.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Input | Type | Purpose |
        |-------|------|---------|
        | name | String | PascalCase component name |
        | parts | list String | Anatomy part names (root, trigger, content, etc.) |
        | slots | list String | Named slot insertion points |
        | states | list String | FSM state names |
        | events | list String | FSM event names |
        | a11y | { role, ariaProps } | Accessibility configuration |

        **Output Files:**
        | File | Purpose |
        |------|---------|
        | `{name}-widget.concept` | Widget FSM specification |
        | `{name}-anatomy.concept` | Parts contract definition |
        | `suite.yaml` | Kit manifest with dependencies |
        | `{name}-machine.handler.ts` | Machine handler implementation |
    related-workflows:
      - name: surface-theme-scaffold
        description: "Generate themes to style the component"
      - name: concept-scaffold
        description: "Generate concept specs for custom component concepts"
      - name: suite-scaffold
        description: "Generate suite manifests for component libraries"
    anti-patterns:
      - title: "Rendering logic in widget spec"
        description: "Widget spec includes CSS, HTML, or framework-specific code — violates behavior-rendering separation."
        bad: |
          widget Dialog {
            render {
              <div class="dialog-overlay">  # HTML in spec!
                <div class="dialog-content">...</div>
              </div>
            }
          }
        good: |
          widget Dialog {
            anatomy {
              part root        # Just names — rendering
              part backdrop    # is the adapter's job
              part content
            }
          }
      - title: "Implicit state transitions"
        description: "Component changes state without explicit events — makes behavior unpredictable."
        bad: |
          machine {
            state open {
              # Implicitly closes after 5 seconds — not declarative!
              after 5000ms -> closed
            }
          }
        good: |
          machine {
            state open {
              on close -> closed
              on timeout -> closed  # Explicit event
            }
          }

  # ─── SurfaceThemeScaffoldGen: surface-theme-scaffold ─────
  surface-theme-scaffold:
    concept: SurfaceThemeScaffoldGen
    steps:
      - action: register
        title: "Register Generator"
        prose: "Self-register with PluginRegistry so KindSystem can track ThemeConfig → CoifTheme transformations. Registration is also handled automatically by register-generator-kinds.sync."
      - action: preview
        title: "Preview Changes"
        prose: "Dry-run the generation using Emitter content-addressing to classify each output file as new, changed, or unchanged. No files are written."
      - action: generate
        title: "Generate Clef Surface Theme"
        prose: "Generate a complete design system theme scaffold including palette configuration (OKLCH color scales with WCAG contrast), typography scale (modular ratio), motion definitions (with reduced-motion support), elevation scale (shadow layers), and light/dark theme manifests. Sync rules then cascade: surface-theme-scaffold-emit.sync routes files through Emitter, surface-theme-scaffold-record-cache.sync records output in BuildCache, and surface-theme-scaffold-observer.sync tracks the run in GenerationPlan."
    checklists:
      generate:
        - "Theme name is kebab-case?"
        - "Primary color generates full 50-950 scale?"
        - "Palette has semantic roles (primary, secondary, error, etc.)?"
        - "WCAG contrast ratios meet AA standard (4.5:1 normal, 3:1 large)?"
        - "Typography uses modular ratio scale?"
        - "Motion respects prefers-reduced-motion?"
        - "Elevation scale covers 0-5 levels?"
        - "Light and dark themes are generated (if mode=both)?"
        - "All files written through Emitter (not directly to disk)?"
        - "Source provenance attached to each file?"
        - "Generation step recorded in GenerationPlan?"
    design-principles:
      - title: "Token-Based Design"
        rule: "Every visual value is a named design token — no hardcoded colors, sizes, or shadows anywhere in component code."
      - title: "WCAG Compliance"
        rule: "Every color pair must meet WCAG 2.1 AA contrast (4.5:1 normal text, 3:1 large text). The generator validates at generation time."
      - title: "Reduced Motion Respect"
        rule: "All motion durations collapse to 0ms when prefers-reduced-motion is active. This is built into the motion token system, not opt-in."
      - title: "Theme Layering"
        rule: "Themes are layered: base + variants. Multiple variants can be active simultaneously, resolved by priority then activation order."
    references:
      - path: references/surface-theme-guide.md
        label: "Clef Surface design system and theme architecture"
        tier: reference
        content: |
          # Clef Surface Theme Architecture

          How the design system works in the Clef Surface.

          ## Token Hierarchy

          ```
          Primitive Tokens     →  Semantic Tokens    →  Component Tokens
          color.blue.500           color.primary          button.background
          font.size.base           font.body              input.fontSize
          spacing.4                spacing.md             card.padding
          ```

          ## Palette Generation

          Colors are generated from a seed hue using OKLCH perceptual color space:

          ```json
          {
            "primary": {
              "seed": "220",
              "scale": {
                "50": "hsl(220, 65%, 97%)",
                "100": "hsl(220, 65%, 93%)",
                "500": "hsl(220, 65%, 50%)",
                "900": "hsl(220, 65%, 18%)",
                "950": "hsl(220, 65%, 12%)"
              },
              "roles": {
                "default": "500",
                "hover": "600",
                "active": "700",
                "subtle": "100"
              }
            }
          }
          ```

          ## Typography Scale

          Uses modular ratio (default: major third, 1.25):

          | Name | Scale Factor | Size (16px base) |
          |------|-------------|------------------|
          | xs | 0.64 | 10.24px |
          | sm | 0.80 | 12.80px |
          | base | 1.00 | 16.00px |
          | lg | 1.25 | 20.00px |
          | xl | 1.56 | 25.00px |
          | 2xl | 1.95 | 31.25px |
          | 3xl | 2.44 | 39.06px |

          ## Motion System

          ```json
          {
            "durations": {
              "instant": "0ms",
              "fast": "100ms",
              "normal": "200ms",
              "slow": "300ms"
            },
            "reducedMotion": {
              "respectPreference": true,
              "fallbackDuration": "0ms"
            }
          }
          ```

          ## Elevation Scale

          | Level | Use Case | Shadow |
          |-------|----------|--------|
          | 0 | Flat | none |
          | 1 | Raised (card) | subtle |
          | 2 | Floating (dropdown) | medium |
          | 3 | Overlay (popover) | strong |
          | 4 | Modal (dialog) | heavy |
          | 5 | Top (toast) | maximum |

          ## WCAG Contrast Requirements

          | Standard | Normal Text | Large Text |
          |----------|------------|------------|
          | AA | 4.5:1 | 3:1 |
          | AAA | 7:1 | 4.5:1 |
    validation-commands:
      - label: "Generate a Clef Surface theme scaffold"
        command: "npx tsx cli/src/index.ts scaffold theme --name ocean --primary 220 --font 'Inter, sans-serif'"
      - label: "Run scaffold generator tests"
        command: "npx vitest run tests/scaffold-generators.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Input | Type | Purpose |
        |-------|------|---------|
        | name | String | Theme name (kebab-case) |
        | primaryColor | String | Primary color hue or hex value |
        | secondaryColor | String | Secondary color hue or hex |
        | fontFamily | String | Primary font stack |
        | baseSize | Int | Base font size in pixels (default: 16) |
        | scale | Float | Modular ratio (default: 1.25 major third) |
        | borderRadius | String | Default border radius |
        | mode | String | light, dark, or both (default: both) |

        **Output Files:**
        | File | Purpose |
        |------|---------|
        | `suite.yaml` | Theme suite manifest |
        | `themes/{name}-light.json` | Light theme tokens |
        | `themes/{name}-dark.json` | Dark theme tokens |
        | `tokens/palette.json` | Color scale configuration |
        | `tokens/typography.json` | Type scale and font stacks |
        | `tokens/motion.json` | Animation timing and easing |
        | `tokens/elevation.json` | Shadow scale |
    related-workflows:
      - name: surface-component-scaffold
        description: "Generate components to use the theme tokens"
      - name: suite-scaffold
        description: "Generate suite manifests for theme packages"
    anti-patterns:
      - title: "Hardcoded colors in components"
        description: "Component uses raw hex values instead of design tokens."
        bad: |
          .button { background: #3b82f6; color: #ffffff; }
        good: |
          .button {
            background: var(--color-primary);
            color: var(--color-on-primary);
          }
      - title: "Ignoring reduced motion"
        description: "Animations play regardless of prefers-reduced-motion setting."
        bad: |
          .dialog { transition: transform 300ms ease; }
        good: |
          .dialog {
            transition: transform var(--motion-duration-slow) var(--motion-ease-default);
          }
          @media (prefers-reduced-motion: reduce) {
            .dialog { transition-duration: 0ms; }
          }

# ─── ANNOTATIONS ─────────────────────────────────────
# Rich metadata for skills and CLI: tool permissions,
# argument templates, code examples, references, and
# trigger descriptions.

annotations:
  SpecParser:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when designing, creating, or validating concept specs following
        Jackson's methodology. Covers purpose articulation, state design,
        action design, invariant writing, and spec syntax validation.
      intro-template: >
        Parse and validate concept spec **$ARGUMENTS** to verify syntax,
        structure, and adherence to Jackson's concept design methodology.
      companion-docs:
        - path: examples/design-a-concept.md
          label: "End-to-end concept design walkthrough"
          content: |
            # Walkthrough: Designing a Concept from Scratch

            This walkthrough shows how to design a `Bookmark` concept
            following Jackson's methodology.

            ## Step 1: Articulate the Purpose

            > What is this concept for?

            ```
            purpose { Allow users to save and organize references to items. }
            ```

            - One sentence, imperative present tense.
            - No implementation details (no "stores in database").

            ## Step 2: Design the State

            Start from the purpose. A bookmark needs:
            - A collection of bookmarks
            - Which user owns it
            - Which item it references
            - Optional: a label

            ```
            state {
              bookmarks: set B
              owner: B -> U
              item: B -> I
              label: B -> option String
              created: B -> String
            }
            ```

            ## Step 3: Design the Actions

            What can users do with bookmarks?

            ```
            actions {
              action add(item: I, label: option String) {
                -> ok(bookmark: B) { Bookmark created. }
                -> duplicate(item: I) { Item already bookmarked. }
              }
              action remove(bookmark: B) {
                -> ok { Bookmark removed. }
                -> notFound(bookmark: B) { Bookmark does not exist. }
              }
              action list(owner: U) {
                -> ok(bookmarks: list B) { User's bookmarks returned. }
              }
            }
            ```

            ## Step 4: Write Invariants

            ```
            invariants {
              after add(item) -> ok(bookmark) {
                then { bookmark in bookmarks; item(bookmark) = item }
              }
              after remove(bookmark) -> ok {
                then { bookmark not in bookmarks }
              }
            }
            ```

            ## Step 5: Validate

            ```bash
            clef check specs/bookmark.concept
            ```
      example-walkthroughs:
        - path: examples/design-a-concept.md
          label: "Design a concept from scratch (Bookmark example)"
    parse:
      examples:
        - label: "Parse a concept file"
          language: typescript
          code: |
            import { parseConceptFile } from './parser';
            const ast = parseConceptFile(source);
        - label: "Parse from CLI"
          language: bash
          code: "clef check specs/my-concept.concept"
      references:
        - path: references/concept-grammar.md
          label: "Full concept grammar specification"

  SchemaGen:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when generating ConceptManifests from parsed ASTs, implementing
        concept handlers, or inspecting the schema that drives code generation.
      intro-template: >
        Generate a ConceptManifest from **$ARGUMENTS** that provides typed
        action signatures, state schemas, and invariant test values for
        code generation.
      companion-docs:
        - path: examples/implement-a-handler.md
          label: "End-to-end handler implementation walkthrough"
          content: |
            # Walkthrough: Implementing a Concept Handler

            This walkthrough shows how to implement a handler for the
            `User` concept from spec to working code.

            ## Step 1: Generate the Manifest

            ```bash
            clef generate specs/user.concept
            ```

            This produces `generated/manifests/user.manifest.json` with typed
            action signatures.

            ## Step 2: Create the Handler File

            ```typescript
            // implementations/user.handler.ts
            import type { ConceptHandler, ConceptStorage } from '@clef/kernel';

            interface UserState {
              name: string;
              email: string;
            }

            export const userHandler: ConceptHandler<UserState> = {
              async create(input, storage) {
                // Check for duplicate
                for (const [id, user] of await storage.entries()) {
                  if (user.name === input.name) {
                    return { variant: 'duplicate', name: input.name };
                  }
                }
                // Create
                const id = crypto.randomUUID();
                await storage.set(id, { name: input.name, email: input.email });
                return { variant: 'ok', user: id };
              },

              async delete(input, storage) {
                if (!await storage.has(input.user)) {
                  return { variant: 'notFound', user: input.user };
                }
                await storage.delete(input.user);
                return { variant: 'ok' };
              },
            };
            ```

            ## Step 3: Verify Against Manifest

            Every variant declared in the spec must have a code path:
            - `create → ok` ✓
            - `create → duplicate` ✓
            - `delete → ok` ✓
            - `delete → notFound` ✓

            ## Step 4: Run Tests

            ```bash
            npx vitest run tests/user.test.ts
            ```
      example-walkthroughs:
        - path: examples/implement-a-handler.md
          label: "Implement a concept handler (User example)"
    generate:
      examples:
        - label: "Generate manifest from AST"
          language: typescript
          code: |
            import { schemaGenHandler } from './schema-gen.impl';
            const result = await schemaGenHandler.generate(
              { conceptAst: JSON.stringify(ast) }, storage
            );
        - label: "Generate from CLI"
          language: bash
          code: "clef generate specs/my-concept.concept"
      references:
        - path: references/type-mapping.md
          label: "Spec-to-TypeScript type mapping rules"

  SyncParser:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when parsing and validating .sync files against loaded concept
        manifests. Catches variable binding errors, missing concept references,
        and parameter mismatches at parse time.
      intro-template: >
        Parse sync file **$ARGUMENTS** and validate its structure, variable
        bindings, and concept references against loaded manifests.
      companion-docs:
        - path: examples/validate-a-sync.md
          label: "Sync validation walkthrough"
          content: |
            # Walkthrough: Validating a Sync File

            This walkthrough shows how to validate a sync file and fix
            common errors caught by the parser.

            ## Step 1: Write the Sync

            ```
            sync WelcomeEmail [eager] {
              when { User/create => ok[user: ?u] }
              where { User: { ?u email: ?email } }
              then { Email/send[to: ?email, template: "welcome"] }
            }
            ```

            ## Step 2: Parse and Validate

            ```bash
            clef compile-syncs syncs/welcome-email.sync
            ```

            ## Step 3: Fix Common Errors

            **Unbound variable:**
            ```
            ERROR: Variable ?email in then-clause is not bound
            FIX: Add a where-clause to bind ?email from User state
            ```

            **Missing concept reference:**
            ```
            ERROR: Concept 'Emaill' not found in loaded manifests
            FIX: Check spelling — should be 'Email'
            ```

            **Parameter mismatch:**
            ```
            ERROR: Email/send expects 'to' (String) but got 'to' (Int)
            FIX: Ensure variable type matches action parameter type
            ```
    parse:
      examples:
        - label: "Parse a sync file"
          language: typescript
          code: |
            import { syncParserHandler } from './sync-parser.impl';
            const result = await syncParserHandler.parse(
              { source: syncSource, manifests: loadedManifests }, storage
            );
        - label: "Parse from CLI"
          language: bash
          code: "clef compile-syncs syncs/my-sync.sync"
      references:
        - path: references/sync-design.md
          label: "Sync language reference"

  SyncCompiler:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when compiling parsed sync ASTs into executable registrations
        that the sync engine can evaluate at runtime.
      intro-template: >
        Compile sync rules in **$ARGUMENTS** into executable registrations
        for the sync engine.
      companion-docs:
        - path: examples/write-a-sync-chain.md
          label: "Sync chain composition walkthrough"
          content: |
            # Walkthrough: Writing a Sync Chain

            This walkthrough shows how to compose syncs into a chain
            where each sync reacts to the previous one's completion.

            ## The Scenario

            When a user registers:
            1. Create their profile (eager)
            2. Send a welcome email (eventual)
            3. Notify the admin (eventual)

            ## Step 1: Registration → Profile

            ```
            sync CreateProfile [eager] {
              when { User/create => ok[user: ?u] }
              then { Profile/create[owner: ?u] }
            }
            ```

            ## Step 2: Profile → Welcome Email

            ```
            sync WelcomeEmail [eventual] {
              when { Profile/create => ok[profile: ?p] }
              where { Profile: { ?p owner: ?u } }
              where { User: { ?u email: ?email, name: ?name } }
              then { Email/send[to: ?email, template: "welcome", data: ?name] }
            }
            ```

            ## Step 3: Registration → Admin Notification

            ```
            sync NotifyAdmin [eventual] {
              when { User/create => ok[user: ?u] }
              where { User: { ?u name: ?name } }
              then { Notification/create[type: "new-user", message: ?name] }
            }
            ```

            ## Key Points

            - Each sync sees only the completion it reacts to.
            - Sync 2 reacts to Profile/create, not to User/create.
            - Sync 3 runs independently from Sync 2.
            - Eager syncs run in the same transaction. Eventual syncs are queued.
      example-walkthroughs:
        - path: examples/write-a-sync-chain.md
          label: "Compose a sync chain (registration flow)"
    compile:
      examples:
        - label: "Compile sync rules"
          language: bash
          code: "clef compile-syncs --dir ./syncs"
        - label: "Compile programmatically"
          language: typescript
          code: |
            import { syncCompilerHandler } from './sync-compiler.impl';
            const result = await syncCompilerHandler.compile(
              { sync: parsedSync, ast: syncAst }, storage
            );
      references:
        - path: references/sync-patterns.md
          label: "Reusable sync templates and patterns"

  FlowTrace:
    concept:
      tool-permissions: [Read, Bash]
      argument-template: "<flow-id>"
      trigger-description: >
        Use when debugging action flows, tracing causal chains through
        concept actions and sync firings, or diagnosing why an expected
        sync did not trigger.
      intro-template: >
        Build a debug trace for flow **$ARGUMENTS** showing the causal
        chain of concept actions, sync firings, and data propagation.
      companion-docs:
        - path: examples/debug-a-flow.md
          label: "Flow debugging walkthrough"
          content: |
            # Walkthrough: Debugging a Flow

            This walkthrough shows how to use FlowTrace to debug
            a sync that didn't fire as expected.

            ## The Problem

            A welcome email should be sent when a user registers,
            but no email is being sent.

            ## Step 1: Find the Flow ID

            ```bash
            clef trace --recent
            ```

            Output shows recent flows. Find the User/create flow.

            ## Step 2: Build the Trace

            ```bash
            clef trace abc-123
            ```

            ```
            Flow abc-123
            ├─ User/create => ok [user: u1]        2ms
            │  └─ [sync: CreateProfile] eager
            │     └─ Profile/create => ok [p: p1]   1ms
            └─ total: 3ms
            ```

            ## Step 3: Diagnose

            The WelcomeEmail sync is missing from the trace. Check:

            1. **Is it registered?** — Check `syncs/welcome-email.sync` exists.
            2. **Does the pattern match?** — The sync watches
               `Profile/create => ok`, which DID fire. Check variable bindings.
            3. **Is it eventual?** — Eventual syncs execute asynchronously.
               Check the async queue for pending jobs.

            ## Step 4: Fix

            The sync had a typo in the variant name (`sucess` → `ok`).
            After fixing, the trace shows the complete chain.
    build:
      examples:
        - label: "Build trace from flow ID"
          language: bash
          code: "clef trace <flow-id>"
        - label: "Build trace programmatically"
          language: typescript
          code: |
            import { flowTraceHandler } from './flow-trace.impl';
            const result = await flowTraceHandler.build(
              { flowId: 'abc-123' }, storage
            );
  DeploymentValidator:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when configuring deployment manifests that map concepts to
        runtimes, assign syncs to engines, set up transport adapters,
        and validate capability requirements.
      intro-template: >
        Validate deployment manifest **$ARGUMENTS** against compiled
        concepts and syncs, checking runtime mappings, engine assignments,
        and transport configuration.
      companion-docs:
        - path: examples/configure-deployment.md
          label: "Deployment configuration walkthrough"
          content: |
            # Walkthrough: Configuring a Deployment

            This walkthrough shows how to set up a deployment manifest
            for a two-runtime application.

            ## The Application

            - **API runtime**: User, Article, Comment concepts
            - **Worker runtime**: Email, Notification concepts
            - Syncs cross the boundary (e.g., WelcomeEmail)

            ## Step 1: Define Runtimes

            ```yaml
            runtimes:
              api:
                type: node
                concepts: [User, Article, Comment]
                capabilities: [storage-postgres, transport-http]
              worker:
                type: node
                concepts: [Email, Notification]
                capabilities: [storage-redis, transport-amqp]
            ```

            ## Step 2: Assign Sync Engines

            ```yaml
            engines:
              default:
                type: in-process
                syncs: [CreateProfile, UpdateCache]
              async:
                type: queue
                syncs: [WelcomeEmail, NotifyOnComment]
            ```

            ## Step 3: Configure Transport

            ```yaml
            transports:
              api-to-worker:
                type: http
                from: api
                to: worker
                endpoint: http://worker:3001
            ```

            ## Step 4: Validate

            ```bash
            clef deploy --validate deploy.yaml
            ```
    validate:
      examples:
        - label: "Validate deployment manifest"
          language: bash
          code: "clef deploy --validate app.deploy.yaml"
      references:
        - path: references/deployment-guide.md
          label: "Deployment configuration guide"
        - path: references/transport-adapters.md
          label: "Transport adapter reference"

  ProjectScaffold:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when starting a new CLEF project from scratch. Creates the
        standard directory structure, example concept spec, and
        configuration files.
      intro-template: >
        Scaffold a new CLEF project named **$ARGUMENTS** with the standard
        directory layout, example concept, and configuration files.
      companion-docs:
        - path: templates/concept-template.md
          label: "Concept spec starter template"
          content: |
            # Concept Spec Template

            Use this template when creating a new concept spec file.

            ```
            concept Name [T] {

              purpose {
                One to three sentences describing what this concept is for.
                Use imperative present tense. No implementation details.
              }

              state {
                items: set T
                // Add relations on T:
                // name: T -> String        (required field)
                // label: T -> option String (optional field)
                // tags: T -> list String    (multi-valued)
              }

              actions {
                action create(/* params */) {
                  -> ok(item: T) { Created successfully. }
                  // Add error variants as needed:
                  // -> duplicate(name: String) { Name already taken. }
                  // -> invalid(reason: String) { Validation failed. }
                }

                action delete(item: T) {
                  -> ok { Deleted successfully. }
                  -> notFound(item: T) { Item does not exist. }
                }
              }

              invariants {
                after create(/* params */) -> ok(item) {
                  then { item in items }
                }
                after delete(item) -> ok {
                  then { item not in items }
                }
              }
            }
            ```
    scaffold:
      examples:
        - label: "Scaffold a new project"
          language: bash
          code: "clef init my-app"
        - label: "Scaffold with custom template"
          language: bash
          code: "clef init my-app --template minimal"

  DevServer:
    concept:
      tool-permissions: [Read, Bash]
      argument-template: "--port <port>"
      trigger-description: >
        Use when developing concepts and syncs iteratively. The dev server
        watches for file changes and recompiles automatically, providing
        a fast feedback loop.
      intro-template: >
        Start a development server that watches concept specs and syncs for
        changes and auto-recompiles on save.
      companion-docs:
        - path: examples/dev-iteration-cycle.md
          label: "Development iteration cycle walkthrough"
          content: |
            # Walkthrough: Development Iteration Cycle

            This walkthrough shows a typical edit-validate-test cycle
            using the dev server.

            ## Step 1: Start the Dev Server

            ```bash
            clef dev --port 3000
            ```

            ```
            CLEF dev server started on port 3000
            Watching: specs/, syncs/, implementations/
            Parsed 5 concepts, compiled 3 syncs — all valid
            ```

            ## Step 2: Edit a Concept

            Add a new action to `specs/user.concept`:

            ```
            action updateEmail(user: U, email: String) {
              -> ok { Email updated. }
              -> notFound(user: U) { User not found. }
            }
            ```

            Save → dev server output:
            ```
            [hot] user.concept changed
            [parse] User: valid ✓
            [generate] user.manifest.json updated
            [type] user.d.ts updated
            ```

            ## Step 3: Add a Sync

            Create `syncs/email-updated.sync`:

            ```
            sync NotifyEmailChange [eventual] {
              when { User/updateEmail => ok }
              where { User: { ?u email: ?email } }
              then { Email/send[to: ?email, template: "email-changed"] }
            }
            ```

            Save → dev server output:
            ```
            [hot] email-updated.sync changed
            [compile] NotifyEmailChange: valid ✓
            ```

            ## Step 4: Implement the Handler

            Add the handler method in `implementations/user.handler.ts`,
            then run tests to verify.
    start:
      examples:
        - label: "Start dev server"
          language: bash
          code: "clef dev --port 3000"
    status:
      examples:
        - label: "Check dev server status"
          language: bash
          code: "clef dev status"
    stop:
      examples:
        - label: "Stop dev server"
          language: bash
          code: "clef dev stop"

  SuiteManager:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when creating, validating, testing, or managing suites.
        Covers the full kit lifecycle from scaffolding to publishing.
      intro-template: >
        Manage kit **$ARGUMENTS** — scaffold, validate, test, and publish
        reusable concept packages.
      companion-docs:
        - path: examples/create-a-suite.md
          label: "Kit creation walkthrough"
          content: |
            # Walkthrough: Creating a Kit

            This walkthrough shows how to create, validate, and test
            a reusable suite.

            ## Step 1: Scaffold

            ```bash
            clef suite init auth-kit
            ```

            Creates:
            ```
            auth-kit/
            ├── suite.yaml
            ├── concepts/
            │   └── example.concept
            ├── syncs/
            └── tests/
            ```

            ## Step 2: Add Concepts

            Move your concept specs into `concepts/`:

            ```bash
            cp specs/user.concept auth-kit/concepts/
            cp specs/password.concept auth-kit/concepts/
            cp specs/session.concept auth-kit/concepts/
            ```

            ## Step 3: Update suite.yaml

            ```yaml
            suite:
              name: auth
              version: 1.0.0
              description: Authentication and identity management

            concepts:
              - concepts/user.concept
              - concepts/password.concept
              - concepts/session.concept

            syncs:
              required:
                - syncs/validate-session.sync
            ```

            ## Step 4: Validate and Test

            ```bash
            clef suite validate ./auth-kit
            clef suite test ./auth-kit
            ```
      example-walkthroughs:
        - path: examples/create-a-suite.md
          label: "Create a reusable suite (auth example)"
    init:
      examples:
        - label: "Create a new suite"
          language: bash
          code: "clef suite init my-kit"
    validate:
      examples:
        - label: "Validate a suite"
          language: bash
          code: "clef suite validate ./kits/my-kit"
    test:
      examples:
        - label: "Test a suite"
          language: bash
          code: "clef suite test ./kits/my-kit"
    list:
      examples:
        - label: "List active suites"
          language: bash
          code: "clef suite list"
    checkOverrides:
      examples:
        - label: "Check sync overrides"
          language: bash
          code: "clef suite check-overrides ./kits/my-kit"
  SuiteScaffoldGen:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "--name <suite-name>"
      trigger-description: >
        Use when creating a new CLEF kit from scratch. Generates a suite.yaml
        manifest with concept declarations, sync tier groupings, type parameter
        alignment, and directory structure stubs.
      intro-template: >
        Scaffold a new CLEF kit named **$ARGUMENTS** with a suite.yaml manifest,
        concept spec stubs, and sync directory structure.
      companion-docs:
        - path: examples/scaffold-a-suite.md
          label: "End-to-end suite scaffolding walkthrough"
          content: |
            # Walkthrough: Scaffolding a New Kit

            This walkthrough creates an `auth` kit with User, Session, and
            Password concepts.

            ## Step 1: Generate the Suite Scaffold

            ```bash
            clef scaffold kit --name auth --concepts User,Session,Password
            ```

            Output:
            ```
            Created auth/suite.yaml
            Created auth/user.concept (stub)
            Created auth/session.concept (stub)
            Created auth/password.concept (stub)
            Created auth/syncs/.gitkeep
            ```

            ## Step 2: Edit the Concept Stubs

            Open `auth/user.concept` and replace the TODO with your design:

            ```
            concept User [U] {
              purpose { Manage user identity and profile information. }
              state {
                users: set U
                name: U -> String
                email: U -> String
              }
              actions {
                action create(name: String, email: String) {
                  -> ok(user: U) { User created. }
                  -> duplicate(email: String) { Email already registered. }
                }
              }
            }
            ```

            ## Step 3: Add Type Alignment

            Edit `auth/suite.yaml` to align type parameters:

            ```yaml
            concepts:
              User:
                params: { U: { as: user-ref } }
              Session:
                params:
                  S: { as: session-ref }
                  U: { as: user-ref }  # Same user-ref!
            ```

            ## Step 4: Validate

            ```bash
            clef suite validate ./kits/auth
            ```
    register:
      examples:
        - label: "Register the suite scaffold generator"
          language: typescript
          code: |
            const result = await kitScaffoldGenHandler.register({}, storage);
            // { variant: 'ok', name: 'SuiteScaffoldGen', inputKind: 'KitConfig', ... }
    generate:
      examples:
        - label: "Generate a basic kit"
          language: bash
          code: "clef scaffold kit --name auth --concepts User,Session,Password"
        - label: "Generate a domain suite with infrastructure"
          language: bash
          code: "clef scaffold kit --name web3 --concepts Token,Wallet --domain"
        - label: "Generate programmatically"
          language: typescript
          code: |
            import { kitScaffoldGenHandler } from './suite-scaffold-gen.impl';
            const result = await kitScaffoldGenHandler.generate({
              name: 'auth',
              description: 'Authentication and identity management.',
              concepts: ['User', 'Session', 'Password'],
              syncs: [
                { name: 'ValidateSession', tier: 'required' },
                { name: 'RefreshExpired', tier: 'recommended' },
              ],
            }, storage);
      references:
        - path: references/suite-manifest-schema.md
          label: "Kit manifest schema reference"

  DeployScaffoldGen:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "--app <app-name>"
      trigger-description: >
        Use when creating a new deployment manifest for a CLEF application.
        Generates deploy.yaml with runtime configurations, infrastructure
        declarations, concept-to-runtime assignments, and build settings.
      intro-template: >
        Scaffold a deploy.yaml manifest for application **$ARGUMENTS** with
        runtime configs, infrastructure, and concept assignments.
      companion-docs:
        - path: examples/scaffold-deploy.md
          label: "Deployment manifest scaffolding walkthrough"
          content: |
            # Walkthrough: Scaffolding a Deployment Manifest

            This walkthrough creates a deploy manifest for a multi-runtime
            application.

            ## Step 1: Generate the Deploy Scaffold

            ```bash
            clef scaffold deploy --app conduit \
              --runtimes api:node:http:postgresql,worker:node:sqs:redis \
              --iac terraform
            ```

            ## Step 2: Assign Concepts to Runtimes

            Edit `deploy/conduit.deploy.yaml`:

            ```yaml
            concepts:
              User:
                spec: ./specs/app/user.concept
                implementations:
                  - language: typescript
                    runtime: api
                    storage: postgresql
              Email:
                spec: ./specs/app/email.concept
                implementations:
                  - language: typescript
                    runtime: worker
                    storage: redis
            ```

            ## Step 3: Add Sync Assignments

            ```yaml
            syncs:
              - path: ./syncs/welcome-email.sync
                engine: engine
                annotations: [eventual]
            ```

            ## Step 4: Validate

            ```bash
            clef deploy --validate deploy/conduit.deploy.yaml
            ```
    register:
      examples:
        - label: "Register the deploy scaffold generator"
          language: typescript
          code: |
            const result = await deployScaffoldGenHandler.register({}, storage);
    generate:
      examples:
        - label: "Generate a basic deploy manifest"
          language: bash
          code: "clef scaffold deploy --app my-app"
        - label: "Generate with custom runtimes"
          language: bash
          code: "clef scaffold deploy --app conduit --iac terraform"
        - label: "Generate programmatically"
          language: typescript
          code: |
            import { deployScaffoldGenHandler } from './deploy-scaffold-gen.impl';
            const result = await deployScaffoldGenHandler.generate({
              appName: 'conduit',
              runtimes: [
                { name: 'api', type: 'node', transport: 'http', storage: 'postgresql' },
                { name: 'worker', type: 'node', transport: 'sqs', storage: 'redis' },
              ],
              concepts: [
                { name: 'User', runtime: 'api' },
                { name: 'Article', runtime: 'api' },
              ],
              iacProvider: 'terraform',
            }, storage);
      references:
        - path: references/deploy-manifest-schema.md
          label: "Deploy manifest schema reference"

  InterfaceScaffoldGen:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "--name <interface-name>"
      trigger-description: >
        Use when creating a new interface generation manifest. Generates
        interface.yaml with target configurations for REST, GraphQL, gRPC,
        CLI, MCP, and Claude Skills, plus SDK settings and spec outputs.
      intro-template: >
        Scaffold an interface.yaml for **$ARGUMENTS** with target configs,
        SDK settings, and per-concept overrides.
      companion-docs:
        - path: examples/scaffold-interface.md
          label: "Interface manifest scaffolding walkthrough"
          content: |
            # Walkthrough: Scaffolding an Interface Manifest

            This walkthrough creates an interface manifest for a REST +
            GraphQL API with TypeScript and Python SDKs.

            ## Step 1: Generate the Interface Scaffold

            ```bash
            clef scaffold interface --name conduit-api \
              --targets rest,graphql \
              --sdks typescript,python \
              --concepts User,Article,Comment
            ```

            ## Step 2: Customize Target Settings

            Edit `conduit-api.interface.yaml`:

            ```yaml
            targets:
              rest:
                basePath: /api/v1
                framework: hono
              graphql:
                path: /graphql
                relay: true
                subscriptions: true
            ```

            ## Step 3: Add Per-Concept Overrides

            ```yaml
            concepts:
              User:
                rest:
                  basePath: /api/v1/users
                graphql:
                  typeName: User
              Article:
                rest:
                  basePath: /api/v1/articles
            ```

            ## Step 4: Generate Interfaces

            ```bash
            clef interface generate --manifest conduit-api.interface.yaml
            ```
    register:
      examples:
        - label: "Register the interface scaffold generator"
          language: typescript
          code: |
            const result = await interfaceScaffoldGenHandler.register({}, storage);
    generate:
      examples:
        - label: "Generate a REST + GraphQL interface"
          language: bash
          code: "clef scaffold interface --name my-api --targets rest,graphql --sdks typescript"
        - label: "Generate a full-stack interface"
          language: bash
          code: "clef scaffold interface --name my-api --targets rest,graphql,grpc,cli,mcp,claude-skills --sdks typescript,python,go"
      references:
        - path: references/interface-manifest-schema.md
          label: "Interface manifest schema reference"

  ConceptScaffoldGen:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "--name <ConceptName>"
      trigger-description: >
        Use when creating a new concept specification from scratch. Generates
        a .concept file with purpose, state, actions, variants, invariants,
        and a register() action following Jackson's methodology.
      intro-template: >
        Scaffold a concept spec for **$ARGUMENTS** with state declarations,
        typed action signatures, and a register() action.
      companion-docs:
        - path: examples/scaffold-concept.md
          label: "Concept spec scaffolding walkthrough"
          content: |
            # Walkthrough: Scaffolding a Concept Spec

            This walkthrough creates a `Bookmark` concept from inputs.

            ## Step 1: Generate the Concept Scaffold

            ```bash
            clef scaffold concept --name Bookmark \
              --param B \
              --purpose "Allow users to save and organize references to items." \
              --actions add,remove,list
            ```

            ## Step 2: Refine State Fields

            Edit `bookmark.concept`:

            ```
            state {
              bookmarks: set B
              owner: B -> U        # who owns it
              item: B -> I         # what it references
              label: B -> option String
            }
            ```

            ## Step 3: Refine Action Signatures

            ```
            action add(item: I, label: option String) {
              -> ok(bookmark: B) { Bookmark created. }
              -> duplicate(item: I) { Item already bookmarked. }
            }
            ```

            ## Step 4: Add Invariants

            ```
            invariant {
              after add(item: i) -> ok(bookmark: b)
              then add(item: i) -> duplicate(item: i)
            }
            ```

            ## Step 5: Validate

            ```bash
            clef check specs/app/bookmark.concept
            ```
    register:
      examples:
        - label: "Register the concept scaffold generator"
          language: typescript
          code: |
            const result = await conceptScaffoldGenHandler.register({}, storage);
    generate:
      examples:
        - label: "Generate a basic concept"
          language: bash
          code: "clef scaffold concept --name User --actions create,update,delete"
        - label: "Generate with custom state"
          language: bash
          code: "clef scaffold concept --name Article --param A --category domain"
      references:
        - path: references/concept-spec-guide.md
          label: "Concept specification writing guide"

  SyncScaffoldGen:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "--name <SyncName>"
      trigger-description: >
        Use when creating a new sync rule to connect concepts. Generates a
        .sync file with when/where/then clauses from trigger and effect
        configurations.
      intro-template: >
        Scaffold a sync rule **$ARGUMENTS** with trigger patterns, guard
        conditions, and effect actions.
      companion-docs:
        - path: examples/scaffold-sync.md
          label: "Sync rule scaffolding walkthrough"
          content: |
            # Walkthrough: Scaffolding a Sync Rule

            This walkthrough creates a sync that auto-creates a profile
            when a user is created.

            ## Step 1: Generate the Sync Scaffold

            ```bash
            clef scaffold sync --name CreateProfile \
              --from User/create \
              --to Profile/init \
              --tier required
            ```

            ## Step 2: Refine the Pattern

            Edit `create-profile.sync`:

            ```
            sync CreateProfile [eager]
              purpose { Auto-create a profile when a user registers. }
            when {
              User/create: [
                name: ?name;
                email: ?email
              ] => ok(user: ?u)
            }
            then {
              Profile/init: [
                owner: ?u;
                displayName: ?name
              ]
            }
            ```

            ## Step 3: Add Guard Conditions (optional)

            ```
            where {
              not(query(Profile/find: [owner: ?u] as ?existing))
            }
            ```

            ## Step 4: Validate

            ```bash
            clef sync validate syncs/create-profile.sync
            ```
    register:
      examples:
        - label: "Register the sync scaffold generator"
          language: typescript
          code: |
            const result = await syncScaffoldGenHandler.register({}, storage);
    generate:
      examples:
        - label: "Generate a simple sync"
          language: bash
          code: "clef scaffold sync --name CreateProfile --from User/create --to Profile/init"
        - label: "Generate an eager sync"
          language: bash
          code: "clef scaffold sync --name ValidateOrder --tier required --eager"
      references:
        - path: references/sync-rule-guide.md
          label: "Sync rule writing guide"

  HandlerScaffoldGen:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "--concept <ConceptName>"
      trigger-description: >
        Use when implementing a concept handler in TypeScript. Generates a
        .handler.ts handler with register(), typed action methods, input extraction,
        storage patterns, and a conformance test file.
      intro-template: >
        Scaffold a TypeScript handler for concept **$ARGUMENTS** with typed
        actions, storage patterns, and a conformance test.
      companion-docs:
        - path: examples/scaffold-handler.md
          label: "Handler implementation scaffolding walkthrough"
          content: |
            # Walkthrough: Scaffolding a Handler

            This walkthrough creates a handler for the `Bookmark` concept.

            ## Step 1: Generate the Handler Scaffold

            ```bash
            clef scaffold handler --concept Bookmark \
              --actions add:url:String,remove:bookmark:String,list:owner:String
            ```

            Output:
            ```
            Created handlers/ts/framework/bookmark.handler.ts
            Created tests/bookmark.conformance.test.ts
            ```

            ## Step 2: Implement Action Logic

            Edit `bookmark.handler.ts` — replace TODO comments:

            ```typescript
            async add(input, storage) {
              const url = input.url as string;
              if (!url) return { variant: 'error', message: 'url required' };

              const existing = await storage.find('bookmarks', { url });
              if (existing.length > 0) return { variant: 'duplicate', url };

              const id = crypto.randomUUID();
              await storage.put('bookmarks', id, { id, url, created: new Date().toISOString() });
              return { variant: 'ok', bookmark: id };
            },
            ```

            ## Step 3: Run Conformance Test

            ```bash
            npx vitest run tests/bookmark.conformance.test.ts
            ```
    register:
      examples:
        - label: "Register the handler scaffold generator"
          language: typescript
          code: |
            const result = await handlerScaffoldGenHandler.register({}, storage);
    generate:
      examples:
        - label: "Generate a handler"
          language: bash
          code: "clef scaffold handler --concept User --actions create,update,delete"
        - label: "Generate with test only"
          language: bash
          code: "clef scaffold handler --concept Article"
      references:
        - path: references/handler-implementation-guide.md
          label: "Handler implementation patterns"

  StorageAdapterScaffoldGen:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "--name <AdapterName> --backend <backend>"
      trigger-description: >
        Use when adding a new storage backend to a CLEF application. Generates
        a ConceptStorage adapter implementation with put, get, find, del, and
        delMany methods for the specified backend.
      intro-template: >
        Scaffold a **$ARGUMENTS** storage adapter implementing the ConceptStorage
        interface with all five required methods.
      companion-docs:
        - path: examples/scaffold-storage-adapter.md
          label: "Storage adapter scaffolding walkthrough"
          content: |
            # Walkthrough: Scaffolding a Storage Adapter

            This walkthrough creates a PostgreSQL storage adapter.

            ## Step 1: Generate the Adapter Scaffold

            ```bash
            clef scaffold storage --name AppStorage --backend postgresql
            ```

            ## Step 2: Configure Connection

            Edit the constructor in `app-storage-storage.ts`:

            ```typescript
            constructor(connectionString: string) {
              this.pool = new Pool({ connectionString });
            }
            ```

            ## Step 3: Wire into Deploy Manifest

            ```yaml
            # deploy.yaml
            infrastructure:
              storage:
                postgresql:
                  type: postgresql
                  config:
                    host: localhost
                    port: 5432
                    database: myapp
            ```

            ## Supported Backends

            | Backend | Package | Best For |
            |---------|---------|----------|
            | sqlite | better-sqlite3 | Single-node, embedded |
            | postgresql | pg | Production, multi-node |
            | redis | redis | Caching, sessions |
            | dynamodb | @aws-sdk/client-dynamodb | Serverless |
            | memory | (none) | Tests, prototypes |
    register:
      examples:
        - label: "Register the storage adapter scaffold generator"
          language: typescript
          code: |
            const result = await storageAdapterScaffoldGenHandler.register({}, storage);
    generate:
      examples:
        - label: "Generate a PostgreSQL adapter"
          language: bash
          code: "clef scaffold storage --name AppStorage --backend postgresql"
        - label: "Generate a Redis adapter"
          language: bash
          code: "clef scaffold storage --name CacheStorage --backend redis"
        - label: "Generate an in-memory adapter"
          language: bash
          code: "clef scaffold storage --name TestStorage --backend memory"
      references:
        - path: references/storage-adapter-guide.md
          label: "Storage adapter implementation guide"

  TransportAdapterScaffoldGen:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "--name <AdapterName> --protocol <protocol>"
      trigger-description: >
        Use when adding a new transport protocol to a CLEF application.
        Generates a transport adapter with invoke, query, and health methods
        for the specified protocol.
      intro-template: >
        Scaffold a **$ARGUMENTS** transport adapter with invoke, query, and
        health methods for cross-runtime communication.
      companion-docs:
        - path: examples/scaffold-transport-adapter.md
          label: "Transport adapter scaffolding walkthrough"
          content: |
            # Walkthrough: Scaffolding a Transport Adapter

            This walkthrough creates an HTTP transport adapter.

            ## Step 1: Generate the Adapter Scaffold

            ```bash
            clef scaffold transport --name ApiTransport --protocol http
            ```

            ## Step 2: Configure Base URL

            ```typescript
            const transport = new ApiTransport('http://api-server:3000');
            ```

            ## Step 3: Wire into Deploy Manifest

            ```yaml
            # deploy.yaml
            infrastructure:
              transports:
                http:
                  type: http
                  config:
                    port: 3000
                    timeout: 5000
            ```

            ## Protocol Comparison

            | Protocol | Bidirectional | Latency | Best For |
            |----------|--------------|---------|----------|
            | http | No | Medium | REST APIs |
            | websocket | Yes | Low | Real-time |
            | worker | No | Very Low | Same-machine |
            | in-process | N/A | None | Tests |
    register:
      examples:
        - label: "Register the transport adapter scaffold generator"
          language: typescript
          code: |
            const result = await transportAdapterScaffoldGenHandler.register({}, storage);
    generate:
      examples:
        - label: "Generate an HTTP adapter"
          language: bash
          code: "clef scaffold transport --name ApiTransport --protocol http"
        - label: "Generate a WebSocket adapter"
          language: bash
          code: "clef scaffold transport --name RealtimeTransport --protocol websocket"
        - label: "Generate an in-process adapter"
          language: bash
          code: "clef scaffold transport --name TestTransport --protocol in-process"
      references:
        - path: references/transport-adapter-guide.md
          label: "Transport adapter implementation guide"

  SurfaceComponentScaffoldGen:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "--name <ComponentName>"
      trigger-description: >
        Use when creating a new Clef Surface headless component. Generates a complete
        component scaffold including widget specification (FSM), anatomy
        definition (parts contract), machine implementation, and suite manifest.
      intro-template: >
        Scaffold a Clef Surface headless component **$ARGUMENTS** with widget FSM,
        anatomy parts, machine implementation, and suite manifest.
      companion-docs:
        - path: examples/scaffold-surface-component.md
          label: "Clef Surface component scaffolding walkthrough"
          content: |
            # Walkthrough: Scaffolding a Clef Surface Component

            This walkthrough creates a `Dialog` headless component.

            ## Step 1: Generate the Component Scaffold

            ```bash
            clef scaffold component --name Dialog \
              --parts root,trigger,backdrop,content,title,closeTrigger \
              --states closed,open \
              --events open,close,escape
            ```

            Output:
            ```
            Created surface-dialog/dialog-widget.concept
            Created surface-dialog/dialog-anatomy.concept
            Created surface-dialog/suite.yaml
            Created surface-dialog/dialog-machine.handler.ts
            ```

            ## Step 2: Add Accessibility

            Edit `dialog-widget.concept`:

            ```
            accessibility {
              role: "dialog"
              aria-modal: true
              aria-labelledby: titleId
              aria-describedby: descriptionId
            }
            ```

            ## Step 3: Customize the Machine

            Add guards and transition side effects in
            `dialog-machine.handler.ts`:

            ```typescript
            // Add escape key handler
            if (event === 'escape' && machine.config?.closeOnEsc !== false) {
              // ... transition to closed
            }
            ```

            ## Step 4: Register with Widget Catalog

            The generated widget auto-registers via the surface-component
            suite's Widget/register action.

            ## Standard Component Library

            | Component | Parts | States |
            |-----------|-------|--------|
            | Button | root | idle, pressed |
            | Dialog | root, trigger, backdrop, content | closed, open |
            | Tabs | root, list, trigger, content | idle, focused |
            | Accordion | root, item, trigger, content | collapsed, expanded |
            | Menu | root, trigger, content, item | closed, open |
            | Select | root, trigger, content, item | closed, open |
            | Tooltip | root, trigger, content | hidden, visible |
    register:
      examples:
        - label: "Register the component scaffold generator"
          language: typescript
          code: |
            const result = await surfaceComponentScaffoldGenHandler.register({}, storage);
    generate:
      examples:
        - label: "Generate a dialog component"
          language: bash
          code: "clef scaffold component --name Dialog --parts root,trigger,content --states closed,open"
        - label: "Generate a tabs component"
          language: bash
          code: "clef scaffold component --name Tabs --parts root,list,trigger,content,indicator --states idle,focused,selected --events focus,select,blur"
      references:
        - path: references/surface-component-guide.md
          label: "Clef Surface headless component architecture"

  SurfaceThemeScaffoldGen:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "--name <theme-name>"
      trigger-description: >
        Use when creating a new Clef Surface design system theme. Generates palette
        configuration, typography scale, motion definitions, elevation scale,
        and light/dark theme manifests with WCAG accessibility compliance.
      intro-template: >
        Scaffold a Clef Surface design system theme **$ARGUMENTS** with palette tokens,
        typography scale, motion transitions, and elevation shadows.
      companion-docs:
        - path: examples/scaffold-surface-theme.md
          label: "Clef Surface theme scaffolding walkthrough"
          content: |
            # Walkthrough: Scaffolding a Clef Surface Theme

            This walkthrough creates an `ocean` design system theme.

            ## Step 1: Generate the Theme Scaffold

            ```bash
            clef scaffold theme --name ocean \
              --primary 220 \
              --font "Inter, sans-serif" \
              --base-size 16 \
              --scale 1.25
            ```

            Output:
            ```
            Created theme-ocean/suite.yaml
            Created theme-ocean/themes/ocean-light.json
            Created theme-ocean/themes/ocean-dark.json
            Created theme-ocean/tokens/palette.json
            Created theme-ocean/tokens/typography.json
            Created theme-ocean/tokens/motion.json
            Created theme-ocean/tokens/elevation.json
            ```

            ## Step 2: Customize Colors

            Edit `tokens/palette.json` to adjust semantic roles:

            ```json
            {
              "primary": {
                "roles": {
                  "default": "500",
                  "hover": "600",
                  "active": "700"
                }
              }
            }
            ```

            ## Step 3: Check WCAG Contrast

            The palette generator ensures AA compliance (4.5:1 for
            normal text, 3:1 for large text). Verify:

            ```
            Primary 500 on white background → 4.6:1 ✓ (AA pass)
            Primary 500 on dark background → 7.2:1 ✓ (AAA pass)
            ```

            ## Step 4: Customize Typography

            Edit `tokens/typography.json`:

            ```json
            {
              "presets": {
                "heading-1": { "size": "39.06px", "weight": 700 },
                "body": { "size": "16px", "weight": 400 }
              }
            }
            ```

            ## Token Hierarchy

            ```
            Primitive          → Semantic          → Component
            color.blue.500       color.primary        button.bg
            font.size.base       font.body            input.fontSize
            spacing.4            spacing.md           card.padding
            ```
    register:
      examples:
        - label: "Register the theme scaffold generator"
          language: typescript
          code: |
            const result = await surfaceThemeScaffoldGenHandler.register({}, storage);
    generate:
      examples:
        - label: "Generate a theme with defaults"
          language: bash
          code: "clef scaffold theme --name ocean"
        - label: "Generate a custom theme"
          language: bash
          code: "clef scaffold theme --name brand --primary '#3b82f6' --font 'Inter, sans-serif' --base-size 18"
        - label: "Generate light-only theme"
          language: bash
          code: "clef scaffold theme --name print --mode light"
      references:
        - path: references/surface-theme-guide.md
          label: "Clef Surface design system and theme architecture"

# ─── PER-CONCEPT CLI OVERRIDES ──────────────────────
# CLI-specific: positional args, custom command names.

concept-overrides:
  SpecParser:
    cli:
      actions:
        parse:
          command: check
          params:
            source:
              positional: true

  ProjectScaffold:
    cli:
      actions:
        scaffold:
          command: init
          params:
            name:
              positional: true

  SuiteManager:
    cli:
      actions:
        init:
          params:
            name:
              positional: true
        validate:
          params:
            path:
              positional: true
        test:
          params:
            path:
              positional: true
  SuiteScaffoldGen:
    cli:
      command-group: scaffold
      subcommand: kit
      description: "Generate suite manifest (suite.yaml) and directory structure."
      actions:
        preview:
          command: preview
          description: "Dry-run: compute output files without writing. Uses Emitter content-addressing to show what would change."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "Kit name (kebab-case)"
            concepts:
              type: string
              required: false
              short: c
              description: "Comma-separated PascalCase concept names"
        generate:
          command: kit
          description: "Scaffold a new CLEF kit with suite.yaml, concept stubs, and sync directories."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "Kit name (kebab-case)"
            description:
              type: string
              required: false
              short: d
              description: "Kit description"
            concepts:
              type: string
              required: false
              short: c
              description: "Comma-separated PascalCase concept names"
            syncs:
              type: string
              required: false
              description: "Comma-separated sync declarations (Name:tier)"
            dependencies:
              type: string
              required: false
              description: "Comma-separated kit dependencies"
            domain:
              type: boolean
              required: false
              description: "Include infrastructure section for domain suite"
            output:
              type: string
              required: false
              short: o
              description: "Output directory (default: ./kits/<name>)"
          examples:
            - description: "Scaffold a basic kit"
              command: "clef scaffold kit --name auth --concepts User,Session,Password"
            - description: "Scaffold a domain suite with infrastructure"
              command: "clef scaffold kit --name web3 --concepts Token,Wallet --domain"
            - description: "Scaffold with syncs"
              command: "clef scaffold kit --name auth --concepts User --syncs ValidateSession:required,RefreshExpired:recommended"

  DeployScaffoldGen:
    cli:
      command-group: scaffold
      subcommand: deploy
      description: "Generate deployment manifest (deploy.yaml)."
      actions:
        preview:
          command: preview
          description: "Dry-run: compute output files without writing. Uses Emitter content-addressing to show what would change."
          flags:
            app:
              type: string
              required: true
              description: "Application name"
        generate:
          command: deploy
          description: "Scaffold a deploy.yaml with runtimes, infrastructure, and concept assignments."
          flags:
            app:
              type: string
              required: true
              description: "Application name"
            version:
              type: string
              required: false
              short: v
              description: "Semver version (default: 0.1.0)"
            runtimes:
              type: string
              required: false
              short: r
              description: "Runtime declarations (name:type:transport:storage, comma-separated)"
            concepts:
              type: string
              required: false
              short: c
              description: "Concept assignments (Name:runtime, comma-separated)"
            iac:
              type: string
              required: false
              description: "IaC provider (terraform, cloudformation, pulumi, docker-compose)"
              default: "terraform"
            output:
              type: string
              required: false
              short: o
              description: "Output directory (default: ./deploy)"
          examples:
            - description: "Scaffold a basic deploy manifest"
              command: "clef scaffold deploy --app my-app"
            - description: "Scaffold with custom runtimes"
              command: "clef scaffold deploy --app conduit --runtimes api:node:http:postgresql,worker:node:sqs:redis --iac terraform"
            - description: "Scaffold with concept assignments"
              command: "clef scaffold deploy --app conduit --concepts User:api,Article:api,Email:worker"

  InterfaceScaffoldGen:
    cli:
      command-group: scaffold
      subcommand: interface
      description: "Generate interface manifest (interface.yaml)."
      actions:
        preview:
          command: preview
          description: "Dry-run: compute output files without writing. Uses Emitter content-addressing to show what would change."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "Interface name"
            targets:
              type: string
              required: false
              short: t
              description: "Comma-separated targets"
        generate:
          command: interface
          description: "Scaffold an interface.yaml with targets, SDKs, and concept overrides."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "Interface name"
            targets:
              type: string
              required: false
              short: t
              description: "Comma-separated targets (rest, graphql, grpc, cli, mcp, claude-skills)"
              default: "rest"
            sdks:
              type: string
              required: false
              short: s
              description: "Comma-separated SDK languages (typescript, python, go, rust, java, swift)"
              default: "typescript"
            concepts:
              type: string
              required: false
              short: c
              description: "Comma-separated concept names for per-concept overrides"
            openapi:
              type: boolean
              required: false
              description: "Generate OpenAPI spec (default: true)"
              default: "true"
            asyncapi:
              type: boolean
              required: false
              description: "Generate AsyncAPI spec (default: false)"
              default: "false"
            output:
              type: string
              required: false
              short: o
              description: "Output directory"
          examples:
            - description: "Scaffold a REST + GraphQL interface"
              command: "clef scaffold interface --name my-api --targets rest,graphql --sdks typescript,python"
            - description: "Scaffold a full-stack interface"
              command: "clef scaffold interface --name my-api --targets rest,graphql,grpc,cli,mcp,claude-skills"

  ConceptScaffoldGen:
    cli:
      command-group: scaffold
      subcommand: concept
      description: "Generate concept specification (.concept) file."
      actions:
        preview:
          command: preview
          description: "Dry-run: compute output files without writing. Uses Emitter content-addressing to show what would change."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "PascalCase concept name"
        generate:
          command: concept
          description: "Scaffold a .concept file with state, actions, and register()."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "PascalCase concept name"
            param:
              type: string
              required: false
              short: p
              description: "Type parameter letter (default: T)"
              default: "T"
            purpose:
              type: string
              required: false
              description: "Purpose description"
            category:
              type: string
              required: false
              description: "Annotation category (domain, devtools, etc.)"
            actions:
              type: string
              required: false
              short: a
              description: "Comma-separated action names"
            output:
              type: string
              required: false
              short: o
              description: "Output directory (default: ./specs/app)"
          examples:
            - description: "Scaffold a basic concept"
              command: "clef scaffold concept --name User --actions create,update,delete"
            - description: "Scaffold with custom type parameter"
              command: "clef scaffold concept --name Article --param A --category domain"
            - description: "Scaffold with purpose"
              command: "clef scaffold concept --name Bookmark --purpose 'Save and organize references.'"

  SyncScaffoldGen:
    cli:
      command-group: scaffold
      subcommand: sync
      description: "Generate synchronization rule (.sync) file."
      actions:
        preview:
          command: preview
          description: "Dry-run: compute output files without writing. Uses Emitter content-addressing to show what would change."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "PascalCase sync name"
        generate:
          command: sync
          description: "Scaffold a .sync file with when/where/then clauses."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "PascalCase sync name"
            from:
              type: string
              required: false
              description: "Trigger source (Concept/action)"
            to:
              type: string
              required: false
              description: "Effect target (Concept/action)"
            tier:
              type: string
              required: false
              short: t
              description: "Sync tier (required, recommended)"
              default: "recommended"
            eager:
              type: boolean
              required: false
              description: "Fire immediately (default: true)"
              default: "true"
            output:
              type: string
              required: false
              short: o
              description: "Output directory (default: ./syncs)"
          examples:
            - description: "Scaffold a sync between two concepts"
              command: "clef scaffold sync --name CreateProfile --from User/create --to Profile/init"
            - description: "Scaffold a required sync"
              command: "clef scaffold sync --name ValidateOrder --tier required"

  HandlerScaffoldGen:
    cli:
      command-group: scaffold
      subcommand: handler
      description: "Generate TypeScript concept handler (.handler.ts) and conformance test."
      actions:
        preview:
          command: preview
          description: "Dry-run: compute output files without writing. Uses Emitter content-addressing to show what would change."
          flags:
            concept:
              type: string
              required: true
              short: c
              description: "PascalCase concept name"
        generate:
          command: handler
          description: "Scaffold a .handler.ts handler with register(), typed actions, and a conformance test."
          flags:
            concept:
              type: string
              required: true
              short: c
              description: "PascalCase concept name"
            actions:
              type: string
              required: false
              short: a
              description: "Comma-separated action signatures (name:param1:Type1,name:param2:Type2)"
            input-kind:
              type: string
              required: false
              description: "KindSystem input kind"
            output-kind:
              type: string
              required: false
              description: "KindSystem output kind"
            output:
              type: string
              required: false
              short: o
              description: "Output directory (default: ./handlers/ts)"
          examples:
            - description: "Scaffold a handler"
              command: "clef scaffold handler --concept User --actions create:name:String,update:name:String,delete:id:String"
            - description: "Scaffold with kind metadata"
              command: "clef scaffold handler --concept Bookmark --input-kind BookmarkInput --output-kind BookmarkResult"

  StorageAdapterScaffoldGen:
    cli:
      command-group: scaffold
      subcommand: storage
      description: "Generate ConceptStorage adapter for a persistence backend."
      actions:
        preview:
          command: preview
          description: "Dry-run: compute output files without writing. Uses Emitter content-addressing to show what would change."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "Adapter class name (PascalCase)"
            backend:
              type: string
              required: true
              short: b
              description: "Backend type"
              choices: [sqlite, postgresql, redis, dynamodb, memory]
        generate:
          command: storage
          description: "Scaffold a ConceptStorage adapter with put, get, find, del, and delMany methods."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "Adapter class name (PascalCase)"
            backend:
              type: string
              required: true
              short: b
              description: "Backend type"
              choices: [sqlite, postgresql, redis, dynamodb, memory]
            output:
              type: string
              required: false
              short: o
              description: "Output directory"
          examples:
            - description: "Generate a PostgreSQL adapter"
              command: "clef scaffold storage --name AppStorage --backend postgresql"
            - description: "Generate a Redis adapter"
              command: "clef scaffold storage --name CacheStorage --backend redis"
            - description: "Generate an in-memory adapter for tests"
              command: "clef scaffold storage --name TestStorage --backend memory"

  TransportAdapterScaffoldGen:
    cli:
      command-group: scaffold
      subcommand: transport
      description: "Generate transport adapter for a communication protocol."
      actions:
        preview:
          command: preview
          description: "Dry-run: compute output files without writing. Uses Emitter content-addressing to show what would change."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "Adapter class name (PascalCase)"
            protocol:
              type: string
              required: true
              short: p
              description: "Protocol type"
              choices: [http, websocket, worker, in-process]
        generate:
          command: transport
          description: "Scaffold a transport adapter with invoke, query, and health methods."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "Adapter class name (PascalCase)"
            protocol:
              type: string
              required: true
              short: p
              description: "Protocol type"
              choices: [http, websocket, worker, in-process]
            base-url:
              type: string
              required: false
              description: "Base URL (for http/websocket)"
              default: "http://localhost:3000"
            output:
              type: string
              required: false
              short: o
              description: "Output directory"
          examples:
            - description: "Generate an HTTP adapter"
              command: "clef scaffold transport --name ApiTransport --protocol http"
            - description: "Generate a WebSocket adapter"
              command: "clef scaffold transport --name RealtimeTransport --protocol websocket --base-url ws://localhost:3000"
            - description: "Generate an in-process adapter for tests"
              command: "clef scaffold transport --name TestTransport --protocol in-process"

  SurfaceComponentScaffoldGen:
    cli:
      command-group: scaffold
      subcommand: component
      description: "Generate Clef Surface headless component (widget, anatomy, machine, kit)."
      actions:
        preview:
          command: preview
          description: "Dry-run: compute output files without writing. Uses Emitter content-addressing to show what would change."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "PascalCase component name"
            parts:
              type: string
              required: false
              short: p
              description: "Comma-separated anatomy part names"
        generate:
          command: component
          description: "Scaffold a complete Clef Surface headless component with FSM, anatomy, and machine."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "PascalCase component name"
            parts:
              type: string
              required: false
              short: p
              description: "Comma-separated anatomy part names"
              default: "root,trigger,content"
            slots:
              type: string
              required: false
              description: "Comma-separated slot names"
            states:
              type: string
              required: false
              short: s
              description: "Comma-separated FSM state names"
              default: "idle,active"
            events:
              type: string
              required: false
              short: e
              description: "Comma-separated FSM event names"
              default: "open,close"
            role:
              type: string
              required: false
              description: "ARIA role for accessibility"
              default: "widget"
            output:
              type: string
              required: false
              short: o
              description: "Output directory"
          examples:
            - description: "Generate a dialog component"
              command: "clef scaffold component --name Dialog --parts root,trigger,backdrop,content,title,closeTrigger --states closed,open --events open,close,escape"
            - description: "Generate a tabs component"
              command: "clef scaffold component --name Tabs --parts root,list,trigger,content,indicator --states idle,focused,selected --events focus,select,blur"
            - description: "Generate with slots"
              command: "clef scaffold component --name Card --parts root,header,body,footer --slots header,footer"

  SurfaceThemeScaffoldGen:
    cli:
      command-group: scaffold
      subcommand: theme
      description: "Generate Clef Surface design system theme (palette, typography, motion, elevation)."
      actions:
        preview:
          command: preview
          description: "Dry-run: compute output files without writing. Uses Emitter content-addressing to show what would change."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "Theme name (kebab-case)"
        generate:
          command: theme
          description: "Scaffold a complete design system theme with WCAG-compliant tokens."
          flags:
            name:
              type: string
              required: true
              short: n
              description: "Theme name (kebab-case)"
            primary:
              type: string
              required: false
              short: p
              description: "Primary color hue (0-360) or hex value"
            secondary:
              type: string
              required: false
              description: "Secondary color hue or hex value"
            font:
              type: string
              required: false
              short: f
              description: "Primary font family stack"
              default: "system-ui, -apple-system, sans-serif"
            base-size:
              type: string
              required: false
              description: "Base font size in pixels"
              default: "16"
            scale:
              type: string
              required: false
              description: "Modular ratio for type scale"
              default: "1.25"
            border-radius:
              type: string
              required: false
              description: "Default border radius"
              default: "0.375rem"
            mode:
              type: string
              required: false
              short: m
              description: "Theme mode"
              choices: [light, dark, both]
              default: "both"
            output:
              type: string
              required: false
              short: o
              description: "Output directory"
          examples:
            - description: "Generate a theme with defaults"
              command: "clef scaffold theme --name ocean"
            - description: "Generate a custom theme"
              command: "clef scaffold theme --name brand --primary 220 --font 'Inter, sans-serif' --base-size 18"
            - description: "Generate a light-only theme"
              command: "clef scaffold theme --name print --mode light"
            - description: "Generate a dark theme"
              command: "clef scaffold theme --name midnight --mode dark --primary '#6366f1'"
