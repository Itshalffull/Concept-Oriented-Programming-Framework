# COPF DevTools — Interface Generation Manifest
#
# Generates Claude Skills and CLI commands from
# framework concept specs. Uses workflow and annotation
# metadata to produce rich, step-based skills that
# match the hand-written originals.
#
# Usage:
#   copf interface generate --manifest examples/devtools/devtools.interface.yaml

interface:
  name: copf-devtools
  version: 0.2.0

# ─── GENERATION TARGETS ──────────────────────────────
targets:
  claude-skills:
    name: copf-devtools
    grouping: per-concept

  cli:
    name: copf

# ─── CONCEPT SPECS ───────────────────────────────────
# Framework concepts that map to CLI commands and skills.
# Each concept has corresponding actions in its .concept spec.
concepts:
  - specs/framework/spec-parser.concept
  - specs/framework/schema-gen.concept
  - specs/framework/sync-parser.concept
  - specs/framework/sync-compiler.concept
  - specs/framework/flow-trace.concept
  - specs/framework/deployment-validator.concept
  - specs/framework/migration.concept
  - specs/framework/project-scaffold.concept
  - specs/framework/dev-server.concept
  - specs/framework/cache-compiler.concept
  - specs/framework/kit-manager.concept
  # Generation kit concepts
  - kits/generation/emitter.concept
  - kits/generation/build-cache.concept
  - kits/generation/resource.concept
  - kits/generation/kind-system.concept
  - kits/generation/generation-plan.concept

# ─── OUTPUT CONFIGURATION ────────────────────────────
output:
  dir: ./generated/devtools
  formatting:
    typescript: prettier
  clean: true

# ─── WORKFLOWS ───────────────────────────────────────
# Define ordered, annotated workflows for skill targets.
# Each workflow maps a concept to a step-by-step guide.

workflows:

  # ─── SpecParser: concept-validator ─────────────────
  concept-validator:
    concept: SpecParser
    steps:
      - action: parse
        title: "Parse and Validate"
        prose: "Parse all .concept specs in the project and report syntax or structural errors."
    checklists:
      parse:
        - "Has purpose block?"
        - "Actions have at least one variant?"
        - "Invariants reference valid actions?"
        - "Type parameters declared and used?"
    design-principles:
      - title: "Spec as Source of Truth"
        rule: "The .concept file is the single authoritative definition — all generated code, tests, and documentation derive from it."
      - title: "Fail Fast on Ambiguity"
        rule: "Parser rejects specs with ambiguous state relations or incomplete action signatures rather than guessing intent."
    references:
      - path: references/concept-grammar.md
        label: "Concept grammar reference"
        tier: reference
        content: |
          # Concept Grammar Reference

          Complete grammar for `.concept` specification files.

          ## Top-Level Structure

          ```
          concept Name [TypeParam, ...] {
            purpose { ... }
            state { ... }
            actions { ... }
            invariants { ... }
          }
          ```

          ## Purpose Block

          ```
          purpose { Free-text description in imperative present tense. }
          ```

          One to three sentences. No implementation details.

          ## State Block

          ```
          state {
            items: set T            # Primary collection
            name: T -> String       # Total function (every T has one)
            email: T -> option String  # Partial (may be absent)
            tags: T -> list String  # Multi-valued
          }
          ```

          **Relation types:**
          | Syntax | Meaning | TypeScript |
          |--------|---------|-----------|
          | `set T` | Collection of T | `Map<id, T>` |
          | `T -> V` | Total function | Required field |
          | `T -> option V` | Partial function | Optional field |
          | `T -> list V` | Multi-valued | Array field |

          ## Actions Block

          ```
          actions {
            action create(name: String, email: String) {
              -> ok(item: T) { Created successfully. }
              -> duplicate(name: String) { Name already taken. }
            }
          }
          ```

          - Each action has a name, typed parameters, and one or more **variants**.
          - Variants use `->` arrow syntax: `-> variantName(bindings) { prose }`.
          - At least one variant is required per action.

          **Parameter types:** `String`, `Int`, `Bool`, `T` (type param), `list T`, `option T`.

          ## Invariants Block

          ```
          invariants {
            after create(name) -> ok(item) {
              then { item in items; name(item) = name }
            }
            after delete(item) -> ok {
              then { item not in items }
            }
          }
          ```

          - `after action -> variant { then { assertions } }` — post-condition.
          - Assertions: `field(item) = value`, `item in collection`, `item not in collection`.

          ## Type Parameters

          Declared in brackets after concept name: `concept Name [T, U]`.
          Used throughout state and action signatures. Resolved by syncs at composition time.
      - path: references/jackson-methodology.md
        label: "Jackson's concept design methodology"
        tier: reference
        content: |
          # Jackson's Concept Design Methodology

          Summary of Daniel Jackson's software concept design methodology
          as applied in COPF.

          ## Five Core Principles

          ### 1. Singularity
          Each concept serves exactly one purpose. If the purpose statement
          contains "and", it should be split into separate concepts.

          ### 2. Independence
          A concept never references another concept directly — no imports,
          no shared types, no cross-concept calls. Concepts communicate only
          through type parameters and syncs.

          ### 3. Sufficiency
          The concept's state and actions are sufficient to fulfill its purpose.
          Every use case implied by the purpose can be served by the declared actions.

          ### 4. Necessity
          Every piece of state is needed by at least one action. Every action
          serves the concept's purpose. No dead state or unused actions.

          ### 5. Invariant Completeness
          Key properties of the concept are captured as formal invariants.
          Invariants document what must always be true after each action completes.

          ## Design Workflow

          1. **Articulate purpose** — Write 1-3 sentences describing what the
             concept is for, not how it works.
          2. **Design state** — Start with the primary collection (`items: set T`),
             then add relations that serve the actions.
          3. **Design actions** — Define verbs with typed parameters and return
             variants. Each variant represents a distinct outcome.
          4. **Write invariants** — For each action+variant, state what must be
             true afterward. This catches design gaps early.
          5. **Validate** — Run `copf check` to verify syntax, completeness, and
             consistency.

          ## Common Concept Patterns

          | Pattern | State Shape | Example |
          |---------|-------------|---------|
          | Entity CRUD | `items: set T; fields: T -> Type` | User, Article |
          | Relationship | `links: set L; from: L -> A; to: L -> B` | Friendship, Membership |
          | Workflow | `items: set T; status: T -> Status` | Order, Approval |
          | Guard | `(no primary state)` | Password, RateLimit |
    validation-commands:
      - label: "Parse and validate all concept specs"
        command: "npx tsx tools/copf-cli/src/index.ts check"
      - label: "Run parser tests"
        command: "npx vitest run tests/spec-parser.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | parse | `copf check <file>` | Validate concept spec syntax and structure |
    related-workflows:
      - name: concept-designer
        description: "Design new concepts following Jackson's methodology"
      - name: implementation-builder
        description: "Write handlers that implement concept actions"
      - name: sync-designer
        description: "Write syncs that connect concepts together"
    anti-patterns:
      - title: "Missing purpose block"
        description: "Concept spec has no purpose — impossible to evaluate design quality."
        bad: |
          concept User [U] {
            state { users: set U; name: U -> String }
            actions { action create(name: String) { -> ok(user: U) { Created. } } }
          }
        good: |
          concept User [U] {
            purpose { Manage user identity and profile information. }
            state { users: set U; name: U -> String }
            actions { action create(name: String) { -> ok(user: U) { Created. } } }
          }
      - title: "Untyped action parameters"
        description: "Action parameters lack types — generated code will use 'any'."
        bad: |
          action create(name, email) { -> ok(user: U) { Created. } }
        good: |
          action create(name: String, email: String) { -> ok(user: U) { Created. } }

  # ─── SpecParser: concept-designer ──────────────────
  concept-designer:
    concept: SpecParser
    steps:
      - action: parse
        title: "Articulate the Purpose"
        prose: "The purpose answers: What is this concept for? Write 1-3 sentences in imperative present tense."
    checklists:
      parse:
        - "Single purpose — no 'and also'?"
        - "Describes why, not what?"
        - "A user would understand it without seeing the implementation?"
    design-principles:
      - title: "Singularity"
        rule: "Each concept serves exactly one purpose — if the purpose has 'and', it's two concepts."
      - title: "Independence"
        rule: "A concept never references another concept's types or calls another concept's actions directly — use type parameters and syncs."
      - title: "Sufficiency & Necessity"
        rule: "Every state field is needed by at least one action, and every action can be served from the declared state."
    references:
      - path: references/jackson-methodology.md
        label: "Jackson's full methodology"
        tier: reference
        content: |
          # Jackson's Concept Design Methodology

          Summary of Daniel Jackson's software concept design methodology
          as applied in COPF.

          ## Five Core Principles

          ### 1. Singularity
          Each concept serves exactly one purpose. If the purpose statement
          contains "and", it should be split into separate concepts.

          ### 2. Independence
          A concept never references another concept directly — no imports,
          no shared types, no cross-concept calls. Concepts communicate only
          through type parameters and syncs.

          ### 3. Sufficiency
          The concept's state and actions are sufficient to fulfill its purpose.
          Every use case implied by the purpose can be served by the declared actions.

          ### 4. Necessity
          Every piece of state is needed by at least one action. Every action
          serves the concept's purpose. No dead state or unused actions.

          ### 5. Invariant Completeness
          Key properties of the concept are captured as formal invariants.
          Invariants document what must always be true after each action completes.

          ## Design Workflow

          1. **Articulate purpose** — Write 1-3 sentences describing what the
             concept is for, not how it works.
          2. **Design state** — Start with the primary collection (`items: set T`),
             then add relations that serve the actions.
          3. **Design actions** — Define verbs with typed parameters and return
             variants. Each variant represents a distinct outcome.
          4. **Write invariants** — For each action+variant, state what must be
             true afterward. This catches design gaps early.
          5. **Validate** — Run `copf check` to verify syntax, completeness, and
             consistency.

          ## Common Concept Patterns

          | Pattern | State Shape | Example |
          |---------|-------------|---------|
          | Entity CRUD | `items: set T; fields: T -> Type` | User, Article |
          | Relationship | `links: set L; from: L -> A; to: L -> B` | Friendship, Membership |
          | Workflow | `items: set T; status: T -> Status` | Order, Approval |
          | Guard | `(no primary state)` | Password, RateLimit |
      - path: references/concept-catalog.md
        label: "Reusable concept catalog"
        tier: reference
        content: |
          # Reusable Concept Catalog

          Common concepts that appear across applications. Use as starting
          points — adapt state and actions to your specific purpose.

          ## Identity & Access

          | Concept | Purpose | Key Actions |
          |---------|---------|-------------|
          | User | Manage user identity | create, update, delete, find |
          | Password | Verify credentials | set, check, reset |
          | Session | Track authenticated sessions | start, end, validate |
          | Role | Assign permissions to users | grant, revoke, check |

          ## Content

          | Concept | Purpose | Key Actions |
          |---------|---------|-------------|
          | Article | Manage authored content | create, publish, archive |
          | Tag | Categorize items with labels | add, remove, find |
          | Comment | Attach discussion to items | post, edit, delete |

          ## Commerce

          | Concept | Purpose | Key Actions |
          |---------|---------|-------------|
          | Cart | Collect items for purchase | add, remove, clear |
          | Order | Track purchase lifecycle | place, fulfill, cancel |
          | Payment | Process financial transactions | charge, refund |
          | Invoice | Record financial obligations | issue, pay, void |

          ## Communication

          | Concept | Purpose | Key Actions |
          |---------|---------|-------------|
          | Email | Send transactional messages | send, schedule, cancel |
          | Notification | Alert users of events | create, read, dismiss |

          ## Composition Notes

          These concepts are designed to be independent. Wire them together
          using syncs:

          ```
          sync WelcomeEmail [eager] {
            when { User/create => ok[user: ?u] }
            where { User: { ?u email: ?email } }
            then { Email/send[to: ?email, template: "welcome"] }
          }
          ```
    anti-patterns:
      - title: "Kitchen-sink concept"
        description: "Concept has multiple unrelated purposes — split into separate concepts."
        bad: |
          concept UserAuth [U] {
            purpose { Manage users AND authenticate them. }
          }
        good: |
          concept User [U] { purpose { Manage user identity. } }
          concept Password [U] { purpose { Verify credentials for a user. } }
      - title: "Leaky independence"
        description: "Concept references another concept's types or calls another concept's actions — use type parameters instead."
        bad: |
          concept Order [O] {
            state { customer: O -> User }
          }
        good: |
          concept Order [O, U] {
            state { customer: O -> U }
          }
    validation-commands:
      - label: "Validate the new concept spec"
        command: "npx tsx tools/copf-cli/src/index.ts check"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Section | What to Write | Key Question |
        |---------|---------------|--------------|
        | purpose | 1-3 sentences | What is this concept for? |
        | state | Relations on type params | What does the concept remember? |
        | actions | Verbs with variants | What can users do? |
        | invariants | after/then assertions | What must always be true? |
    related-workflows:
      - name: concept-validator
        description: "Parse and validate concept specs for syntax errors"
      - name: sync-designer
        description: "Write syncs that connect concepts together"
      - name: implementation-builder
        description: "Write TypeScript handlers for concept actions"
    content-sections:
      - heading: "State Design Principles"
        body: |
          State is what the concept remembers. Start from the purpose — every
          piece of state must serve at least one action. Use the primary
          collection pattern (`items: set T`) and derive everything else as
          relations on T. Avoid storing derived data that can be computed.
        afterStep: 1

  # ─── SyncCompiler: sync-designer ───────────────────
  sync-designer:
    concept: SyncCompiler
    steps:
      - action: compile
        title: "Compile Sync Rules"
        prose: "Compile .sync files that wire concepts together through pattern matching on completions."
    checklists:
      compile:
        - "Sync references valid concept actions?"
        - "Variable bindings are consistent across when/where/then?"
        - "Where-clause queries are well-formed?"
        - "Sync mode (eager vs eventual) matches intent?"
    design-principles:
      - title: "Completion Chaining"
        rule: "Syncs compose through completions, never by referencing other syncs — each sync reacts to what happened, not who caused it."
      - title: "Concept Independence"
        rule: "Syncs wire concepts together without the concepts knowing about each other — concepts never import or reference each other."
      - title: "Pattern Exhaustiveness"
        rule: "Every when-clause variant that a sync matches should be explicitly listed — don't rely on fallthrough behavior."
    references:
      - path: references/sync-design.md
        label: "Sync language and patterns"
        tier: reference
        content: |
          # Sync Language Reference

          Syncs wire concepts together by reacting to completions. A sync
          never calls another sync — it only sees concept action completions.

          ## Sync Declaration

          ```
          sync Name [mode] {
            when { ... }
            where { ... }    # optional
            filter(...)      # optional
            then { ... }
          }
          ```

          **Modes:**
          - `eager` — Executes synchronously within the same transaction.
            Use for data consistency (e.g., creating related records).
          - `eventual` — Queued for async execution. Use for side effects
            (e.g., sending emails, updating caches).

          ## When Clause

          Pattern matches on a concept action completion:

          ```
          when { Concept/action => variant[binding: ?var, ...] }
          ```

          - `Concept/action` — The concept and action to watch.
          - `=> variant` — Which return variant to match.
          - `[binding: ?var]` — Extract values from the completion into variables.

          ## Where Clause

          Queries concept state to bind additional variables:

          ```
          where { Concept: { ?item field: ?value } }
          ```

          - `?item` — Binds to items in the concept's primary collection.
          - `field: ?value` — Binds the field value to a variable.

          ## Filter Clause

          Guards execution with a boolean condition:

          ```
          filter(?count > 0)
          filter(?status = "active")
          ```

          ## Then Clause

          Invokes a target concept action with bound variables:

          ```
          then { Concept/action[param: ?var, ...] }
          ```

          All variables in then must be bound in when or where.

          ## Variable Binding Rules

          1. Variables start with `?` — e.g., `?user`, `?email`.
          2. A variable must be bound (in when or where) before use in then.
          3. Variables are scoped to a single sync — no cross-sync sharing.
      - path: references/sync-patterns.md
        label: "Reusable sync templates"
        tier: reference
        content: |
          # Reusable Sync Patterns

          Common sync patterns for wiring concepts together.

          ## CRUD Chain

          When one entity is created, create related records:

          ```
          sync CreateProfile [eager] {
            when { User/create => ok[user: ?u] }
            then { Profile/create[owner: ?u] }
          }
          ```

          ## Auth-Gated Action

          Validate authentication before allowing an action:

          ```
          sync AuthGate [eager] {
            when { Session/validate => ok[token: ?t] }
            where { Session: { ?t userId: ?uid } }
            then { Article/create[author: ?uid] }
          }
          ```

          ## Notification on Event

          Send async notification when something happens:

          ```
          sync NotifyOnOrder [eventual] {
            when { Order/place => ok[order: ?o] }
            where { Order: { ?o customer: ?c } }
            where { User: { ?c email: ?email } }
            then { Email/send[to: ?email, template: "order-placed"] }
          }
          ```

          ## Cache Invalidation

          Invalidate cache when source data changes:

          ```
          sync InvalidateUserCache [eager] {
            when { User/update => ok[user: ?u] }
            then { Cache/invalidate[key: ?u, namespace: "user"] }
          }
          ```

          ## Cascade Delete

          Clean up related data when a parent is deleted:

          ```
          sync CascadeDelete [eager] {
            when { User/delete => ok[user: ?u] }
            then { Profile/deleteByOwner[owner: ?u] }
          }
          ```

          ## Guarded Sync

          Only fire when a condition is met:

          ```
          sync HighValueOrder [eventual] {
            when { Order/place => ok[order: ?o] }
            where { Order: { ?o total: ?amount } }
            filter(?amount > 1000)
            then { Alert/create[type: "high-value", ref: ?o] }
          }
          ```
    anti-patterns:
      - title: "Sync referencing sync"
        description: "One sync tries to trigger another sync directly instead of reacting to a completion."
        bad: |
          sync BadChain [eager] {
            when { MySyncA/complete => ok }
            then { ConceptB/doThing }
          }
        good: |
          sync GoodChain [eager] {
            when { ConceptA/create => ok[item: ?x] }
            then { ConceptB/process[item: ?x] }
          }
      - title: "Overly broad pattern match"
        description: "Sync matches all variants of an action instead of the specific one it needs."
        bad: |
          sync TooWide [eager] {
            when { User/register => [user: ?u] }
            then { Email/send[to: ?u] }
          }
        good: |
          sync Precise [eager] {
            when { User/register => ok[user: ?u] }
            then { Email/send[to: ?u] }
          }
    validation-commands:
      - label: "Compile all sync rules"
        command: "npx tsx tools/copf-cli/src/index.ts compile-syncs"
      - label: "Run sync compiler tests"
        command: "npx vitest run tests/sync-compiler.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Clause | Purpose | Example |
        |--------|---------|---------|
        | when | Pattern match on completion | `ConceptA/action => ok[field: ?var]` |
        | where | Query concept state | `ConceptB: { ?item state.field: ?val }` |
        | then | Invoke target action | `ConceptC/action[param: ?var]` |
        | filter | Guard condition | `filter(?val > 0)` |
    related-workflows:
      - name: concept-designer
        description: "Design concepts that syncs connect"
      - name: implementation-builder
        description: "Write handlers for concept actions"
      - name: concept-validator
        description: "Validate concept specs before writing syncs"
    content-sections:
      - heading: "Completion Chaining Pattern"
        body: |
          Syncs compose through completions, not references. A typical
          authenticated CRUD flow chains like this:

          1. `User/login => ok[session: ?s]`
          2. → `Auth/validate[session: ?s] => ok[token: ?t]`
          3. → `Article/create[author: ?t] => ok[article: ?a]`

          Each sync sees only the completion it reacts to — no sync
          knows about the others in the chain.
        afterStep: 1

  # ─── SchemaGen: implementation-builder ─────────────
  implementation-builder:
    concept: SchemaGen
    steps:
      - action: generate
        title: "Generate Schema from Spec"
        prose: "Generate ConceptManifest from parsed AST. The manifest provides typed action signatures for implementation."
    checklists:
      generate:
        - "All action parameters have types?"
        - "Return variants match spec declarations?"
        - "State relations are correctly grouped?"
        - "Type parameters are resolved?"
    design-principles:
      - title: "One Handler per Action"
        rule: "Each action in the concept spec maps to exactly one async method in the implementation handler."
      - title: "Variant Completeness"
        rule: "Every return variant declared in the spec must have a corresponding code path in the handler — no missing branches."
      - title: "Storage Sovereignty"
        rule: "Each concept owns its storage exclusively — no shared databases, no cross-concept state access."
    references:
      - path: references/implementation-patterns.md
        label: "Implementation patterns and storage"
        tier: reference
        content: |
          # Implementation Patterns

          Patterns for writing concept handler implementations.

          ## Handler Structure

          Each concept gets one handler file. Each action maps to one async method:

          ```typescript
          export const userHandler: ConceptHandler<UserState> = {
            async create(input, storage) {
              const id = generateId();
              await storage.set(id, { name: input.name, email: input.email });
              return { variant: 'ok', user: id };
            },

            async delete(input, storage) {
              const exists = await storage.has(input.user);
              if (!exists) return { variant: 'notFound', user: input.user };
              await storage.delete(input.user);
              return { variant: 'ok' };
            },
          };
          ```

          ## Storage Patterns

          **Key-value storage** — Every concept gets isolated key-value storage:
          - `storage.get(key)` — Read a record
          - `storage.set(key, value)` — Write a record
          - `storage.has(key)` — Check existence
          - `storage.delete(key)` — Remove a record
          - `storage.list()` — List all keys

          **Storage sovereignty** — A concept only accesses its own storage.
          Never import or reference another concept's storage.

          ## Return Variants

          Every code path must return one of the declared variants:

          ```typescript
          // Spec declares: -> ok(item: T), -> duplicate(name: String)
          async create(input, storage) {
            const existing = await findByName(input.name, storage);
            if (existing) {
              return { variant: 'duplicate', name: input.name };
            }
            // ... create logic
            return { variant: 'ok', item: id };
          }
          ```

          **Rules:**
          - Every variant from the spec must have a code path.
          - Return object must include `variant` field plus declared bindings.
          - No undeclared variants — the runtime rejects unknown variants.

          ## Error Handling

          - Use variants for expected outcomes (not found, duplicate, invalid).
          - Throw exceptions only for unexpected failures (storage errors, bugs).
          - The runtime wraps thrown exceptions as `error` completions automatically.
      - path: references/type-mapping.md
        label: "Spec-to-TypeScript type mapping rules"
        tier: reference
        content: |
          # Spec-to-TypeScript Type Mapping

          Rules for mapping concept spec types to TypeScript types in
          generated manifests and handler interfaces.

          ## Primitive Types

          | Spec Type | TypeScript Type | Notes |
          |-----------|----------------|-------|
          | `String` | `string` | |
          | `Int` | `number` | Integer values |
          | `Bool` | `boolean` | |
          | `Float` | `number` | Floating point |

          ## Collection Types

          | Spec Type | TypeScript Type | Notes |
          |-----------|----------------|-------|
          | `set T` | `Map<string, T>` | Primary collection keyed by ID |
          | `list T` | `T[]` | Ordered array |
          | `option T` | `T \| undefined` | Nullable/optional |

          ## Relation Types

          | Spec Syntax | TypeScript Type | Meaning |
          |-------------|----------------|---------|
          | `T -> String` | `string` (required field) | Total function |
          | `T -> option String` | `string \| undefined` | Partial function |
          | `T -> list String` | `string[]` | Multi-valued |
          | `T -> set U` | `Set<U>` | Set-valued |

          ## Type Parameters

          Type parameters (`[T, U]`) become generic type arguments.
          In generated code, they resolve to `string` (ID references)
          unless a concrete type is provided by the sync wiring.

          ## Action Signatures

          ```
          // Spec:
          action create(name: String, count: Int) {
            -> ok(item: T) { ... }
          }

          // Generated TypeScript:
          create(input: { name: string; count: number }, storage: Storage)
            : Promise<{ variant: 'ok'; item: string } | ...>
          ```
    validation-commands:
      - label: "Generate manifests from specs"
        command: "npx tsx tools/copf-cli/src/index.ts generate"
      - label: "Run schema generation tests"
        command: "npx vitest run tests/schema-gen.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Spec Type | TypeScript Type | Notes |
        |-----------|----------------|-------|
        | String | string | Direct mapping |
        | Int | number | Direct mapping |
        | Bool | boolean | Direct mapping |
        | list T | T[] | Array mapping |
        | option T | T \| undefined | Optional mapping |
        | set T | Set<T> or Map | Primary collection |
    related-workflows:
      - name: concept-designer
        description: "Design concepts before implementing them"
      - name: concept-validator
        description: "Validate specs before generating schemas"
      - name: sync-designer
        description: "Wire implemented concepts together with syncs"
    anti-patterns:
      - title: "Cross-concept storage access"
        description: "Handler reads or writes another concept's storage — violates sovereignty."
        bad: |
          async create(input, storage) {
            const user = await userStorage.get(input.userId); // Wrong!
            // ...
          }
        good: |
          async create(input, storage) {
            // userId is passed in — concept doesn't know where it came from
            const item = { id: generateId(), owner: input.userId };
            await storage.set(item.id, item);
            return { variant: 'ok', item: item.id };
          }

  # ─── SyncParser: sync-validator ────────────────────
  sync-validator:
    concept: SyncParser
    steps:
      - action: parse
        title: "Parse and Validate Sync Files"
        prose: "Parse .sync files into structured ASTs and validate variable bindings, concept references, and action signatures against loaded manifests."
    checklists:
      parse:
        - "Sync file has valid when/then structure?"
        - "All concept references resolve to loaded manifests?"
        - "Variable bindings are consistent across clauses?"
        - "Action parameters match concept action signatures?"
        - "Sync mode (eager/eventual) is declared?"
    design-principles:
      - title: "Manifest-Aware Validation"
        rule: "Sync validation cross-references concept manifests to verify that referenced actions and parameters actually exist."
      - title: "Early Error Detection"
        rule: "Catch variable binding mismatches and type errors at parse time, not at runtime when the sync fires."
    references:
      - path: references/sync-design.md
        label: "Sync language reference"
        tier: reference
        content: |
          # Sync Language Reference

          Syncs wire concepts together by reacting to completions. A sync
          never calls another sync — it only sees concept action completions.

          ## Sync Declaration

          ```
          sync Name [mode] {
            when { ... }
            where { ... }    # optional
            filter(...)      # optional
            then { ... }
          }
          ```

          **Modes:**
          - `eager` — Synchronous, same transaction. Use for data consistency.
          - `eventual` — Queued async. Use for side effects.

          ## When Clause

          ```
          when { Concept/action => variant[binding: ?var, ...] }
          ```

          ## Where Clause

          ```
          where { Concept: { ?item field: ?value } }
          ```

          ## Filter Clause

          ```
          filter(?count > 0)
          ```

          ## Then Clause

          ```
          then { Concept/action[param: ?var, ...] }
          ```

          ## Variable Binding Rules

          1. Variables start with `?`.
          2. Must be bound in when or where before use in then.
          3. Scoped to a single sync.
      - path: references/sync-patterns.md
        label: "Common sync patterns and templates"
        tier: reference
        content: |
          # Common Sync Patterns

          ## CRUD Chain
          ```
          sync CreateProfile [eager] {
            when { User/create => ok[user: ?u] }
            then { Profile/create[owner: ?u] }
          }
          ```

          ## Notification
          ```
          sync NotifyOnOrder [eventual] {
            when { Order/place => ok[order: ?o] }
            where { Order: { ?o customer: ?c } }
            where { User: { ?c email: ?email } }
            then { Email/send[to: ?email, template: "order-placed"] }
          }
          ```

          ## Cache Invalidation
          ```
          sync InvalidateCache [eager] {
            when { User/update => ok[user: ?u] }
            then { Cache/invalidate[key: ?u, namespace: "user"] }
          }
          ```

          ## Guarded Sync
          ```
          sync HighValue [eventual] {
            when { Order/place => ok[order: ?o] }
            where { Order: { ?o total: ?amount } }
            filter(?amount > 1000)
            then { Alert/create[type: "high-value", ref: ?o] }
          }
          ```
    validation-commands:
      - label: "Parse all sync files"
        command: "npx tsx tools/copf-cli/src/index.ts compile-syncs"
      - label: "Run sync parser tests"
        command: "npx vitest run tests/sync-parser.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Element | Syntax | Purpose |
        |---------|--------|---------|
        | Sync declaration | `sync Name [mode] { ... }` | Define a synchronization rule |
        | When clause | `Concept/action => variant[bindings]` | Pattern match on completion |
        | Where clause | `Concept: { ?item field: ?val }` | Query concept state |
        | Then clause | `Concept/action[params]` | Invoke target action |
    related-workflows:
      - name: sync-designer
        description: "Compile validated sync rules into executables"
      - name: concept-validator
        description: "Validate concept specs referenced by syncs"
    anti-patterns:
      - title: "Unbound variable in then-clause"
        description: "Then-clause uses a variable not bound in when or where — will fail at runtime."
        bad: |
          sync Broken [eager] {
            when { User/create => ok[user: ?u] }
            then { Email/send[to: ?email] }
          }
        good: |
          sync Working [eager] {
            when { User/create => ok[user: ?u] }
            where { User: { ?u email: ?email } }
            then { Email/send[to: ?email] }
          }

  # ─── FlowTrace: trace-debugger ────────────────────
  trace-debugger:
    concept: FlowTrace
    steps:
      - action: build
        title: "Build Execution Trace"
        prose: "Build a trace from a flow ID showing which concepts were invoked, what syncs fired, and data flow between them."
      - action: render
        title: "Render Trace Output"
        prose: "Render the trace tree as a human-readable output with timing, success/failure status, and data flow arrows."
    checklists:
      build:
        - "Flow ID exists in action log?"
        - "All causal links followed (action → sync → action)?"
        - "Timing data captured for each node?"
      render:
        - "Tree indentation correct?"
        - "Failed nodes highlighted?"
        - "Data flow arrows show variable propagation?"
    design-principles:
      - title: "Causal Completeness"
        rule: "The trace shows the complete causal chain — every action that fired because of the initial trigger, not just the immediate effects."
      - title: "Non-Intrusive"
        rule: "Tracing reads the action log — it never modifies runtime behavior or adds overhead to normal execution."
    references:
      - path: references/debugging.md
        label: "Debugging with FlowTrace"
        tier: reference
        content: |
          # Debugging with FlowTrace

          FlowTrace builds causal execution trees from the action log,
          showing every concept action and sync firing triggered by
          an initial action.

          ## Reading a Trace

          ```
          Flow abc-123
          ├─ User/create => ok [user: u1]        2ms
          │  ├─ [sync: CreateProfile] eager
          │  │  └─ Profile/create => ok [profile: p1]  1ms
          │  └─ [sync: WelcomeEmail] eventual
          │     └─ Email/send => ok               45ms
          └─ total: 48ms
          ```

          **Reading the tree:**
          - Root node is the initial action.
          - Indented children are syncs that fired from the parent.
          - `[sync: Name]` shows which sync rule triggered the action.
          - Timing shows per-node and total duration.

          ## Common Debugging Scenarios

          ### Sync didn't fire
          1. Check the when-clause variant matches the actual completion.
          2. Verify variable bindings — a misspelled binding silently fails.
          3. Check sync mode — eventual syncs execute asynchronously.

          ### Unexpected cascade
          1. Look for broad pattern matches (missing variant name).
          2. Check if multiple syncs react to the same completion.
          3. Look for circular chains: A→B→C→A.

          ### Slow execution
          1. Look for deep nesting (long sync chains).
          2. Check eventual syncs for slow external calls.
          3. Look for N+1 patterns in where-clause queries.

          ## Trace Commands

          | Command | Purpose |
          |---------|---------|
          | `copf trace <flow-id>` | Build and display a trace |
          | `copf trace <flow-id> --json` | Output trace as JSON |
          | `copf trace --recent` | Show last 10 flow traces |
    validation-commands:
      - label: "Build a trace"
        command: "npx tsx tools/copf-cli/src/index.ts trace <flow-id>"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | build | `copf trace <flow-id>` | Build trace from a flow ID |
        | render | (automatic) | Render trace as tree output |
    related-workflows:
      - name: sync-designer
        description: "Design the syncs whose execution traces debug"
      - name: concept-validator
        description: "Validate specs before debugging runtime issues"
      - name: dev-workflow
        description: "Run the dev server to generate flow IDs for tracing"

  # ─── DeploymentValidator: deployment-config ────────
  deployment-config:
    concept: DeploymentValidator
    steps:
      - action: validate
        title: "Validate Deployment Manifest"
        prose: "Validate that deployment manifests correctly map concepts to runtimes, assign syncs to engines, and satisfy capability requirements."
    checklists:
      validate:
        - "Every concept mapped to a runtime?"
        - "Sync engine assignments cover all syncs?"
        - "Transport adapters match concept locations?"
        - "Capability requirements satisfied by target runtimes?"
    design-principles:
      - title: "Declarative Deployment"
        rule: "The deployment manifest declares intent (what runs where), not imperative steps — the framework resolves transport and engine assignments."
      - title: "Capability Matching"
        rule: "Each runtime declares capabilities (storage types, transport protocols) and the validator checks that every concept's needs are met."
    references:
      - path: references/deployment-guide.md
        label: "Deployment configuration guide"
        tier: reference
        content: |
          # Deployment Configuration Guide

          A deployment manifest maps concepts to runtimes, assigns syncs
          to engines, and configures transport between runtimes.

          ## Manifest Structure

          ```yaml
          deployment:
            name: my-app
            version: 1.0.0

          runtimes:
            api:
              type: node
              concepts: [User, Article, Comment]
              capabilities: [storage-postgres, transport-http]
            worker:
              type: node
              concepts: [Email, Notification]
              capabilities: [storage-redis, transport-amqp]

          engines:
            default:
              type: in-process
              syncs: [CreateProfile, UpdateCache]
            async:
              type: queue
              syncs: [WelcomeEmail, NotifyOnComment]

          transports:
            api-to-worker:
              type: http
              from: api
              to: worker
              endpoint: http://worker:3001
          ```

          ## Runtime Configuration

          Each runtime declares:
          - **type** — Execution environment (node, deno, edge)
          - **concepts** — Which concepts run in this runtime
          - **capabilities** — Available storage and transport types

          ## Engine Assignment

          Sync engines execute sync rules. Types:
          - `in-process` — Runs within the concept's runtime. For eager syncs.
          - `queue` — Uses a message queue. For eventual syncs.
          - `distributed` — Cross-runtime engine. For multi-runtime syncs.

          ## Validation Rules

          The validator checks:
          1. Every concept is assigned to exactly one runtime.
          2. Every sync is assigned to an engine.
          3. Cross-runtime syncs have a transport adapter configured.
          4. Runtime capabilities satisfy concept requirements.
      - path: references/transport-adapters.md
        label: "Transport adapter configuration"
        tier: reference
        content: |
          # Transport Adapter Reference

          Transport adapters enable cross-runtime communication when
          concepts in different runtimes need to interact through syncs.

          ## Adapter Types

          | Type | Use Case | Latency |
          |------|----------|---------|
          | `http` | REST-based communication | Medium |
          | `websocket` | Bidirectional real-time | Low |
          | `amqp` | Message queue (RabbitMQ) | Medium |
          | `in-process` | Same runtime (no transport) | None |

          ## HTTP Adapter

          ```yaml
          transports:
            api-to-worker:
              type: http
              from: api
              to: worker
              endpoint: http://worker:3001
              timeout: 5000
              retries: 3
          ```

          ## WebSocket Adapter

          ```yaml
          transports:
            realtime:
              type: websocket
              from: api
              to: client
              path: /ws
          ```

          ## AMQP Adapter

          ```yaml
          transports:
            async-bridge:
              type: amqp
              from: api
              to: worker
              url: amqp://rabbitmq:5672
              exchange: copf-events
              queue: worker-tasks
          ```

          ## When to Use Transports

          - **Same runtime**: No transport needed. Syncs run in-process.
          - **Two runtimes, same machine**: Use `http` or `in-process` IPC.
          - **Distributed**: Use `amqp` for reliability or `websocket` for
            low-latency bidirectional communication.
    validation-commands:
      - label: "Validate deployment manifest"
        command: "npx tsx tools/copf-cli/src/index.ts deploy --validate"
      - label: "Run deployment validator tests"
        command: "npx vitest run tests/deployment-validator.test.ts"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Section | Purpose | Required |
        |---------|---------|----------|
        | runtimes | Map concepts to execution environments | Yes |
        | engines | Assign sync engines to sync groups | Yes |
        | transports | Configure cross-runtime communication | If multi-runtime |
        | capabilities | Declare runtime capabilities | Recommended |
    related-workflows:
      - name: concept-validator
        description: "Validate concept specs before deployment"
      - name: cache-build
        description: "Pre-compile artifacts for faster deployment"
      - name: kit-lifecycle
        description: "Manage kits that bundle deployed concepts"
    anti-patterns:
      - title: "Missing transport for cross-runtime sync"
        description: "Two concepts in different runtimes connected by a sync but no transport adapter configured."
        bad: |
          runtimes:
            api: { concepts: [User] }
            worker: { concepts: [Email] }
          syncs:
            - SendWelcome  # User -> Email, but no transport!
        good: |
          runtimes:
            api: { concepts: [User] }
            worker: { concepts: [Email] }
          transports:
            api-to-worker: { type: http, from: api, to: worker }
          syncs:
            - SendWelcome  # Now has a transport path

  # ─── Migration: migration-runner ───────────────────
  migration-runner:
    concept: Migration
    steps:
      - action: plan
        title: "Plan Migration"
        prose: "Analyze schema changes and plan migration steps for concept state transitions."
      - action: apply
        title: "Apply Migration"
        prose: "Execute the planned migration, transforming stored state to match the new schema."
    checklists:
      plan:
        - "Schema diff shows expected changes?"
        - "No data loss in state transformations?"
        - "Rollback strategy identified?"
      apply:
        - "Backup created before applying?"
        - "Migration ran to completion?"
        - "Post-migration validation passed?"
    design-principles:
      - title: "Version Gating"
        rule: "A concept cannot start until its storage schema matches its current spec version — the migration concept gates startup."
      - title: "Reversible by Default"
        rule: "Every migration step should have a corresponding rollback step — data transformations should be invertible."
    references:
      - path: references/migration-guide.md
        label: "Migration planning and execution guide"
        tier: reference
        content: |
          # Migration Planning and Execution Guide

          When a concept's spec changes (new state fields, renamed actions,
          changed types), stored data must be migrated to match.

          ## Migration Workflow

          1. **Detect** — Compare current spec version against stored schema version.
          2. **Plan** — Generate migration steps from the schema diff.
          3. **Dry-run** — Validate the plan against a copy of stored data.
          4. **Apply** — Execute the migration, transforming stored state.
          5. **Verify** — Confirm the new schema matches the updated spec.

          ## Schema Diff Types

          | Change | Migration Action | Risk |
          |--------|-----------------|------|
          | Add field (optional) | Set default value | Low |
          | Add field (required) | Compute or prompt for value | Medium |
          | Remove field | Drop column/key | Low (data loss) |
          | Rename field | Copy + drop | Medium |
          | Change type | Transform values | High |
          | Add action | No migration needed | None |
          | Remove action | No migration needed | None |

          ## Rollback Strategy

          Every migration step should be reversible:

          ```yaml
          migration:
            steps:
              - action: addField
                concept: User
                field: displayName
                type: String
                default: ""
                rollback: removeField
          ```

          ## Commands

          | Command | Purpose |
          |---------|---------|
          | `copf migrate --status` | Show current schema versions |
          | `copf migrate --plan` | Preview planned migration steps |
          | `copf migrate --dry-run` | Test migration without applying |
          | `copf migrate --apply` | Execute the migration |

          ## Safety Rules

          - Always create a backup before applying.
          - Run `--dry-run` before `--apply` on production data.
          - Never skip schema versions — migrations are sequential.
          - Version-gate startup: concepts refuse to start if schema is outdated.
    validation-commands:
      - label: "Check migration status"
        command: "npx tsx tools/copf-cli/src/index.ts migrate --status"
      - label: "Run migration dry-run"
        command: "npx tsx tools/copf-cli/src/index.ts migrate --dry-run"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | plan | `copf migrate --plan` | Show planned migration steps |
        | apply | `copf migrate --apply` | Execute migration |
        | status | `copf migrate --status` | Check current schema versions |
    related-workflows:
      - name: concept-validator
        description: "Validate the updated concept spec"
      - name: implementation-builder
        description: "Update the handler implementation after schema change"
      - name: deployment-config
        description: "Re-validate deployment after migration"

  # ─── ProjectScaffold: project-initializer ──────────
  project-initializer:
    concept: ProjectScaffold
    steps:
      - action: scaffold
        title: "Scaffold New Project"
        prose: "Create a new COPF project directory with specs, syncs, implementations, and configuration files."
    checklists:
      scaffold:
        - "Project name is valid (kebab-case, no conflicts)?"
        - "Directory structure created correctly?"
        - "Example concept spec is parseable?"
        - "Configuration files have sensible defaults?"
    design-principles:
      - title: "Minimal Viable Structure"
        rule: "Scaffold the minimum needed to run `copf check` and `copf generate` — don't overload with unused templates."
      - title: "Convention Over Configuration"
        rule: "Project follows standard directory layout (specs/, syncs/, implementations/) so tools work without configuration."
    references:
      - path: references/project-structure.md
        label: "Standard project directory layout"
        tier: reference
        content: |
          # Standard Project Directory Layout

          A COPF project follows a convention-over-configuration directory
          structure. Tools expect this layout to work without extra config.

          ## Directory Tree

          ```
          my-app/
          ├── specs/                 # Concept specifications
          │   ├── user.concept
          │   ├── article.concept
          │   └── comment.concept
          ├── syncs/                 # Synchronization rules
          │   ├── create-profile.sync
          │   └── welcome-email.sync
          ├── implementations/       # Handler code
          │   ├── user.impl.ts
          │   ├── article.impl.ts
          │   └── comment.impl.ts
          ├── kits/                  # Reusable concept packages
          │   └── auth-kit/
          │       ├── kit.yaml
          │       ├── concepts/
          │       └── syncs/
          ├── tests/                 # Conformance and integration tests
          │   ├── user.test.ts
          │   └── syncs.test.ts
          ├── generated/             # Auto-generated output (do not edit)
          │   ├── manifests/
          │   └── types/
          ├── deploy.yaml            # Deployment manifest
          └── copf.config.yaml       # Project configuration
          ```

          ## Key Directories

          | Directory | Purpose | File Types |
          |-----------|---------|------------|
          | `specs/` | Concept definitions | `.concept` |
          | `syncs/` | Sync rules | `.sync` |
          | `implementations/` | Handler code | `.impl.ts` |
          | `kits/` | Reusable packages | `kit.yaml` + subdirs |
          | `generated/` | Auto-generated (gitignored) | `.ts`, `.json` |
          | `tests/` | Tests | `.test.ts` |

          ## Configuration File

          ```yaml
          # copf.config.yaml
          project:
            name: my-app
            version: 0.1.0
          specs:
            dir: ./specs
          syncs:
            dir: ./syncs
          output:
            dir: ./generated
          ```
    validation-commands:
      - label: "Validate scaffolded project"
        command: "npx tsx tools/copf-cli/src/index.ts check"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Directory | Purpose | Contains |
        |-----------|---------|----------|
        | specs/ | Concept specifications | .concept files |
        | syncs/ | Synchronization rules | .sync files |
        | implementations/ | Handler code | .impl.ts files |
        | kits/ | Kit manifests | kit.yaml + concepts + syncs |
    related-workflows:
      - name: concept-designer
        description: "Design concepts for the new project"
      - name: kit-lifecycle
        description: "Bundle concepts into reusable kits"
      - name: dev-workflow
        description: "Start the dev server for the new project"

  # ─── KitManager: kit-lifecycle ─────────────────────
  kit-lifecycle:
    concept: KitManager
    steps:
      - action: init
        title: "Create Kit"
        prose: "Scaffold a new kit directory with kit.yaml, concept and sync subdirectories, and example files."
      - action: validate
        title: "Validate Kit"
        prose: "Validate a kit manifest, its concept specs, sync definitions, and cross-kit references."
      - action: test
        title: "Test Kit"
        prose: "Run conformance and integration tests for the kit."
      - action: list
        title: "List Active Kits"
        prose: "List all kits used by the current application."
      - action: checkOverrides
        title: "Check Overrides"
        prose: "Verify that application sync overrides reference valid syncs in the target kit."
    checklists:
      init:
        - "Kit name follows naming convention?"
        - "Kit.yaml has required fields (name, version, description)?"
        - "Example concept spec is valid?"
      validate:
        - "All concept specs parse successfully?"
        - "All sync files compile?"
        - "Cross-kit references resolve?"
        - "Type parameters align across concepts?"
      test:
        - "Conformance tests pass?"
        - "Integration tests pass?"
        - "No failing assertions?"
      checkOverrides:
        - "Override references valid syncs?"
        - "Override parameters match original sync signature?"
    design-principles:
      - title: "Kit as Reusable Unit"
        rule: "A kit bundles related concepts and syncs into a single distributable package — like an npm package for COPF."
      - title: "Cross-Kit Isolation"
        rule: "Concepts in one kit never reference concepts in another kit directly — cross-kit integration happens through syncs and type parameter alignment."
      - title: "Required vs Recommended Syncs"
        rule: "Kit syncs are tiered: required syncs are load-bearing, recommended syncs provide useful defaults, integration syncs wire to other kits."
    references:
      - path: references/kit-structure.md
        label: "Kit manifest and directory structure"
        tier: reference
        content: |
          # Kit Manifest and Directory Structure

          A kit bundles related concepts and syncs into a reusable package.

          ## Kit Directory

          ```
          my-kit/
          ├── kit.yaml              # Kit manifest
          ├── concepts/             # Concept specs
          │   ├── user.concept
          │   └── profile.concept
          ├── syncs/                # Internal syncs
          │   └── create-profile.sync
          ├── implementations/      # Default implementations
          │   ├── user.impl.ts
          │   └── profile.impl.ts
          └── tests/                # Kit tests
              └── conformance.test.ts
          ```

          ## Kit Manifest (kit.yaml)

          ```yaml
          kit:
            name: auth
            version: 1.0.0
            description: Authentication and identity management

          concepts:
            - concepts/user.concept
            - concepts/password.concept
            - concepts/session.concept

          syncs:
            required:
              - syncs/validate-session.sync
            recommended:
              - syncs/create-profile.sync
            integration:
              - syncs/audit-login.sync

          typeParameters:
            User: [U]
            Session: [S, U]

          dependencies: []
          ```

          ## Sync Tiers

          | Tier | Meaning | Override? |
          |------|---------|-----------|
          | `required` | Load-bearing, must be active | No |
          | `recommended` | Useful defaults | Yes |
          | `integration` | Wire to other kits | Yes |

          ## Kit vs Application Syncs

          Kit syncs wire concepts *within* the kit. Application syncs
          wire *across* kits. Applications can override recommended
          and integration syncs but not required syncs.
      - path: references/kit-publishing.md
        label: "Publishing and versioning kits"
        tier: reference
        content: |
          # Publishing and Versioning Kits

          ## Versioning

          Kits follow semantic versioning:
          - **Major** — Breaking changes to concept specs or required syncs.
          - **Minor** — New concepts, new optional syncs, new actions.
          - **Patch** — Bug fixes, documentation, implementation improvements.

          ## Publishing Workflow

          1. **Validate** — `copf kit validate ./kits/my-kit`
          2. **Test** — `copf kit test ./kits/my-kit`
          3. **Version** — Update `kit.yaml` version field.
          4. **Package** — `copf kit pack ./kits/my-kit`
          5. **Publish** — `copf kit publish ./kits/my-kit`

          ## Registry

          Kits are published to a registry (npm-compatible):

          ```bash
          # Publish to default registry
          copf kit publish ./kits/my-kit

          # Publish to custom registry
          copf kit publish ./kits/my-kit --registry https://my-registry.com
          ```

          ## Installing Kits

          ```bash
          copf kit add auth@1.0.0
          ```

          This adds the kit to the project's `copf.config.yaml`:

          ```yaml
          kits:
            - name: auth
              version: 1.0.0
              overrides:
                syncs:
                  - syncs/custom-profile.sync  # Override recommended sync
          ```

          ## Breaking Change Guidelines

          When making a breaking change:
          1. Bump major version.
          2. Document migration steps.
          3. Provide a migration sync if state schema changed.
    anti-patterns:
      - title: "Cross-kit concept reference"
        description: "Kit A's concept imports Kit B's types directly instead of using type parameters."
        bad: |
          # In kit-a/concepts/order.concept
          concept Order [O] {
            state { customer: O -> kit_b.User }  # Direct reference!
          }
        good: |
          # In kit-a/concepts/order.concept
          concept Order [O, U] {
            state { customer: O -> U }  # Type parameter, wired by sync
          }
      - title: "Monolithic kit"
        description: "Kit bundles unrelated concepts — violates the reusable unit principle."
        bad: |
          # kit.yaml
          kit: { name: everything }
          concepts: [User, Article, Payment, Analytics, Email, Notification]
        good: |
          # Split into focused kits
          kit: { name: content }   # concepts: [Article, Tag, Comment]
          kit: { name: commerce }  # concepts: [Payment, Invoice, Refund]
    validation-commands:
      - label: "Validate a kit"
        command: "npx tsx tools/copf-cli/src/index.ts kit validate ./kits/my-kit"
      - label: "Run kit tests"
        command: "npx tsx tools/copf-cli/src/index.ts kit test ./kits/my-kit"
      - label: "List active kits"
        command: "npx tsx tools/copf-cli/src/index.ts kit list"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | init | `copf kit init <name>` | Scaffold a new kit |
        | validate | `copf kit validate <path>` | Validate kit manifest |
        | test | `copf kit test <path>` | Run kit tests |
        | list | `copf kit list` | List active kits |
        | checkOverrides | `copf kit check-overrides <path>` | Verify sync overrides |
    related-workflows:
      - name: concept-designer
        description: "Design concepts to include in the kit"
      - name: sync-designer
        description: "Write syncs that wire kit concepts together"
      - name: deployment-config
        description: "Deploy kits to production runtimes"

  # ─── DevServer: dev-workflow ───────────────────────
  dev-workflow:
    concept: DevServer
    steps:
      - action: start
        title: "Start Dev Server"
        prose: "Start a local development server that watches for changes and auto-recompiles."
      - action: status
        title: "Check Status"
        prose: "Check whether the dev server is running and view uptime stats."
      - action: stop
        title: "Stop Server"
        prose: "Stop the running development server."
    checklists:
      start:
        - "Port is available?"
        - "Specs and syncs directories exist?"
        - "Initial compilation succeeds?"
      status:
        - "Server is responsive?"
        - "Last recompile was successful?"
    design-principles:
      - title: "Watch and Recompile"
        rule: "The dev server watches .concept and .sync files for changes and recompiles automatically — no manual rebuild step."
      - title: "Fast Feedback Loop"
        rule: "Recompilation should complete in under a second for typical projects — parse errors show immediately."
    references:
      - path: references/dev-workflow.md
        label: "Development workflow guide"
        tier: reference
        content: |
          # Development Workflow Guide

          The COPF dev server provides a fast feedback loop for iterating
          on concept specs and sync rules.

          ## Starting the Dev Server

          ```bash
          copf dev --port 3000
          ```

          The dev server:
          1. Parses all `.concept` files in `specs/`.
          2. Compiles all `.sync` files in `syncs/`.
          3. Generates manifests and types.
          4. Watches for file changes and re-runs on save.

          ## Development Cycle

          1. **Edit a .concept file** — Save triggers reparse + validation.
          2. **Edit a .sync file** — Save triggers recompile + binding check.
          3. **Edit a .impl.ts file** — Save triggers type check against manifest.
          4. **View errors** — Parse/compile errors show in terminal immediately.

          ## Watch Mode Behavior

          | File Change | Action Taken |
          |-------------|-------------|
          | `.concept` modified | Reparse spec, regenerate manifest |
          | `.sync` modified | Recompile sync, recheck bindings |
          | `.impl.ts` modified | Type-check against manifest |
          | `copf.config.yaml` modified | Full restart |

          ## Debugging During Dev

          The dev server assigns flow IDs to every action invocation.
          Use `copf trace <flow-id>` to debug execution chains.

          ## Performance

          - Incremental recompilation: only changed files are reprocessed.
          - Typical recompile time: under 100ms for small-medium projects.
          - Full rebuild on config change or first start.
    validation-commands:
      - label: "Start dev server"
        command: "npx tsx tools/copf-cli/src/index.ts dev --port 3000"
      - label: "Check dev server status"
        command: "npx tsx tools/copf-cli/src/index.ts dev status"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | start | `copf dev --port <port>` | Start dev server |
        | status | `copf dev status` | Check if running |
        | stop | `copf dev stop` | Stop the server |
    related-workflows:
      - name: concept-validator
        description: "Validate specs that the dev server watches"
      - name: trace-debugger
        description: "Debug flows generated during dev server sessions"
      - name: cache-build
        description: "Pre-compile for production after dev iteration"

  # ─── CacheCompiler: cache-build ────────────────────
  cache-build:
    concept: CacheCompiler
    steps:
      - action: compile
        title: "Build Cache"
        prose: "Parse specs and syncs, generate manifests, compile sync rules, and write pre-compiled artifacts to the cache directory."
    checklists:
      compile:
        - "All concept specs parse without errors?"
        - "All sync files compile?"
        - "Cache directory is writable?"
        - "Previous cache is cleaned or invalidated?"
    design-principles:
      - title: "Content-Addressed Cache"
        rule: "Cached artifacts are keyed by content hash — identical input produces identical output, and unchanged files are never rewritten."
      - title: "Complete Compilation"
        rule: "Cache includes everything needed for deployment — parsed ASTs, generated manifests, compiled syncs, and type information."
    references:
      - path: references/caching.md
        label: "Cache compilation and invalidation"
        tier: reference
        content: |
          # Cache Compilation and Invalidation

          The cache compiler pre-compiles all concept specs and sync rules
          into artifacts for faster startup and deployment.

          ## What Gets Cached

          | Artifact | Source | Format |
          |----------|--------|--------|
          | Parsed ASTs | `.concept` files | JSON |
          | Concept manifests | Parsed ASTs | JSON |
          | Compiled syncs | `.sync` files | JavaScript |
          | Type definitions | Manifests | TypeScript `.d.ts` |

          ## Cache Directory

          ```
          .copf-cache/
          ├── manifests/
          │   ├── user.manifest.json
          │   └── article.manifest.json
          ├── syncs/
          │   ├── create-profile.compiled.js
          │   └── welcome-email.compiled.js
          ├── types/
          │   ├── user.d.ts
          │   └── article.d.ts
          └── cache.lock.json       # Content hashes for invalidation
          ```

          ## Content-Addressed Invalidation

          Each cached artifact is keyed by the content hash of its source
          file. When you run `copf compile --cache`:

          1. Hash each source file.
          2. Compare against `cache.lock.json`.
          3. Only recompile files whose hash changed.
          4. Update `cache.lock.json` with new hashes.

          ## Commands

          | Command | Purpose |
          |---------|---------|
          | `copf compile --cache` | Build/rebuild the cache |
          | `copf compile --cache --clean` | Wipe and rebuild from scratch |
          | `copf compile --cache --verbose` | Show per-file cache hits/misses |

          ## Deployment Use

          In production, deploy the `.copf-cache/` directory alongside
          your application. The runtime loads pre-compiled artifacts
          instead of parsing specs at startup.
    validation-commands:
      - label: "Build the cache"
        command: "npx tsx tools/copf-cli/src/index.ts compile --cache"
      - label: "Verify cache contents"
        command: "ls -la .copf-cache/"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | compile | `copf compile --cache` | Build pre-compiled cache |
    related-workflows:
      - name: concept-validator
        description: "Validate specs before caching"
      - name: deployment-config
        description: "Deploy using cached artifacts"
      - name: dev-workflow
        description: "Dev server uses cache for fast startup"

  # ─── Emitter: file-emission ──────────────────────────
  file-emission:
    concept: Emitter
    steps:
      - action: write
        title: "Write Single File"
        prose: "Write a single generated file with content-addressed deduplication."
      - action: writeBatch
        title: "Emit Generated Files"
        prose: "Atomically write a batch of generated files with content-addressed deduplication."
      - action: audit
        title: "Drift Detection"
        prose: "Compare generated files on disk against expected output to detect manual edits."
      - action: clean
        title: "Orphan Cleanup"
        prose: "Remove output files that are no longer produced by any generator."
      - action: trace
        title: "Source Provenance"
        prose: "Show which source files and concept actions produced a given output file."
      - action: affected
        title: "Impact Analysis"
        prose: "Show what output files are affected by a change to a given source file."
    checklists:
      write:
        - "Path is within the designated output directory?"
        - "Content hash computed before write?"
      writeBatch:
        - "All source provenance metadata attached?"
        - "Format hint set for each file?"
        - "Output directory exists?"
      audit:
        - "Generated files match expected hashes?"
        - "No manual edits detected?"
      clean:
        - "Current manifest accurately lists all expected files?"
        - "Orphaned files identified and removed?"
      trace:
        - "Output path resolves to a tracked generated file?"
        - "Source provenance entries are complete?"
      affected:
        - "Source path resolves to a tracked input?"
        - "All downstream outputs identified?"
    design-principles:
      - title: "Content-Addressed Writes"
        rule: "Files are only written when their content hash changes — identical rewrites are skipped."
      - title: "Source Provenance"
        rule: "Every output file tracks which source files and concept actions produced it."
    references:
      - path: references/emitter-architecture.md
        label: "Emitter architecture and traceability"
        tier: reference
        content: |
          # Emitter Architecture

          The Emitter concept manages all file I/O for the generation pipeline.

          ## Content-Addressed Writes

          Every `write` or `writeBatch` call computes a SHA-256 hash of the
          content. If the on-disk file already matches, the write is skipped.
          This prevents unnecessary file-system churn and avoids triggering
          downstream watchers.

          ## Source Provenance (sourceMap)

          Each output file stores a list of sources that contributed to it:
          - `sourcePath` — the input file (e.g., `specs/app/article.concept`)
          - `conceptName` — the concept that produced it
          - `actionName` — the action (e.g., `generate`)

          This enables:
          - `copf impact <file>` — which outputs change if this input changes
          - `copf emitter trace <output>` — which inputs produced this output
          - `copf emitter audit <dir>` — detect files modified outside generation

          ## Batch Writes

          `writeBatch` writes multiple files atomically — if any file fails,
          the batch reports the failure while the successful writes persist.
    validation-commands:
      - label: "Audit generated files"
        command: "npx tsx tools/copf-cli/src/index.ts generate --audit"
      - label: "Clean orphans"
        command: "npx tsx tools/copf-cli/src/index.ts generate --clean"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | write | `copf emitter write` | Write a single file |
        | writeBatch | `copf emitter write-batch` | Atomic batch write |
        | audit | `copf emitter audit <dir>` | Detect drift |
        | clean | `copf emitter clean <dir>` | Remove orphans |
        | trace | `copf emitter trace <path>` | Show source provenance |
        | affected | `copf emitter affected <path>` | Show impact of a source change |
        | manifest | `copf emitter manifest <dir>` | List all tracked outputs |
        | format | `copf emitter format <path>` | Format a generated file |
    related-workflows:
      - name: cache-compiler
        description: "Cache compiler uses Emitter for output"
      - name: implementation-builder
        description: "Code generation writes through Emitter"

  # ─── BuildCache: incremental-caching ──────────────────
  incremental-caching:
    concept: BuildCache
    steps:
      - action: check
        title: "Check Cache"
        prose: "Compare input hash against cached entry to determine if regeneration is needed."
      - action: record
        title: "Record Result"
        prose: "Store generation result with input/output hashes for future cache lookups."
      - action: status
        title: "Cache Status"
        prose: "Show all cache entries with staleness indicators."
      - action: staleSteps
        title: "List Stale Entries"
        prose: "List step keys that need regeneration because their inputs have changed."
    checklists:
      check:
        - "Step key uniquely identifies this generation step?"
        - "Input hash is deterministic?"
      record:
        - "Output hash computed from actual files written?"
        - "Source locator recorded for invalidation?"
      status:
        - "Stale entries identified?"
      staleSteps:
        - "All step keys evaluated?"
    design-principles:
      - title: "Hash-Based Invalidation"
        rule: "Cache validity is determined solely by comparing input hashes — no timestamps or file watchers."
      - title: "Per-Step Granularity"
        rule: "Each generator+concept pair has its own cache entry, enabling partial rebuilds."
    references:
      - path: references/build-cache-architecture.md
        label: "BuildCache design and invalidation strategy"
        tier: reference
        content: |
          # BuildCache Architecture

          BuildCache tracks generation results per step key (generator:concept pair).

          ## Cache Check Flow

          1. Compute input hash (deterministic hash of concept manifest or projection)
          2. Look up step key in cache
          3. Compare hashes → `unchanged` (cache hit) or `changed` (cache miss)

          ## Invalidation Strategies

          - **By source**: When a `.concept` file changes, invalidate all steps
            that used it (`invalidateBySource`)
          - **By kind**: When an IR kind is invalidated, cascade to all dependent
            kinds (`invalidateByKind`)
          - **Manual**: `invalidateAll` clears the entire cache

          ## Deterministic vs Non-Deterministic

          Deterministic generators (same input → same output) can be cached
          aggressively. Non-deterministic generators (e.g., timestamp-based)
          are always re-run.
    validation-commands:
      - label: "Show cache status"
        command: "npx tsx tools/copf-cli/src/index.ts generate --status"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | check | `copf build-cache check` | Check if step is cached |
        | record | `copf build-cache record` | Record generation result |
        | status | `copf build-cache status` | Show all cache entries |
        | staleSteps | `copf build-cache stale-steps` | List stale entries |
        | invalidate | `copf build-cache invalidate` | Invalidate one step |
        | invalidateBySource | `copf build-cache invalidate-by-source` | Invalidate by source file |
        | invalidateByKind | `copf build-cache invalidate-by-kind` | Invalidate by IR kind |
        | invalidateAll | `copf build-cache invalidate-all` | Clear entire cache |
    related-workflows:
      - name: file-emission
        description: "Emitter writes files after cache miss"
      - name: incremental-caching
        description: "Self-referential: cache checks gate generation"

  # ─── Resource: input-tracking ────────────────────────
  input-tracking:
    concept: Resource
    steps:
      - action: upsert
        title: "Track Input"
        prose: "Register or update a tracked input resource with its content digest."
      - action: list
        title: "List Resources"
        prose: "List all tracked input resources, optionally filtered by kind."
    checklists:
      upsert:
        - "Locator is a stable, unique identifier?"
        - "Digest is a content hash (not a timestamp)?"
      list:
        - "Kind filter matches expected resource types?"
    design-principles:
      - title: "Content-Addressed Tracking"
        rule: "Resources are tracked by content digest, not modification time. Two files with identical content have the same digest."
    validation-commands:
      - label: "List tracked resources"
        command: "npx tsx tools/copf-cli/src/index.ts generate --status"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | upsert | `copf resource upsert` | Track or update an input |
        | get | `copf resource get` | Look up a tracked resource |
        | list | `copf resource list` | List all tracked inputs |
        | remove | `copf resource remove` | Stop tracking a resource |
        | diff | `copf resource diff` | Classify a content change |
    related-workflows:
      - name: incremental-caching
        description: "Resource changes invalidate BuildCache entries"
      - name: file-emission
        description: "Resource tracking feeds into generation pipeline"

  # ─── KindSystem: pipeline-topology ───────────────────
  pipeline-topology:
    concept: KindSystem
    steps:
      - action: graph
        title: "View Kind Graph"
        prose: "Display the full IR kind taxonomy showing all kinds and transform edges."
      - action: route
        title: "Find Transform Path"
        prose: "Find the shortest transform path between two IR kinds."
      - action: consumers
        title: "Show Consumers"
        prose: "List all transforms that consume a given kind."
      - action: producers
        title: "Show Producers"
        prose: "List all transforms that produce a given kind."
    checklists:
      graph:
        - "All generator kinds registered?"
        - "No orphan kinds (unreachable from any source)?"
      route:
        - "Path exists between the two kinds?"
    design-principles:
      - title: "Cycle-Free DAG"
        rule: "The kind graph must be a directed acyclic graph. Cycle detection runs on every connect() call."
      - title: "Static Topology"
        rule: "Kinds and edges are registered at startup from kit.yaml metadata, not at generation time."
    references:
      - path: references/kind-system-architecture.md
        label: "KindSystem taxonomy and routing"
        tier: reference
        content: |
          # KindSystem Architecture

          The KindSystem models the pipeline topology as a directed acyclic graph
          of IR (intermediate representation) kinds.

          ## Kind Categories

          - **source**: Raw input files (ConceptDSL, SyncDSL, InterfaceManifest)
          - **model**: Parsed/structured data (ConceptAST, ConceptManifest, Projection)
          - **artifact**: Generated output files (TypeScriptFiles, RestRoutes, etc.)

          ## Transform Edges

          Each edge represents a generator that transforms one kind into another:
          - `ConceptDSL →[SpecParser]→ ConceptAST`
          - `ConceptAST →[SchemaGen]→ ConceptManifest`
          - `ConceptManifest →[TypeScriptGen]→ TypeScriptFiles`
          - `Projection →[RestTarget]→ RestRoutes`

          ## Routing

          `route(from, to)` finds the shortest path using BFS. This determines
          which generators must run to produce a desired artifact from a given source.

          ## Cascade Invalidation

          When a kind is invalidated, `dependents(kind)` returns all downstream
          kinds that need re-generation. This drives the cascade invalidation syncs.
    validation-commands:
      - label: "List all kinds"
        command: "npx tsx tools/copf-cli/src/index.ts kinds list"
      - label: "Find transform path"
        command: "npx tsx tools/copf-cli/src/index.ts kinds path ConceptDSL TypeScriptFiles"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | graph | `copf kind-system graph` | Show full kind taxonomy |
        | route | `copf kind-system route` | Find shortest transform path |
        | consumers | `copf kind-system consumers` | What consumes a kind |
        | producers | `copf kind-system producers` | What produces a kind |
        | define | `copf kind-system define` | Register a new kind |
        | connect | `copf kind-system connect` | Declare a transform edge |
        | validate | `copf kind-system validate` | Validate an edge |
        | dependents | `copf kind-system dependents` | List downstream kinds |
    related-workflows:
      - name: incremental-caching
        description: "Kind graph drives cascade invalidation"
      - name: file-emission
        description: "Kind routing determines generation order"

  # ─── GenerationPlan: run-tracking ────────────────────
  run-tracking:
    concept: GenerationPlan
    steps:
      - action: status
        title: "Run Status"
        prose: "Show detailed step-by-step status of a generation run."
      - action: summary
        title: "Run Summary"
        prose: "Show aggregate statistics: total/executed/cached/failed steps, duration, files produced."
      - action: history
        title: "Run History"
        prose: "Show recent generation runs with their outcomes."
    checklists:
      status:
        - "Run reference is valid?"
      summary:
        - "All steps accounted for?"
      history:
        - "Limit is reasonable?"
    design-principles:
      - title: "Passive Observer"
        rule: "GenerationPlan is purely passive — it records what syncs report, never drives execution."
      - title: "Run Isolation"
        rule: "Each generation run has its own reference. Steps are recorded against the active run."
    validation-commands:
      - label: "Show generation summary"
        command: "npx tsx tools/copf-cli/src/index.ts generate --summary"
      - label: "Show generation history"
        command: "npx tsx tools/copf-cli/src/index.ts generate --history"
    quick-reference:
      heading: "Quick Reference"
      body: |
        | Action | Command | Purpose |
        |--------|---------|---------|
        | begin | `copf generation-plan begin` | Mark run started |
        | recordStep | `copf generation-plan record-step` | Record step outcome |
        | complete | `copf generation-plan complete` | Mark run finished |
        | status | `copf generation-plan status` | Show step-by-step status |
        | summary | `copf generation-plan summary` | Show aggregate statistics |
        | history | `copf generation-plan history` | Show recent runs |
    related-workflows:
      - name: file-emission
        description: "Emitter writes tracked by GenerationPlan"
      - name: incremental-caching
        description: "Cache hits/misses recorded as steps"

# ─── ANNOTATIONS ─────────────────────────────────────
# Rich metadata for skills and CLI: tool permissions,
# argument templates, code examples, references, and
# trigger descriptions.

annotations:
  SpecParser:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when designing, creating, or validating concept specs following
        Jackson's methodology. Covers purpose articulation, state design,
        action design, invariant writing, and spec syntax validation.
      intro-template: >
        Parse and validate concept spec **$ARGUMENTS** to verify syntax,
        structure, and adherence to Jackson's concept design methodology.
      companion-docs:
        - path: examples/design-a-concept.md
          label: "End-to-end concept design walkthrough"
          content: |
            # Walkthrough: Designing a Concept from Scratch

            This walkthrough shows how to design a `Bookmark` concept
            following Jackson's methodology.

            ## Step 1: Articulate the Purpose

            > What is this concept for?

            ```
            purpose { Allow users to save and organize references to items. }
            ```

            - One sentence, imperative present tense.
            - No implementation details (no "stores in database").

            ## Step 2: Design the State

            Start from the purpose. A bookmark needs:
            - A collection of bookmarks
            - Which user owns it
            - Which item it references
            - Optional: a label

            ```
            state {
              bookmarks: set B
              owner: B -> U
              item: B -> I
              label: B -> option String
              created: B -> String
            }
            ```

            ## Step 3: Design the Actions

            What can users do with bookmarks?

            ```
            actions {
              action add(item: I, label: option String) {
                -> ok(bookmark: B) { Bookmark created. }
                -> duplicate(item: I) { Item already bookmarked. }
              }
              action remove(bookmark: B) {
                -> ok { Bookmark removed. }
                -> notFound(bookmark: B) { Bookmark does not exist. }
              }
              action list(owner: U) {
                -> ok(bookmarks: list B) { User's bookmarks returned. }
              }
            }
            ```

            ## Step 4: Write Invariants

            ```
            invariants {
              after add(item) -> ok(bookmark) {
                then { bookmark in bookmarks; item(bookmark) = item }
              }
              after remove(bookmark) -> ok {
                then { bookmark not in bookmarks }
              }
            }
            ```

            ## Step 5: Validate

            ```bash
            copf check specs/bookmark.concept
            ```
      example-walkthroughs:
        - path: examples/design-a-concept.md
          label: "Design a concept from scratch (Bookmark example)"
    parse:
      examples:
        - label: "Parse a concept file"
          language: typescript
          code: |
            import { parseConceptFile } from './parser';
            const ast = parseConceptFile(source);
        - label: "Parse from CLI"
          language: bash
          code: "copf check specs/my-concept.concept"
      references:
        - path: references/concept-grammar.md
          label: "Full concept grammar specification"

  SchemaGen:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when generating ConceptManifests from parsed ASTs, implementing
        concept handlers, or inspecting the schema that drives code generation.
      intro-template: >
        Generate a ConceptManifest from **$ARGUMENTS** that provides typed
        action signatures, state schemas, and invariant test values for
        code generation.
      companion-docs:
        - path: examples/implement-a-handler.md
          label: "End-to-end handler implementation walkthrough"
          content: |
            # Walkthrough: Implementing a Concept Handler

            This walkthrough shows how to implement a handler for the
            `User` concept from spec to working code.

            ## Step 1: Generate the Manifest

            ```bash
            copf generate specs/user.concept
            ```

            This produces `generated/manifests/user.manifest.json` with typed
            action signatures.

            ## Step 2: Create the Handler File

            ```typescript
            // implementations/user.impl.ts
            import type { ConceptHandler, ConceptStorage } from '@copf/kernel';

            interface UserState {
              name: string;
              email: string;
            }

            export const userHandler: ConceptHandler<UserState> = {
              async create(input, storage) {
                // Check for duplicate
                for (const [id, user] of await storage.entries()) {
                  if (user.name === input.name) {
                    return { variant: 'duplicate', name: input.name };
                  }
                }
                // Create
                const id = crypto.randomUUID();
                await storage.set(id, { name: input.name, email: input.email });
                return { variant: 'ok', user: id };
              },

              async delete(input, storage) {
                if (!await storage.has(input.user)) {
                  return { variant: 'notFound', user: input.user };
                }
                await storage.delete(input.user);
                return { variant: 'ok' };
              },
            };
            ```

            ## Step 3: Verify Against Manifest

            Every variant declared in the spec must have a code path:
            - `create → ok` ✓
            - `create → duplicate` ✓
            - `delete → ok` ✓
            - `delete → notFound` ✓

            ## Step 4: Run Tests

            ```bash
            npx vitest run tests/user.test.ts
            ```
      example-walkthroughs:
        - path: examples/implement-a-handler.md
          label: "Implement a concept handler (User example)"
    generate:
      examples:
        - label: "Generate manifest from AST"
          language: typescript
          code: |
            import { schemaGenHandler } from './schema-gen.impl';
            const result = await schemaGenHandler.generate(
              { conceptAst: JSON.stringify(ast) }, storage
            );
        - label: "Generate from CLI"
          language: bash
          code: "copf generate specs/my-concept.concept"
      references:
        - path: references/type-mapping.md
          label: "Spec-to-TypeScript type mapping rules"

  SyncParser:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when parsing and validating .sync files against loaded concept
        manifests. Catches variable binding errors, missing concept references,
        and parameter mismatches at parse time.
      intro-template: >
        Parse sync file **$ARGUMENTS** and validate its structure, variable
        bindings, and concept references against loaded manifests.
      companion-docs:
        - path: examples/validate-a-sync.md
          label: "Sync validation walkthrough"
          content: |
            # Walkthrough: Validating a Sync File

            This walkthrough shows how to validate a sync file and fix
            common errors caught by the parser.

            ## Step 1: Write the Sync

            ```
            sync WelcomeEmail [eager] {
              when { User/create => ok[user: ?u] }
              where { User: { ?u email: ?email } }
              then { Email/send[to: ?email, template: "welcome"] }
            }
            ```

            ## Step 2: Parse and Validate

            ```bash
            copf compile-syncs syncs/welcome-email.sync
            ```

            ## Step 3: Fix Common Errors

            **Unbound variable:**
            ```
            ERROR: Variable ?email in then-clause is not bound
            FIX: Add a where-clause to bind ?email from User state
            ```

            **Missing concept reference:**
            ```
            ERROR: Concept 'Emaill' not found in loaded manifests
            FIX: Check spelling — should be 'Email'
            ```

            **Parameter mismatch:**
            ```
            ERROR: Email/send expects 'to' (String) but got 'to' (Int)
            FIX: Ensure variable type matches action parameter type
            ```
    parse:
      examples:
        - label: "Parse a sync file"
          language: typescript
          code: |
            import { syncParserHandler } from './sync-parser.impl';
            const result = await syncParserHandler.parse(
              { source: syncSource, manifests: loadedManifests }, storage
            );
        - label: "Parse from CLI"
          language: bash
          code: "copf compile-syncs syncs/my-sync.sync"
      references:
        - path: references/sync-design.md
          label: "Sync language reference"

  SyncCompiler:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when compiling parsed sync ASTs into executable registrations
        that the sync engine can evaluate at runtime.
      intro-template: >
        Compile sync rules in **$ARGUMENTS** into executable registrations
        for the sync engine.
      companion-docs:
        - path: examples/write-a-sync-chain.md
          label: "Sync chain composition walkthrough"
          content: |
            # Walkthrough: Writing a Sync Chain

            This walkthrough shows how to compose syncs into a chain
            where each sync reacts to the previous one's completion.

            ## The Scenario

            When a user registers:
            1. Create their profile (eager)
            2. Send a welcome email (eventual)
            3. Notify the admin (eventual)

            ## Step 1: Registration → Profile

            ```
            sync CreateProfile [eager] {
              when { User/create => ok[user: ?u] }
              then { Profile/create[owner: ?u] }
            }
            ```

            ## Step 2: Profile → Welcome Email

            ```
            sync WelcomeEmail [eventual] {
              when { Profile/create => ok[profile: ?p] }
              where { Profile: { ?p owner: ?u } }
              where { User: { ?u email: ?email, name: ?name } }
              then { Email/send[to: ?email, template: "welcome", data: ?name] }
            }
            ```

            ## Step 3: Registration → Admin Notification

            ```
            sync NotifyAdmin [eventual] {
              when { User/create => ok[user: ?u] }
              where { User: { ?u name: ?name } }
              then { Notification/create[type: "new-user", message: ?name] }
            }
            ```

            ## Key Points

            - Each sync sees only the completion it reacts to.
            - Sync 2 reacts to Profile/create, not to User/create.
            - Sync 3 runs independently from Sync 2.
            - Eager syncs run in the same transaction. Eventual syncs are queued.
      example-walkthroughs:
        - path: examples/write-a-sync-chain.md
          label: "Compose a sync chain (registration flow)"
    compile:
      examples:
        - label: "Compile sync rules"
          language: bash
          code: "copf compile-syncs --dir ./syncs"
        - label: "Compile programmatically"
          language: typescript
          code: |
            import { syncCompilerHandler } from './sync-compiler.impl';
            const result = await syncCompilerHandler.compile(
              { sync: parsedSync, ast: syncAst }, storage
            );
      references:
        - path: references/sync-patterns.md
          label: "Reusable sync templates and patterns"

  FlowTrace:
    concept:
      tool-permissions: [Read, Bash]
      argument-template: "<flow-id>"
      trigger-description: >
        Use when debugging action flows, tracing causal chains through
        concept actions and sync firings, or diagnosing why an expected
        sync did not trigger.
      intro-template: >
        Build a debug trace for flow **$ARGUMENTS** showing the causal
        chain of concept actions, sync firings, and data propagation.
      companion-docs:
        - path: examples/debug-a-flow.md
          label: "Flow debugging walkthrough"
          content: |
            # Walkthrough: Debugging a Flow

            This walkthrough shows how to use FlowTrace to debug
            a sync that didn't fire as expected.

            ## The Problem

            A welcome email should be sent when a user registers,
            but no email is being sent.

            ## Step 1: Find the Flow ID

            ```bash
            copf trace --recent
            ```

            Output shows recent flows. Find the User/create flow.

            ## Step 2: Build the Trace

            ```bash
            copf trace abc-123
            ```

            ```
            Flow abc-123
            ├─ User/create => ok [user: u1]        2ms
            │  └─ [sync: CreateProfile] eager
            │     └─ Profile/create => ok [p: p1]   1ms
            └─ total: 3ms
            ```

            ## Step 3: Diagnose

            The WelcomeEmail sync is missing from the trace. Check:

            1. **Is it registered?** — Check `syncs/welcome-email.sync` exists.
            2. **Does the pattern match?** — The sync watches
               `Profile/create => ok`, which DID fire. Check variable bindings.
            3. **Is it eventual?** — Eventual syncs execute asynchronously.
               Check the async queue for pending jobs.

            ## Step 4: Fix

            The sync had a typo in the variant name (`sucess` → `ok`).
            After fixing, the trace shows the complete chain.
    build:
      examples:
        - label: "Build trace from flow ID"
          language: bash
          code: "copf trace <flow-id>"
        - label: "Build trace programmatically"
          language: typescript
          code: |
            import { flowTraceHandler } from './flow-trace.impl';
            const result = await flowTraceHandler.build(
              { flowId: 'abc-123' }, storage
            );

  DeploymentValidator:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when configuring deployment manifests that map concepts to
        runtimes, assign syncs to engines, set up transport adapters,
        and validate capability requirements.
      intro-template: >
        Validate deployment manifest **$ARGUMENTS** against compiled
        concepts and syncs, checking runtime mappings, engine assignments,
        and transport configuration.
      companion-docs:
        - path: examples/configure-deployment.md
          label: "Deployment configuration walkthrough"
          content: |
            # Walkthrough: Configuring a Deployment

            This walkthrough shows how to set up a deployment manifest
            for a two-runtime application.

            ## The Application

            - **API runtime**: User, Article, Comment concepts
            - **Worker runtime**: Email, Notification concepts
            - Syncs cross the boundary (e.g., WelcomeEmail)

            ## Step 1: Define Runtimes

            ```yaml
            runtimes:
              api:
                type: node
                concepts: [User, Article, Comment]
                capabilities: [storage-postgres, transport-http]
              worker:
                type: node
                concepts: [Email, Notification]
                capabilities: [storage-redis, transport-amqp]
            ```

            ## Step 2: Assign Sync Engines

            ```yaml
            engines:
              default:
                type: in-process
                syncs: [CreateProfile, UpdateCache]
              async:
                type: queue
                syncs: [WelcomeEmail, NotifyOnComment]
            ```

            ## Step 3: Configure Transport

            ```yaml
            transports:
              api-to-worker:
                type: http
                from: api
                to: worker
                endpoint: http://worker:3001
            ```

            ## Step 4: Validate

            ```bash
            copf deploy --validate deploy.yaml
            ```
    validate:
      examples:
        - label: "Validate deployment manifest"
          language: bash
          code: "copf deploy --validate app.deploy.yaml"
      references:
        - path: references/deployment-guide.md
          label: "Deployment configuration guide"
        - path: references/transport-adapters.md
          label: "Transport adapter reference"

  Migration:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when concept schemas have changed and stored state needs to
        be migrated to match the new version. Covers migration planning,
        dry-run validation, and execution.
      intro-template: >
        Plan and apply schema migration for **$ARGUMENTS**, transforming
        stored state from the previous version to the current spec version.
      companion-docs:
        - path: examples/run-a-migration.md
          label: "Migration execution walkthrough"
          content: |
            # Walkthrough: Running a Migration

            This walkthrough shows how to migrate a concept after
            adding a new required field.

            ## The Change

            Adding a `displayName` field to the User concept:

            ```
            state {
              users: set U
              name: U -> String
              email: U -> String
              displayName: U -> String   # NEW
            }
            ```

            ## Step 1: Check Status

            ```bash
            copf migrate --status
            ```
            ```
            User: v1 (stored) → v2 (spec) — MIGRATION NEEDED
            Article: v1 (stored) → v1 (spec) — up to date
            ```

            ## Step 2: Plan

            ```bash
            copf migrate --plan
            ```
            ```
            Migration plan for User v1 → v2:
              1. ADD FIELD displayName (String)
                 Default: compute from name field
            ```

            ## Step 3: Dry Run

            ```bash
            copf migrate --dry-run
            ```

            ## Step 4: Apply

            ```bash
            copf migrate --apply
            ```
    plan:
      examples:
        - label: "Plan a migration"
          language: bash
          code: "copf migrate --plan"
    apply:
      examples:
        - label: "Apply migration"
          language: bash
          code: "copf migrate --apply"

  ProjectScaffold:
    concept:
      tool-permissions: [Read, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when starting a new COPF project from scratch. Creates the
        standard directory structure, example concept spec, and
        configuration files.
      intro-template: >
        Scaffold a new COPF project named **$ARGUMENTS** with the standard
        directory layout, example concept, and configuration files.
      companion-docs:
        - path: templates/concept-template.md
          label: "Concept spec starter template"
          content: |
            # Concept Spec Template

            Use this template when creating a new concept spec file.

            ```
            concept Name [T] {

              purpose {
                One to three sentences describing what this concept is for.
                Use imperative present tense. No implementation details.
              }

              state {
                items: set T
                // Add relations on T:
                // name: T -> String        (required field)
                // label: T -> option String (optional field)
                // tags: T -> list String    (multi-valued)
              }

              actions {
                action create(/* params */) {
                  -> ok(item: T) { Created successfully. }
                  // Add error variants as needed:
                  // -> duplicate(name: String) { Name already taken. }
                  // -> invalid(reason: String) { Validation failed. }
                }

                action delete(item: T) {
                  -> ok { Deleted successfully. }
                  -> notFound(item: T) { Item does not exist. }
                }
              }

              invariants {
                after create(/* params */) -> ok(item) {
                  then { item in items }
                }
                after delete(item) -> ok {
                  then { item not in items }
                }
              }
            }
            ```
    scaffold:
      examples:
        - label: "Scaffold a new project"
          language: bash
          code: "copf init my-app"
        - label: "Scaffold with custom template"
          language: bash
          code: "copf init my-app --template minimal"

  DevServer:
    concept:
      tool-permissions: [Read, Bash]
      argument-template: "--port <port>"
      trigger-description: >
        Use when developing concepts and syncs iteratively. The dev server
        watches for file changes and recompiles automatically, providing
        a fast feedback loop.
      intro-template: >
        Start a development server that watches concept specs and syncs for
        changes and auto-recompiles on save.
      companion-docs:
        - path: examples/dev-iteration-cycle.md
          label: "Development iteration cycle walkthrough"
          content: |
            # Walkthrough: Development Iteration Cycle

            This walkthrough shows a typical edit-validate-test cycle
            using the dev server.

            ## Step 1: Start the Dev Server

            ```bash
            copf dev --port 3000
            ```

            ```
            COPF dev server started on port 3000
            Watching: specs/, syncs/, implementations/
            Parsed 5 concepts, compiled 3 syncs — all valid
            ```

            ## Step 2: Edit a Concept

            Add a new action to `specs/user.concept`:

            ```
            action updateEmail(user: U, email: String) {
              -> ok { Email updated. }
              -> notFound(user: U) { User not found. }
            }
            ```

            Save → dev server output:
            ```
            [hot] user.concept changed
            [parse] User: valid ✓
            [generate] user.manifest.json updated
            [type] user.d.ts updated
            ```

            ## Step 3: Add a Sync

            Create `syncs/email-updated.sync`:

            ```
            sync NotifyEmailChange [eventual] {
              when { User/updateEmail => ok }
              where { User: { ?u email: ?email } }
              then { Email/send[to: ?email, template: "email-changed"] }
            }
            ```

            Save → dev server output:
            ```
            [hot] email-updated.sync changed
            [compile] NotifyEmailChange: valid ✓
            ```

            ## Step 4: Implement the Handler

            Add the handler method in `implementations/user.impl.ts`,
            then run tests to verify.
    start:
      examples:
        - label: "Start dev server"
          language: bash
          code: "copf dev --port 3000"
    status:
      examples:
        - label: "Check dev server status"
          language: bash
          code: "copf dev status"
    stop:
      examples:
        - label: "Stop dev server"
          language: bash
          code: "copf dev stop"

  CacheCompiler:
    concept:
      tool-permissions: [Read, Bash]
      argument-template: "--cache"
      trigger-description: >
        Use when building pre-compiled artifacts for deployment or to
        speed up startup. Parses all specs, generates manifests, compiles
        syncs, and writes cache files.
      intro-template: >
        Build pre-compiled cache artifacts from all concept specs and sync
        rules for faster startup and deployment.
      companion-docs:
        - path: examples/build-for-production.md
          label: "Production build walkthrough"
          content: |
            # Walkthrough: Building for Production

            This walkthrough shows how to build a production-ready
            cache from your concept specs and syncs.

            ## Step 1: Validate Everything

            ```bash
            copf check           # Validate all specs
            copf compile-syncs   # Validate all syncs
            ```

            ## Step 2: Build the Cache

            ```bash
            copf compile --cache --verbose
            ```

            ```
            Building cache...
            [cache] user.concept → manifests/user.manifest.json (new)
            [cache] article.concept → manifests/article.manifest.json (new)
            [cache] create-profile.sync → syncs/create-profile.compiled.js (new)
            [cache] types → types/user.d.ts, types/article.d.ts (new)
            Cache built: 4 manifests, 2 syncs, 4 type files
            ```

            ## Step 3: Deploy

            Include `.copf-cache/` in your deployment:

            ```dockerfile
            COPY .copf-cache/ /app/.copf-cache/
            ```

            The runtime loads pre-compiled artifacts on startup,
            skipping the parse/compile step entirely.
    compile:
      examples:
        - label: "Build cache"
          language: bash
          code: "copf compile --cache"
        - label: "Build cache with verbose output"
          language: bash
          code: "copf compile --cache --verbose"

  KitManager:
    concept:
      tool-permissions: [Read, Grep, Glob, Edit, Write, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when creating, validating, testing, or managing concept kits.
        Covers the full kit lifecycle from scaffolding to publishing.
      intro-template: >
        Manage kit **$ARGUMENTS** — scaffold, validate, test, and publish
        reusable concept packages.
      companion-docs:
        - path: examples/create-a-kit.md
          label: "Kit creation walkthrough"
          content: |
            # Walkthrough: Creating a Kit

            This walkthrough shows how to create, validate, and test
            a reusable concept kit.

            ## Step 1: Scaffold

            ```bash
            copf kit init auth-kit
            ```

            Creates:
            ```
            auth-kit/
            ├── kit.yaml
            ├── concepts/
            │   └── example.concept
            ├── syncs/
            └── tests/
            ```

            ## Step 2: Add Concepts

            Move your concept specs into `concepts/`:

            ```bash
            cp specs/user.concept auth-kit/concepts/
            cp specs/password.concept auth-kit/concepts/
            cp specs/session.concept auth-kit/concepts/
            ```

            ## Step 3: Update kit.yaml

            ```yaml
            kit:
              name: auth
              version: 1.0.0
              description: Authentication and identity management

            concepts:
              - concepts/user.concept
              - concepts/password.concept
              - concepts/session.concept

            syncs:
              required:
                - syncs/validate-session.sync
            ```

            ## Step 4: Validate and Test

            ```bash
            copf kit validate ./auth-kit
            copf kit test ./auth-kit
            ```
      example-walkthroughs:
        - path: examples/create-a-kit.md
          label: "Create a reusable kit (auth example)"
    init:
      examples:
        - label: "Create a new kit"
          language: bash
          code: "copf kit init my-kit"
    validate:
      examples:
        - label: "Validate a kit"
          language: bash
          code: "copf kit validate ./kits/my-kit"
    test:
      examples:
        - label: "Test a kit"
          language: bash
          code: "copf kit test ./kits/my-kit"
    list:
      examples:
        - label: "List active kits"
          language: bash
          code: "copf kit list"
    checkOverrides:
      examples:
        - label: "Check sync overrides"
          language: bash
          code: "copf kit check-overrides ./kits/my-kit"

  Emitter:
    concept:
      tool-permissions: [Read, Grep, Glob, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when writing generated files, auditing for drift, tracing
        source provenance, or cleaning orphaned outputs.
      intro-template: >
        Manage generated file output for **$ARGUMENTS** with content-addressed
        writes, source traceability, and drift detection.
    write:
      examples:
        - label: "Write a single file"
          language: typescript
          code: |
            const result = await emitterHandler.write(
              { path: 'generated/user.types.ts', content: typesCode, formatHint: 'typescript' },
              storage,
            );
    writeBatch:
      examples:
        - label: "Batch write generated files"
          language: typescript
          code: |
            const result = await emitterHandler.writeBatch(
              { files: [{ path: 'user.types.ts', content: types }, { path: 'user.handler.ts', content: handler }] },
              storage,
            );
    audit:
      examples:
        - label: "Audit generated directory"
          language: bash
          code: "copf emitter audit ./generated"
    trace:
      examples:
        - label: "Trace source provenance"
          language: bash
          code: "copf emitter trace ./generated/user.types.ts"
    affected:
      examples:
        - label: "Show impact of changing a source file"
          language: bash
          code: "copf emitter affected ./specs/app/user.concept"
    clean:
      examples:
        - label: "Remove orphaned files"
          language: bash
          code: "copf emitter clean ./generated"

  BuildCache:
    concept:
      tool-permissions: [Read, Grep, Glob, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when checking cache validity, recording generation results,
        or invalidating stale entries for incremental rebuilds.
      intro-template: >
        Manage incremental build cache for **$ARGUMENTS** with hash-based
        invalidation and per-step granularity.
    check:
      examples:
        - label: "Check if step is cached"
          language: typescript
          code: |
            const result = await buildCacheHandler.check(
              { stepKey: 'framework:TypeScriptGen:article', inputHash: hash, deterministic: true },
              storage,
            );
            if (result.variant === 'unchanged') { /* skip generation */ }
    status:
      examples:
        - label: "Show cache status"
          language: bash
          code: "copf build-cache status"
    staleSteps:
      examples:
        - label: "List stale cache entries"
          language: bash
          code: "copf build-cache stale-steps"

  Resource:
    concept:
      tool-permissions: [Read, Grep, Glob, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when tracking input files, detecting changes, or querying
        which resources are currently registered.
      intro-template: >
        Track input resources for **$ARGUMENTS** with content-addressed
        digests and change classification.
    upsert:
      examples:
        - label: "Track a concept spec file"
          language: typescript
          code: |
            const result = await resourceHandler.upsert(
              { locator: 'specs/app/article.concept', kind: 'concept-spec', digest: contentHash },
              storage,
            );
    list:
      examples:
        - label: "List all tracked resources"
          language: bash
          code: "copf resource list"
        - label: "List only concept specs"
          language: bash
          code: "copf resource list --kind concept-spec"

  KindSystem:
    concept:
      tool-permissions: [Read, Grep, Glob, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when inspecting the IR kind taxonomy, finding transform paths
        between kinds, or querying which generators consume or produce a kind.
      intro-template: >
        Inspect the generation pipeline topology for **$ARGUMENTS** showing
        IR kinds, transform edges, and routing paths.
    graph:
      examples:
        - label: "Show full kind graph"
          language: bash
          code: "copf kind-system graph"
    route:
      examples:
        - label: "Find path from source to artifact"
          language: bash
          code: "copf kind-system route --from ConceptDSL --to TypeScriptFiles"
    consumers:
      examples:
        - label: "What consumes ConceptManifest?"
          language: bash
          code: "copf kind-system consumers --kind ConceptManifest"
    producers:
      examples:
        - label: "What produces TypeScriptFiles?"
          language: bash
          code: "copf kind-system producers --kind TypeScriptFiles"

  GenerationPlan:
    concept:
      tool-permissions: [Read, Grep, Glob, Bash]
      argument-template: "$ARGUMENTS"
      trigger-description: >
        Use when checking the status of a generation run, viewing run
        summaries, or browsing generation history.
      intro-template: >
        View generation run tracking for **$ARGUMENTS** with step-by-step
        status, aggregate summaries, and run history.
    status:
      examples:
        - label: "Show current run status"
          language: bash
          code: "copf generation-plan status"
    summary:
      examples:
        - label: "Show run summary"
          language: bash
          code: "copf generation-plan summary"
    history:
      examples:
        - label: "Show last 5 runs"
          language: bash
          code: "copf generation-plan history --limit 5"

# ─── PER-CONCEPT CLI OVERRIDES ──────────────────────
# CLI-specific: positional args, custom command names.

concept-overrides:
  SpecParser:
    cli:
      actions:
        parse:
          command: check
          params:
            source:
              positional: true

  ProjectScaffold:
    cli:
      actions:
        scaffold:
          command: init
          params:
            name:
              positional: true

  KitManager:
    cli:
      actions:
        init:
          params:
            name:
              positional: true
        validate:
          params:
            path:
              positional: true
        test:
          params:
            path:
              positional: true

  Emitter:
    cli:
      command-group: emitter
      description: "Manage generated file output, traceability, and drift detection."
      actions:
        write:
          description: "Write a single generated file"
          args:
            path:
              positional: true
          flags:
            content:
              type: string
              required: true
              description: "File content to write"
            formatHint:
              type: string
              required: false
              short: f
              description: "Formatter to apply (e.g., prettier, rustfmt)"
        writeBatch:
          command: write-batch
          description: "Atomically write a batch of generated files"
        format:
          description: "Format a generated file"
          args:
            path:
              positional: true
        clean:
          description: "Remove orphaned generated files"
          args:
            outputDir:
              positional: true
          flags:
            currentManifest:
              type: string
              required: false
              description: "Path to current manifest listing expected files"
          examples:
            - description: "Clean generated directory"
              command: "copf emitter clean ./generated"
        manifest:
          description: "List all tracked output files"
          args:
            outputDir:
              positional: true
          examples:
            - description: "List outputs in generated/"
              command: "copf emitter manifest ./generated"
        trace:
          description: "Show which sources produced an output file"
          args:
            outputPath:
              positional: true
          examples:
            - description: "Trace provenance of a generated file"
              command: "copf emitter trace ./generated/user.types.ts"
        affected:
          description: "Show what outputs change if a source changes"
          args:
            sourcePath:
              positional: true
          examples:
            - description: "Impact analysis for a concept spec"
              command: "copf emitter affected ./specs/app/user.concept"
        audit:
          description: "Check generated files for drift from expected output"
          args:
            outputDir:
              positional: true
          examples:
            - description: "Audit generated directory"
              command: "copf emitter audit ./generated"

  BuildCache:
    cli:
      command-group: build-cache
      description: "Manage incremental build cache for generation pipeline."
      actions:
        check:
          description: "Check if a generation step is cached"
          flags:
            stepKey:
              type: string
              required: true
              short: k
              description: "Unique step identifier (generator:concept)"
            inputHash:
              type: string
              required: true
              description: "Hash of current input"
            deterministic:
              type: boolean
              required: false
              description: "Whether generator is deterministic"
        record:
          description: "Record a generation result in the cache"
        invalidate:
          description: "Invalidate a single cache entry"
          flags:
            stepKey:
              type: string
              required: true
              short: k
              description: "Step key to invalidate"
        invalidateBySource:
          command: invalidate-by-source
          description: "Invalidate all steps that used a source file"
          args:
            sourceLocator:
              positional: true
          examples:
            - description: "Invalidate after concept change"
              command: "copf build-cache invalidate-by-source specs/app/article.concept"
        invalidateByKind:
          command: invalidate-by-kind
          description: "Invalidate all steps producing a given IR kind"
          args:
            kindName:
              positional: true
          examples:
            - description: "Invalidate all TypeScript generation"
              command: "copf build-cache invalidate-by-kind TypeScriptFiles"
        invalidateAll:
          command: invalidate-all
          description: "Clear the entire build cache"
          examples:
            - description: "Full cache reset"
              command: "copf build-cache invalidate-all"
        status:
          description: "Show all cache entries with staleness indicators"
          examples:
            - description: "View cache status"
              command: "copf build-cache status"
        staleSteps:
          command: stale-steps
          description: "List step keys that need regeneration"
          examples:
            - description: "Find stale entries"
              command: "copf build-cache stale-steps"

  Resource:
    cli:
      command-group: resource
      description: "Track input resources with content-addressed digests."
      actions:
        upsert:
          description: "Register or update a tracked input resource"
          args:
            locator:
              positional: true
          flags:
            kind:
              type: string
              required: true
              short: k
              description: "Resource kind (concept-spec, sync-spec, etc.)"
            digest:
              type: string
              required: true
              description: "Content hash of the resource"
        get:
          description: "Look up a tracked resource"
          args:
            locator:
              positional: true
        list:
          description: "List all tracked input resources"
          flags:
            kind:
              type: string
              required: false
              short: k
              description: "Filter by resource kind"
          examples:
            - description: "List all tracked resources"
              command: "copf resource list"
            - description: "List only concept specs"
              command: "copf resource list --kind concept-spec"
        remove:
          description: "Stop tracking a resource"
          args:
            locator:
              positional: true
        diff:
          description: "Classify a content change between two digests"
          args:
            locator:
              positional: true

  KindSystem:
    cli:
      command-group: kind-system
      description: "Inspect the IR kind taxonomy and pipeline topology."
      actions:
        define:
          description: "Register a new IR kind"
          args:
            name:
              positional: true
          flags:
            category:
              type: string
              required: true
              short: c
              description: "Kind category (source, model, artifact)"
              choices: [source, model, artifact]
        connect:
          description: "Declare a transform edge between two kinds"
          flags:
            from:
              type: string
              required: true
              description: "Source kind"
            to:
              type: string
              required: true
              description: "Target kind"
            relation:
              type: string
              required: true
              description: "Transform relation (normalizes_to, compiles_to, etc.)"
            transformName:
              type: string
              required: false
              short: t
              description: "Name of the transform/generator"
        route:
          description: "Find shortest transform path between two kinds"
          flags:
            from:
              type: string
              required: true
              description: "Source kind"
            to:
              type: string
              required: true
              description: "Target kind"
          examples:
            - description: "Route from source to TypeScript"
              command: "copf kind-system route --from ConceptDSL --to TypeScriptFiles"
        validate:
          description: "Validate a transform edge"
        dependents:
          description: "List all downstream kinds from a given kind"
          args:
            kind:
              positional: true
          examples:
            - description: "What depends on ConceptManifest?"
              command: "copf kind-system dependents ConceptManifest"
        producers:
          description: "Show what transforms produce a given kind"
          args:
            kind:
              positional: true
          examples:
            - description: "What produces TypeScriptFiles?"
              command: "copf kind-system producers TypeScriptFiles"
        consumers:
          description: "Show what transforms consume a given kind"
          args:
            kind:
              positional: true
          examples:
            - description: "What consumes ConceptManifest?"
              command: "copf kind-system consumers ConceptManifest"
        graph:
          description: "Show the full kind taxonomy graph"
          examples:
            - description: "Display kind graph"
              command: "copf kind-system graph"

  GenerationPlan:
    cli:
      command-group: generation-plan
      description: "Track and inspect generation runs."
      actions:
        begin:
          description: "Mark a new generation run as started"
        recordStep:
          command: record-step
          description: "Record a step outcome in the current run"
          flags:
            stepKey:
              type: string
              required: true
              short: k
              description: "Step identifier"
            status:
              type: string
              required: true
              description: "Step outcome (done, cached, failed)"
            cached:
              type: boolean
              required: false
              description: "Whether the step was a cache hit"
        complete:
          description: "Mark the current generation run as finished"
        status:
          description: "Show step-by-step status of a generation run"
          examples:
            - description: "Show current run status"
              command: "copf generation-plan status"
        summary:
          description: "Show aggregate statistics for a generation run"
          examples:
            - description: "Show run summary"
              command: "copf generation-plan summary"
        history:
          description: "Show recent generation runs"
          flags:
            limit:
              type: string
              required: false
              short: n
              description: "Maximum number of runs to show"
              default: "10"
          examples:
            - description: "Show last 5 runs"
              command: "copf generation-plan history --limit 5"
            - description: "Show last 10 runs"
              command: "copf generation-plan history"
