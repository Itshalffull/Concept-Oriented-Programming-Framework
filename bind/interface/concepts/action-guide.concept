@version(3)
concept ActionGuide [W] {

  purpose {
    Organize concept actions into ordered, annotated workflow
    sequences for interface targets. The concept owns step
    ordering (structural) and opaque content passthrough for
    decorations. Each target reads the content keys it
    understands (checklists, design-principles, anti-patterns,
    validation-commands, etc.) and ignores the rest. New
    decoration kinds require only a new YAML key and a
    renderer in the target provider — zero concept changes.
    Renamed from Workflow to avoid collision with
    kits/automation/workflow.concept (FSM with guarded transitions).
    See Architecture doc Section 1.8.
  }

  state {
    workflows: set W
    config {
      concept: W -> String
      steps: W -> list { action: String, title: String, prose: String, order: Int }
    }
    content: W -> String
  }

  actions {
    action define(concept: String, steps: list String, content: String) {
      description {
        Create an action guide from a concept's actions. Steps are
        ordered action names with titles and prose — the concept
        owns this structure. The content string is JSON from the
        interface manifest containing decorations whose internal
        structure is not constrained by this concept. Targets
        interpret keys they recognize (e.g. checklists,
        references, examples, anti-patterns, design-principles,
        content-sections, validation-commands, quick-reference,
        related-workflows) and pass through the rest.
      }
      -> ok(workflow: W, stepCount: Int) {
        Action guide created with ordered steps. Content JSON
        attached as opaque decoration.
      }
      -> invalidAction(action: String) {
        A step references an action not found in the concept.
      }
      -> emptySteps() {
        No steps were provided.
      }
    }

    action render(workflow: W, format: String) {
      description {
        Render an action guide in the requested format. Supported formats
        include skill-md, cli-help, rest-guide, and generic. Each
        format produces output suited to its target audience.
        The renderer deserializes the content JSON and picks out
        keys it understands for the given format.
      }
      -> ok(content: String) {
        Rendered action guide content in the requested format.
      }
      -> unknownFormat(format: String) {
        The requested format is not recognized.
      }
    }
  }

  invariant {
    after define(concept: "SpecParser", steps: ["parse"],
      content: "{\"design-principles\":[{\"title\":\"Independence\",\"rule\":\"Parse without external state\"}]}")
      -> ok(workflow: w, stepCount: 1)
    then render(workflow: w, format: "skill-md") -> ok(content: c)
  }
}
