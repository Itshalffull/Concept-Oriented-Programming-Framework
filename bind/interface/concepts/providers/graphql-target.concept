@version(2)
concept GraphqlTarget [Q] {

  purpose {
    Generate GraphQL schema and resolvers from concept projections.
    Owns query/mutation/subscription classification, connection
    type generation (Relay spec), input/output type mapping,
    DataLoader integration, and recursive type generation. When
    @hierarchical trait is present, generates self-referential
    types with children, parent, ancestors, and depth fields.
    Enrichment content from Projection is passed through for
    schema documentation and directive generation.
    See Architecture doc Section 2.2.
  }

  state {
    types: set Q
    config {
      relay: Q -> Bool
      federation: Q -> Bool
      subscriptions: Q -> Bool
    }
    mapping {
      concept: Q -> String
      action: Q -> String
      operationType: Q -> String
      typeName: Q -> String
    }
    hierarchical {
      selfRef: Q -> Bool
      childrenField: Q -> option String
      parentField: Q -> option String
      ancestorsField: Q -> option String
      depthField: Q -> option String
    }
    content: Q -> String
  }

  actions {
    action generate(projection: String, config: String) {
      -> ok(types: list String, files: list String) {
        GraphQL schema and resolver stubs generated from
        projection. Actions classified as queries, mutations,
        or subscriptions based on action semantics and
        annotation overrides. When @hierarchical trait is
        detected, generates recursive object type with
        children (with Connection type if @paginated),
        parent (nullable), ancestors (ordered list), and
        depth (Int) fields. Resolver stubs include tree
        traversal delegating to the kernel.
      }
      -> federationConflict(type: String, reason: String) {
        Type cannot be federated due to conflicting key
        directives or ownership boundaries across subgraphs.
      }
    }

    action validate(type: Q) {
      -> ok(type: Q) {
        Generated schema is valid GraphQL. Resolver signatures
        match schema field types. Relay connection types conform
        to the Relay spec if enabled. Recursive types have no
        unbounded nesting.
      }
      -> cyclicType(type: Q, cycle: list String) {
        Type graph contains a cycle that would cause infinite
        nesting in the schema.
      }
    }

    action listOperations(concept: String) {
      -> ok(queries: list String, mutations: list String, subscriptions: list String) {
        Return all generated operations for a concept grouped
        by operation type, including hierarchy traversal queries.
      }
    }
  }

  invariant {
    after generate(projection: "order-projection", config: "{}") -> ok(types: t, files: f)
    then listOperations(concept: "Order") -> ok(queries: q, mutations: m, subscriptions: s)
  }
}
