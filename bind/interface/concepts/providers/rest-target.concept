@version(2)
concept RestTarget [R] {

  purpose {
    Generate REST API code from concept projections. Owns HTTP
    method mappings, URL pattern derivation, status code tables,
    request/response serialization, middleware integration, and
    hierarchical resource nesting. When @hierarchical trait is
    present, generates children/ancestors/descendants endpoints.
    Enrichment content from Projection is passed through as
    opaque JSON for middleware and documentation generation.
    See Architecture doc Section 2.1.
  }

  state {
    routes: set R
    config {
      basePath: R -> String
      framework: R -> String
      versioning: R -> option String
    }
    mapping {
      concept: R -> String
      action: R -> String
      method: R -> String
      path: R -> String
      statusCodes: R -> list { code: Int, meaning: String }
    }
    hierarchical {
      parentRoute: R -> option String
      childrenRoute: R -> option String
      ancestorsRoute: R -> option String
      descendantsRoute: R -> option String
    }
    content: R -> String
  }

  actions {
    action generate(projection: String, config: String) {
      -> ok(routes: list String, files: list String) {
        REST routes and type definitions generated from
        projection. HTTP methods derived from action semantics.
        Status code tables attached per route. When @hierarchical
        trait is detected, additional routes are generated:
        GET /{resource}/{id}/children (list direct children),
        POST /{resource}/{id}/children (create child under parent),
        GET /{resource}/{id}/ancestors (path to root),
        GET /{resource}/{id}/descendants?depth=N (subtree query).
        Enrichment content is read from projection for API
        documentation generation.
      }
      -> ambiguousMapping(action: String, reason: String) {
        Action cannot be unambiguously mapped to an HTTP method
        and path. Manual annotation required in the interface
        manifest.
      }
    }

    action validate(route: R) {
      -> ok(route: R) {
        Route handler compiles. Request and response types
        are consistent with concept state and action signatures.
        Hierarchical routes have no path conflicts.
      }
      -> pathConflict(route: R, conflicting: String, reason: String) {
        Two actions map to the same HTTP method and path.
      }
    }

    action listRoutes(concept: String) {
      -> ok(routes: list String, methods: list String) {
        Return all generated routes for a concept with their
        HTTP methods, including hierarchical routes if present.
      }
    }
  }

  invariant {
    after generate(projection: "user-projection", config: "{}") -> ok(routes: r, files: f)
    then listRoutes(concept: "User") -> ok(routes: lr, methods: m)
  }
}
