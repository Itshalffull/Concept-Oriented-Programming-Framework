// Auto-generated by COPF Interface Kit â€” cli target
// Concept: BuildCache
// Do not edit manually; regenerate with: copf interface generate

import { Command } from 'commander';

export const buildCacheCommand = new Command('build-cache')
  .description('Track input output hashes for generation steps 
 Enable incremental rebuilds : skip generation when 
 inputs haven t changed since the last successful run 
 Support cascading invalidation when upstream kinds change');

buildCacheCommand
  .command('check')
  .description('The input hash matches the stored hash for this step key , 
 AND the transform is deterministic ( so same input guarantees 
 same output ) The generator can skip execution 
 Returns outputRef if available the caller can load the 
 cached output directly from copf cache without re running 
 If deterministic is false , this variant is never returned 
 nondeterministic transforms always re run')
  .requiredOption('--step-key <stepKey>', 'Step Key')
  .requiredOption('--input-hash <inputHash>', 'Input Hash')
  .requiredOption('--deterministic <deterministic>', 'Deterministic')
  .option('--json', 'Output as JSON')
  .action(async (opts) => {
    const result = await globalThis.kernel.handleRequest({ method: 'check', ...opts });
    console.log(opts.json ? JSON.stringify(result) : result);
  });

buildCacheCommand
  .command('record')
  .description('Record a successful generation Store input hash , output hash , 
 timestamp , optional output reference path , and the source 
 locator that produced this step s input 
 outputRef points to the cached output in copf cache so 
 future cache hits can retrieve the output without re running 
 sourceLocator tracks which Resource produced this step s input , 
 enabling Resource BuildCache invalidation chains')
  .requiredOption('--step-key <stepKey>', 'Step Key')
  .requiredOption('--input-hash <inputHash>', 'Input Hash')
  .requiredOption('--output-hash <outputHash>', 'Output Hash')
  .requiredOption('--output-ref <outputRef>', 'Output Ref')
  .requiredOption('--source-locator <sourceLocator>', 'Source Locator')
  .requiredOption('--deterministic <deterministic>', 'Deterministic')
  .option('--json', 'Output as JSON')
  .action(async (opts) => {
    const result = await globalThis.kernel.handleRequest({ method: 'record', ...opts });
    console.log(opts.json ? JSON.stringify(result) : result);
  });

buildCacheCommand
  .command('invalidate')
  .description('Force a step to re run next time by clearing its entry')
  .requiredOption('--step-key <stepKey>', 'Step Key')
  .option('--json', 'Output as JSON')
  .action(async (opts) => {
    const result = await globalThis.kernel.handleRequest({ method: 'invalidate', ...opts });
    console.log(opts.json ? JSON.stringify(result) : result);
  });

buildCacheCommand
  .command('invalidate-by-source')
  .description('Invalidate all cache entries whose sourceLocator matches 
 Used when Resource upsert reports a changed source 
 all steps derived from that source are invalidated 
 Returns list of invalidated step keys')
  .requiredOption('--source-locator <sourceLocator>', 'Source Locator')
  .option('--json', 'Output as JSON')
  .action(async (opts) => {
    const result = await globalThis.kernel.handleRequest({ method: 'invalidateBySource', ...opts });
    console.log(opts.json ? JSON.stringify(result) : result);
  });

buildCacheCommand
  .command('invalidate-by-kind')
  .description('Invalidate all cache entries whose step key contains 
 generators that produce the given kind Used for cascading : 
 KindSystem dependents returns affected kinds , then 
 BuildCache invalidates all steps producing those kinds 
 Returns list of invalidated step keys')
  .requiredOption('--kind-name <kindName>', 'Kind Name')
  .option('--json', 'Output as JSON')
  .action(async (opts) => {
    const result = await globalThis.kernel.handleRequest({ method: 'invalidateByKind', ...opts });
    console.log(opts.json ? JSON.stringify(result) : result);
  });

buildCacheCommand
  .command('invalidate-all')
  .description('Clear all cache entries Full rebuild on next run')
  .option('--json', 'Output as JSON')
  .action(async (opts) => {
    const result = await globalThis.kernel.handleRequest({ method: 'invalidateAll', ...opts });
    console.log(opts.json ? JSON.stringify(result) : result);
  });

buildCacheCommand
  .command('status')
  .description('Return current cache status for all entries 
 An entry is stale if it has been invalidated since lastRun')
  .option('--json', 'Output as JSON')
  .action(async (opts) => {
    const result = await globalThis.kernel.handleRequest({ method: 'status', ...opts });
    console.log(opts.json ? JSON.stringify(result) : result);
  });

buildCacheCommand
  .command('stale-steps')
  .description('Return step keys for all stale entries entries that 
 have been invalidated and need re running 
 Used by GenerationPlan plan for planning display')
  .option('--json', 'Output as JSON')
  .action(async (opts) => {
    const result = await globalThis.kernel.handleRequest({ method: 'staleSteps', ...opts });
    console.log(opts.json ? JSON.stringify(result) : result);
  });

export const buildCacheCommandTree = {
  group: 'build-cache',
  description: 'Track input output hashes for generation steps 
 Enable incremental rebuilds : skip generation when 
 inputs haven t changed since the last successful run 
 Support cascading invalidation when upstream kinds change',
  commands: [{ action: 'check', command: 'check' }, { action: 'record', command: 'record' }, { action: 'invalidate', command: 'invalidate' }, { action: 'invalidateBySource', command: 'invalidate-by-source' }, { action: 'invalidateByKind', command: 'invalidate-by-kind' }, { action: 'invalidateAll', command: 'invalidate-all' }, { action: 'status', command: 'status' }, { action: 'staleSteps', command: 'stale-steps' }],
};
