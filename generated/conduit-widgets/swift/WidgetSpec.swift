// =============================================================================
// Conduit App Widget Specification Types (Swift)
//
// Clef Surface-driven widget abstraction: each Conduit widget is described as a
// WidgetSpec that declares its concept bindings, element tree, anatomy,
// state machine, and accessibility contract. This spec is framework-agnostic --
// the same WidgetSpec renders via SwiftUI, UIKit, or AppKit through the Clef Surface
// FrameworkAdapter pipeline.
//
// Architecture:
//   ConceptSpec -> UISchema.inspect() -> ElementTree
//   ElementTree + MachineSpec + Anatomy + A11ySpec = WidgetSpec
//   WidgetSpec  -> FrameworkAdapter.normalize() -> rendered component
// =============================================================================

import Foundation

// MARK: - Element Kinds

/// Abstract interaction units from the Clef Surface Element concept.
enum ElementKind: String, Codable {
    case inputText = "input-text"
    case inputNumber = "input-number"
    case inputDate = "input-date"
    case inputBool = "input-bool"
    case selectionSingle = "selection-single"
    case selectionMulti = "selection-multi"
    case trigger
    case navigation
    case outputText = "output-text"
    case outputNumber = "output-number"
    case outputDate = "output-date"
    case outputBool = "output-bool"
    case group
    case container
    case richText = "rich-text"
    case fileUpload = "file-upload"
    case mediaDisplay = "media-display"
}

// MARK: - Element Constraints

/// Validation constraints applied to an element.
struct ElementConstraints: Codable {
    let min: Double?
    let max: Double?
    let minLength: Int?
    let maxLength: Int?
    let pattern: String?
    let options: [SelectionOption]?

    init(
        min: Double? = nil,
        max: Double? = nil,
        minLength: Int? = nil,
        maxLength: Int? = nil,
        pattern: String? = nil,
        options: [SelectionOption]? = nil
    ) {
        self.min = min
        self.max = max
        self.minLength = minLength
        self.maxLength = maxLength
        self.pattern = pattern
        self.options = options
    }
}

/// A single option within a selection element.
struct SelectionOption: Codable {
    let value: String
    let label: String
}

// MARK: - Element Tree

/// A node in the abstract UI structure generated by UISchema.inspect().
struct ElementNode: Codable {
    let id: String
    let kind: ElementKind
    let label: String
    let dataType: String
    let required: Bool
    let scope: String
    let constraints: ElementConstraints?
    let children: [ElementNode]?

    init(
        id: String,
        kind: ElementKind,
        label: String,
        dataType: String,
        required: Bool,
        scope: String,
        constraints: ElementConstraints? = nil,
        children: [ElementNode]? = nil
    ) {
        self.id = id
        self.kind = kind
        self.label = label
        self.dataType = dataType
        self.required = required
        self.scope = scope
        self.constraints = constraints
        self.children = children
    }
}

// MARK: - Concept Binding

/// Declares which concept actions and state a widget connects to.
struct ConceptBinding: Codable {
    let concept: String
    let actions: [String]
    let queries: [String]
}

// MARK: - Anatomy

/// Named parts contract from the Clef Surface Anatomy concept.
struct AnatomySpec: Codable {
    let component: String
    let parts: [String]
    let slots: [String]
}

// MARK: - State Machine

/// A single transition within a state machine.
struct MachineTransition: Codable {
    let target: String
    let `guard`: String?
    let action: String?

    init(target: String, guard: String? = nil, action: String? = nil) {
        self.target = target
        self.guard = `guard`
        self.action = action
    }

    enum CodingKeys: String, CodingKey {
        case target
        case `guard`
        case action
    }
}

/// A single state within the state machine.
struct MachineState: Codable {
    let name: String
    let on: [String: MachineTransition]
}

/// The headless state machine specification from Clef Surface Widget/Machine.
struct MachineSpec: Codable {
    let initial: String
    let states: [String: MachineState]
    let context: [String: String]
}

// MARK: - Accessibility

/// ARIA and keyboard interaction contract from Clef Surface Widget a11ySpec.
struct A11ySpec: Codable {
    let role: String
    let label: String
    let description: String?
    let keyboard: [String: String]
    let liveRegions: [String]?

    init(
        role: String,
        label: String,
        description: String? = nil,
        keyboard: [String: String],
        liveRegions: [String]? = nil
    ) {
        self.role = role
        self.label = label
        self.description = description
        self.keyboard = keyboard
        self.liveRegions = liveRegions
    }
}

// MARK: - Widget Category

/// High-level classification of the widget's purpose.
enum WidgetCategory: String, Codable {
    case form
    case display
    case composite
    case navigation
}

// MARK: - Widget Spec

/// The complete, framework-agnostic widget definition.
struct WidgetSpec: Codable {
    let name: String
    let version: String
    let category: WidgetCategory
    let concepts: [ConceptBinding]
    let anatomy: AnatomySpec
    let elements: [ElementNode]
    let machine: MachineSpec
    let a11y: A11ySpec
}
