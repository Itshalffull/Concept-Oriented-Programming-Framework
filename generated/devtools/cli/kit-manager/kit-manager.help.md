<!-- Auto-generated by Clef Clef Bind — cli target -->
<!-- Concept: KitManager -->
<!-- Do not edit manually; regenerate with: clef interface generate -->

# clef suite-manager — Help

Manage kit **<source>** — scaffold, validate, test, and publish reusable concept packages.


> **When to use:** Use when creating, validating, testing, or managing suites. Covers the full kit lifecycle from scaffolding to publishing.


## Design Principles

- **Kit as Reusable Unit:** A suite bundles related concepts and syncs into a single distributable package — like an npm package for Clef.
- **Cross-Kit Isolation:** Concepts in one kit never reference concepts in another suite directly — cross-suite integration happens through syncs and type parameter alignment.
- **Required vs Recommended Syncs:** Kit syncs are tiered: required syncs are load-bearing, recommended syncs provide useful defaults, integration syncs wire to other suites.
**init:**
- [ ] Kit name follows naming convention?
- [ ] Kit.yaml has required fields (name, version, description)?
- [ ] Example concept spec is valid?

**validate:**
- [ ] All concept specs parse successfully?
- [ ] All sync files compile?
- [ ] Cross-suite references resolve?
- [ ] Type parameters align across concepts?

**test:**
- [ ] Conformance tests pass?
- [ ] Integration tests pass?
- [ ] No failing assertions?

**checkOverrides:**
- [ ] Override references valid syncs?
- [ ] Override parameters match original sync signature?
## References

- [Kit manifest and directory structure](references/kit-structure.md)
- [Publishing and versioning kits](references/kit-publishing.md)
## Supporting Materials

- [Kit creation walkthrough](examples/create-a-kit.md)
## Quick Reference

| Action | Command | Purpose |
|--------|---------|---------|
| init | `clef suite init <name>` | Scaffold a new suite |
| validate | `clef suite validate <path>` | Validate suite manifest |
| test | `clef suite test <path>` | Run suite tests |
| list | `clef suite list` | List active suites |
| checkOverrides | `clef suite check-overrides <path>` | Verify sync overrides |


## Example Walkthroughs

For complete examples with design rationale:

- [Create a reusable suite (auth example)](examples/create-a-kit.md)
## Anti-Patterns

### Cross-suite concept reference
Kit A's concept imports Kit B's types directly instead of using type parameters.

**Bad:**
```
# In kit-a/concepts/order.concept
concept Order [O] {
  state { customer: O -> kit_b.User }  # Direct reference!
}

```

**Good:**
```
# In kit-a/concepts/order.concept
concept Order [O, U] {
  state { customer: O -> U }  # Type parameter, wired by sync
}

```

### Monolithic kit
Kit bundles unrelated concepts — violates the reusable unit principle.

**Bad:**
```
# suite.yaml
kit: { name: everything }
concepts: [User, Article, Payment, Analytics, Email, Notification]

```

**Good:**
```
# Split into focused kits
kit: { name: content }   # concepts: [Article, Tag, Comment]
kit: { name: commerce }  # concepts: [Payment, Invoice, Refund]

```
## Validation

*Validate a suite:*
```bash
npx tsx cli/src/index.ts suite validate ./kits/my-kit
```
*Run suite tests:*
```bash
npx tsx cli/src/index.ts suite test ./kits/my-kit
```
*List active suites:*
```bash
npx tsx cli/src/index.ts suite list
```
## Related Skills

- /concept-designer — Design concepts to include in the suite
- /sync-designer — Write syncs that wire kit concepts together
- /deployment-config — Deploy suites to production runtimes
