<!-- Auto-generated by COPF Interface Kit — claude-skills target -->
<!-- Concept: TransportAdapterScaffoldGen -->
<!-- Do not edit manually; regenerate with: clef interface generate -->
# Transport Adapter Guide

How to implement transport adapters for different protocols.

## Transport Interface

```typescript
interface ConceptTransport {
  invoke(concept: string, action: string,
         input: Record<string, unknown>): Promise<Record<string, unknown>>;
  query(concept: string, relation: string,
        criteria?: Record<string, unknown>): Promise<Record<string, unknown>[]>;
  health(): Promise<{ ok: boolean; latencyMs: number }>;
}
```

## Protocol Comparison

| Protocol | Bidirectional | Latency | Best For |
|----------|--------------|---------|----------|
| http | No | Medium | REST APIs, microservices |
| websocket | Yes | Low | Real-time, subscriptions |
| worker | No | Very Low | Same-machine parallelism |
| in-process | N/A | None | Testing, monoliths |

## HTTP Adapter

```typescript
async invoke(concept, action, input) {
  const url = `${this.baseUrl}/concepts/${concept}/${action}`;
  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(input),
  });
  return response.json();
}
```

## WebSocket Adapter

Uses request/response correlation with message IDs:
1. Send `{ id, concept, action, input }` as JSON
2. Receive `{ id, result }` — match by ID
3. Resolve the pending promise

## When to Use Each

- **Same runtime**: Use `in-process` — zero overhead
- **Same machine**: Use `worker` — parallel execution
- **Same network**: Use `http` — simple and reliable
- **Real-time**: Use `websocket` — bidirectional streaming
