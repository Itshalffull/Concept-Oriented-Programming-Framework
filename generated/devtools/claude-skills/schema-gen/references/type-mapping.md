<!-- Auto-generated by COPF Interface Kit â€” claude-skills target -->
<!-- Concept: SchemaGen -->
<!-- Do not edit manually; regenerate with: clef interface generate -->
# Spec-to-TypeScript Type Mapping

Rules for mapping concept spec types to TypeScript types in
generated manifests and handler interfaces.

## Primitive Types

| Spec Type | TypeScript Type | Notes |
|-----------|----------------|-------|
| `String` | `string` | |
| `Int` | `number` | Integer values |
| `Bool` | `boolean` | |
| `Float` | `number` | Floating point |

## Collection Types

| Spec Type | TypeScript Type | Notes |
|-----------|----------------|-------|
| `set T` | `Map<string, T>` | Primary collection keyed by ID |
| `list T` | `T[]` | Ordered array |
| `option T` | `T \| undefined` | Nullable/optional |

## Relation Types

| Spec Syntax | TypeScript Type | Meaning |
|-------------|----------------|---------|
| `T -> String` | `string` (required field) | Total function |
| `T -> option String` | `string \| undefined` | Partial function |
| `T -> list String` | `string[]` | Multi-valued |
| `T -> set U` | `Set<U>` | Set-valued |

## Type Parameters

Type parameters (`[T, U]`) become generic type arguments.
In generated code, they resolve to `string` (ID references)
unless a concrete type is provided by the sync wiring.

## Action Signatures

```
// Spec:
action create(name: String, count: Int) {
  -> ok(item: T) { ... }
}

// Generated TypeScript:
create(input: { name: string; count: number }, storage: Storage)
  : Promise<{ variant: 'ok'; item: string } | ...>
```
