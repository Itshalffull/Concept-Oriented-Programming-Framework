// RecursiveMerge â€” handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.
//
// Implements Git's recursive merge strategy. For criss-cross merge
// scenarios with multiple common ancestors, this strategy recursively
// merges the bases to produce a virtual common ancestor, then performs
// a standard three-way merge against that virtual base. Nested
// structures (JSON objects) are merged field-by-field recursively.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  RecursiveMergeStorage,
  RecursiveMergeRegisterInput,
  RecursiveMergeRegisterOutput,
  RecursiveMergeExecuteInput,
  RecursiveMergeExecuteOutput,
} from './types.js';

import {
  registerOk,
  executeClean,
  executeConflicts,
  executeUnsupportedContent,
} from './types.js';

export interface RecursiveMergeError {
  readonly code: string;
  readonly message: string;
}

export interface RecursiveMergeHandler {
  readonly register: (
    input: RecursiveMergeRegisterInput,
    storage: RecursiveMergeStorage,
  ) => TE.TaskEither<RecursiveMergeError, RecursiveMergeRegisterOutput>;
  readonly execute: (
    input: RecursiveMergeExecuteInput,
    storage: RecursiveMergeStorage,
  ) => TE.TaskEither<RecursiveMergeError, RecursiveMergeExecuteOutput>;
}

// --- Internal types ---

interface DiffHunk {
  readonly baseStart: number;
  readonly baseEnd: number;
  readonly lines: readonly string[];
}

type MergeRegion =
  | { readonly type: 'clean'; readonly lines: readonly string[] }
  | { readonly type: 'conflict'; readonly ours: readonly string[]; readonly theirs: readonly string[] };

// --- Pure helper functions ---

const splitLines = (buf: Buffer): readonly string[] =>
  buf.toString('utf-8').split('\n');

const joinLines = (lines: readonly string[]): Buffer =>
  Buffer.from(lines.join('\n'), 'utf-8');

/**
 * LCS table for two line arrays.
 */
const lcsTable = (
  a: readonly string[],
  b: readonly string[],
): readonly (readonly number[])[] => {
  const n = a.length;
  const m = b.length;
  const dp: number[][] = Array.from({ length: n + 1 }, () =>
    new Array<number>(m + 1).fill(0),
  );
  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= m; j++) {
      dp[i][j] = a[i - 1] === b[j - 1]
        ? dp[i - 1][j - 1] + 1
        : Math.max(dp[i - 1][j], dp[i][j - 1]);
    }
  }
  return dp;
};

/**
 * Extract diff hunks between base and modified.
 */
const extractHunks = (
  base: readonly string[],
  modified: readonly string[],
): readonly DiffHunk[] => {
  const dp = lcsTable(base, modified);
  const n = base.length;
  const m = modified.length;

  const matches: { readonly baseIdx: number; readonly modIdx: number }[] = [];
  let i = n;
  let j = m;
  while (i > 0 && j > 0) {
    if (base[i - 1] === modified[j - 1]) {
      matches.push({ baseIdx: i - 1, modIdx: j - 1 });
      i--;
      j--;
    } else if (dp[i - 1][j] >= dp[i][j - 1]) {
      i--;
    } else {
      j--;
    }
  }
  matches.reverse();

  const hunks: DiffHunk[] = [];
  let basePos = 0;
  let modPos = 0;

  for (const match of matches) {
    if (basePos < match.baseIdx || modPos < match.modIdx) {
      hunks.push({
        baseStart: basePos,
        baseEnd: match.baseIdx,
        lines: modified.slice(modPos, match.modIdx),
      });
    }
    basePos = match.baseIdx + 1;
    modPos = match.modIdx + 1;
  }

  if (basePos < n || modPos < m) {
    hunks.push({
      baseStart: basePos,
      baseEnd: n,
      lines: modified.slice(modPos, m),
    });
  }

  return hunks;
};

const hunksIdentical = (a: DiffHunk, b: DiffHunk): boolean =>
  a.baseStart === b.baseStart &&
  a.baseEnd === b.baseEnd &&
  a.lines.length === b.lines.length &&
  a.lines.every((line, idx) => line === b.lines[idx]);

/**
 * Three-way merge of line arrays, returning merge regions.
 */
const threeWayMergeLines = (
  base: readonly string[],
  ours: readonly string[],
  theirs: readonly string[],
): readonly MergeRegion[] => {
  const oursHunks = extractHunks(base, ours);
  const theirsHunks = extractHunks(base, theirs);

  type TaggedHunk = { readonly hunk: DiffHunk; readonly side: 'ours' | 'theirs' };
  const allHunks: TaggedHunk[] = [
    ...oursHunks.map(h => ({ hunk: h, side: 'ours' as const })),
    ...theirsHunks.map(h => ({ hunk: h, side: 'theirs' as const })),
  ].sort((a, b) => a.hunk.baseStart - b.hunk.baseStart || a.hunk.baseEnd - b.hunk.baseEnd);

  const regions: MergeRegion[] = [];
  let basePos = 0;
  let idx = 0;

  while (idx < allHunks.length) {
    const current = allHunks[idx];

    if (basePos < current.hunk.baseStart) {
      regions.push({ type: 'clean', lines: base.slice(basePos, current.hunk.baseStart) });
      basePos = current.hunk.baseStart;
    }

    let groupEnd = current.hunk.baseEnd;
    const groupHunks: TaggedHunk[] = [current];
    let next = idx + 1;
    while (next < allHunks.length && allHunks[next].hunk.baseStart < groupEnd) {
      groupHunks.push(allHunks[next]);
      groupEnd = Math.max(groupEnd, allHunks[next].hunk.baseEnd);
      next++;
    }

    const oursInGroup = groupHunks.filter(h => h.side === 'ours');
    const theirsInGroup = groupHunks.filter(h => h.side === 'theirs');

    if (oursInGroup.length === 0) {
      for (const th of theirsInGroup) {
        regions.push({ type: 'clean', lines: th.hunk.lines });
      }
    } else if (theirsInGroup.length === 0) {
      for (const oh of oursInGroup) {
        regions.push({ type: 'clean', lines: oh.hunk.lines });
      }
    } else {
      const allIdentical = oursInGroup.length === theirsInGroup.length &&
        oursInGroup.every((oh, i) => hunksIdentical(oh.hunk, theirsInGroup[i].hunk));

      if (allIdentical) {
        for (const oh of oursInGroup) {
          regions.push({ type: 'clean', lines: oh.hunk.lines });
        }
      } else {
        const oursLines = oursInGroup.flatMap(h => [...h.hunk.lines]);
        const theirsLines = theirsInGroup.flatMap(h => [...h.hunk.lines]);
        regions.push({ type: 'conflict', ours: oursLines, theirs: theirsLines });
      }
    }

    basePos = groupEnd;
    idx = next;
  }

  if (basePos < base.length) {
    regions.push({ type: 'clean', lines: base.slice(basePos) });
  }

  return regions;
};

/**
 * Attempt to merge two "base" versions into a virtual common ancestor.
 * This handles criss-cross merges by recursively merging the bases.
 * For our line-based implementation, this produces the best approximation
 * by taking the LCS of both bases.
 */
const mergeVirtualBase = (
  baseA: readonly string[],
  baseB: readonly string[],
  depth: number,
): readonly string[] => {
  if (depth > 8) {
    // Guard against infinite recursion; fall back to baseA
    return baseA;
  }

  // Use LCS to find common lines, filling gaps with lines from either side
  const dp = lcsTable(baseA, baseB);
  const n = baseA.length;
  const m = baseB.length;
  const result: string[] = [];
  let i = n;
  let j = m;

  const stack: string[] = [];
  while (i > 0 || j > 0) {
    if (i > 0 && j > 0 && baseA[i - 1] === baseB[j - 1]) {
      stack.push(baseA[i - 1]);
      i--;
      j--;
    } else if (i > 0 && j > 0 && dp[i - 1][j] >= dp[i][j - 1]) {
      // Line only in A: include it in the virtual base
      stack.push(baseA[i - 1]);
      i--;
    } else if (j > 0) {
      // Line only in B: include it in the virtual base
      stack.push(baseB[j - 1]);
      j--;
    } else {
      stack.push(baseA[i - 1]);
      i--;
    }
  }

  stack.reverse();
  return stack;
};

/**
 * Recursive merge: merge with support for multiple bases.
 * When the base itself has variants (criss-cross), recursively merge
 * the bases to produce a virtual ancestor before doing three-way merge.
 *
 * Additionally, for each conflict region, attempt to recursively merge
 * sub-lines to resolve inner conflicts that are structurally compatible.
 */
const recursiveMerge = (
  base: readonly string[],
  ours: readonly string[],
  theirs: readonly string[],
  depth: number,
): readonly MergeRegion[] => {
  if (depth > 10) {
    // Depth guard: treat entire content as conflict at extreme nesting
    return [{
      type: 'conflict',
      ours,
      theirs,
    }];
  }

  const regions = threeWayMergeLines(base, ours, theirs);

  // For each conflict region, try to recursively resolve by using
  // the base's corresponding region as a sub-base
  return regions.map(region => {
    if (region.type === 'clean') return region;

    // Try to find a sub-base from the original base for this conflict
    // and recursively merge at a finer granularity
    const subBase = mergeVirtualBase(region.ours, region.theirs, depth);
    const subRegions = threeWayMergeLines(subBase, region.ours, region.theirs);
    const subHasConflicts = subRegions.some(r => r.type === 'conflict');

    if (!subHasConflicts) {
      // Recursive merge resolved the conflict
      const resolved = subRegions.flatMap(r => {
        if (r.type === 'clean') return [...r.lines];
        return [];
      });
      return { type: 'clean' as const, lines: resolved };
    }

    // Could not resolve: return original conflict
    return region;
  });
};

const formatConflictRegion = (
  ours: readonly string[],
  theirs: readonly string[],
): string =>
  [
    '<<<<<<< ours',
    ...ours,
    '=======',
    ...theirs,
    '>>>>>>> theirs',
  ].join('\n');

// --- Implementation ---

export const recursiveMergeHandler: RecursiveMergeHandler = {
  register: (_input, _storage) =>
    TE.right(
      registerOk('recursive', 'merge', ['text/plain', 'text/*']),
    ),

  execute: (input, _storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const baseLines = splitLines(input.base);
          const oursLines = splitLines(input.ours);
          const theirsLines = splitLines(input.theirs);
          return { baseLines, oursLines, theirsLines };
        },
        (error): RecursiveMergeError => ({
          code: 'DECODE_ERROR',
          message: `Failed to decode input buffers: ${error instanceof Error ? error.message : String(error)}`,
        }),
      ),
      TE.map(({ baseLines, oursLines, theirsLines }) => {
        const regions = recursiveMerge(baseLines, oursLines, theirsLines, 0);
        const hasConflicts = regions.some(r => r.type === 'conflict');

        if (!hasConflicts) {
          const mergedLines = regions.flatMap(r => {
            if (r.type === 'clean') return [...r.lines];
            return [];
          });
          return executeClean(joinLines(mergedLines));
        }

        const conflictRegions: Buffer[] = regions
          .filter((r): r is Extract<MergeRegion, { readonly type: 'conflict' }> =>
            r.type === 'conflict',
          )
          .map(r => Buffer.from(formatConflictRegion(r.ours, r.theirs), 'utf-8'));

        return executeConflicts(conflictRegions);
      }),
    ),
};
