// Artifact â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as O from 'fp-ts/Option';

// Storage interface for Artifact
export interface ArtifactStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface ArtifactBuildInput {
  readonly concept: string;
  readonly spec: string;
  readonly implementation: string;
  readonly deps: readonly string[];
}

export interface ArtifactBuildOutputOk {
  readonly variant: 'ok';
  readonly artifact: string;
  readonly hash: string;
  readonly sizeBytes: number;
}

export interface ArtifactBuildOutputCompilationError {
  readonly variant: 'compilationError';
  readonly concept: string;
  readonly errors: readonly string[];
}

export type ArtifactBuildOutput = ArtifactBuildOutputOk | ArtifactBuildOutputCompilationError;

export interface ArtifactStoreInput {
  readonly hash: string;
  readonly location: string;
  readonly concept: string;
  readonly language: string;
  readonly platform: string;
  readonly metadata: O.Option<{ readonly toolchainVersion: string; readonly buildMode: string; readonly duration: number }>;
}

export interface ArtifactStoreOutputOk {
  readonly variant: 'ok';
  readonly artifact: string;
}

export interface ArtifactStoreOutputAlreadyExists {
  readonly variant: 'alreadyExists';
  readonly artifact: string;
}

export type ArtifactStoreOutput = ArtifactStoreOutputOk | ArtifactStoreOutputAlreadyExists;

export interface ArtifactResolveInput {
  readonly hash: string;
}

export interface ArtifactResolveOutputOk {
  readonly variant: 'ok';
  readonly artifact: string;
  readonly location: string;
}

export interface ArtifactResolveOutputNotfound {
  readonly variant: 'notfound';
  readonly hash: string;
}

export type ArtifactResolveOutput = ArtifactResolveOutputOk | ArtifactResolveOutputNotfound;

export interface ArtifactGcInput {
  readonly olderThan: Date;
  readonly keepVersions: number;
}

export interface ArtifactGcOutput {
  readonly variant: 'ok';
  readonly removed: number;
  readonly freedBytes: number;
}

// --- Variant constructors ---

export const buildOk = (artifact: string, hash: string, sizeBytes: number): ArtifactBuildOutput => ({ variant: 'ok', artifact, hash, sizeBytes } as ArtifactBuildOutput);
export const buildCompilationError = (concept: string, errors: readonly string[]): ArtifactBuildOutput => ({ variant: 'compilationError', concept, errors } as ArtifactBuildOutput);

export const storeOk = (artifact: string): ArtifactStoreOutput => ({ variant: 'ok', artifact } as ArtifactStoreOutput);
export const storeAlreadyExists = (artifact: string): ArtifactStoreOutput => ({ variant: 'alreadyExists', artifact } as ArtifactStoreOutput);

export const resolveOk = (artifact: string, location: string): ArtifactResolveOutput => ({ variant: 'ok', artifact, location } as ArtifactResolveOutput);
export const resolveNotfound = (hash: string): ArtifactResolveOutput => ({ variant: 'notfound', hash } as ArtifactResolveOutput);

export const gcOk = (removed: number, freedBytes: number): ArtifactGcOutput => ({ variant: 'ok', removed, freedBytes } as ArtifactGcOutput);

