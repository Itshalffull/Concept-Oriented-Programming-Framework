// TypeSystem â€” handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  TypeSystemStorage,
  TypeSystemRegisterTypeInput,
  TypeSystemRegisterTypeOutput,
  TypeSystemResolveInput,
  TypeSystemResolveOutput,
  TypeSystemNavigateInput,
  TypeSystemNavigateOutput,
  TypeSystemSerializeInput,
  TypeSystemSerializeOutput,
} from './types.js';

import {
  registerTypeOk,
  registerTypeExists,
  resolveOk,
  resolveNotfound,
  navigateOk,
  navigateNotfound,
  serializeOk,
  serializeNotfound,
} from './types.js';

export interface TypeSystemError {
  readonly code: string;
  readonly message: string;
}

export interface TypeSystemHandler {
  readonly registerType: (
    input: TypeSystemRegisterTypeInput,
    storage: TypeSystemStorage,
  ) => TE.TaskEither<TypeSystemError, TypeSystemRegisterTypeOutput>;
  readonly resolve: (
    input: TypeSystemResolveInput,
    storage: TypeSystemStorage,
  ) => TE.TaskEither<TypeSystemError, TypeSystemResolveOutput>;
  readonly navigate: (
    input: TypeSystemNavigateInput,
    storage: TypeSystemStorage,
  ) => TE.TaskEither<TypeSystemError, TypeSystemNavigateOutput>;
  readonly serialize: (
    input: TypeSystemSerializeInput,
    storage: TypeSystemStorage,
  ) => TE.TaskEither<TypeSystemError, TypeSystemSerializeOutput>;
}

// --- Internal types ---

interface TypeDef {
  readonly id: string;
  readonly schema: Record<string, unknown>;
  readonly constraints: Record<string, unknown>;
  readonly parentId: string | null;
}

const makeStorageError = (error: unknown): TypeSystemError => ({
  code: 'STORAGE_ERROR',
  message: error instanceof Error ? error.message : String(error),
});

const safeParseJson = (str: string): Record<string, unknown> => {
  try {
    const parsed = JSON.parse(str);
    return typeof parsed === 'object' && parsed !== null ? parsed : {};
  } catch {
    return {};
  }
};

// Load a type definition from storage
const loadType = (
  storage: TypeSystemStorage,
  typeId: string,
): TE.TaskEither<TypeSystemError, O.Option<TypeDef>> =>
  TE.tryCatch(
    async () => {
      const record = await storage.get('types', typeId);
      return pipe(
        O.fromNullable(record),
        O.map((r) => ({
          id: String(r['id'] ?? ''),
          schema: safeParseJson(String(r['schema'] ?? '{}')),
          constraints: safeParseJson(String(r['constraints'] ?? '{}')),
          parentId: r['parentId'] !== null && r['parentId'] !== undefined
            ? String(r['parentId'])
            : null,
        })),
      );
    },
    makeStorageError,
  );

// Resolve a type fully, merging inherited fields from parent types
const resolveTypeFull = async (
  typeId: string,
  storage: TypeSystemStorage,
  visited: ReadonlySet<string>,
): Promise<E.Either<string, { readonly schema: Record<string, unknown>; readonly typeId: string }>> => {
  if (visited.has(typeId)) {
    return E.left(`Circular type inheritance detected for '${typeId}'`);
  }

  const record = await storage.get('types', typeId);
  if (record === null) {
    return E.left(`Type '${typeId}' not found`);
  }

  const schema = safeParseJson(String(record['schema'] ?? '{}'));
  const parentId = record['parentId'] !== null && record['parentId'] !== undefined
    ? String(record['parentId'])
    : null;

  // If there's a parent, resolve it and merge
  if (parentId !== null) {
    const newVisited = new Set(visited);
    newVisited.add(typeId);
    const parentResult = await resolveTypeFull(parentId, storage, newVisited);
    if (E.isLeft(parentResult)) return parentResult;

    const parentSchema = parentResult.right.schema;
    // Deep merge: child overrides parent
    const mergedSchema = mergeSchemas(parentSchema, schema);
    return E.right({ schema: mergedSchema, typeId });
  }

  return E.right({ schema, typeId });
};

// Deep merge two schema objects (target overrides source)
const mergeSchemas = (
  parent: Record<string, unknown>,
  child: Record<string, unknown>,
): Record<string, unknown> => {
  const result: Record<string, unknown> = { ...parent };

  for (const [key, value] of Object.entries(child)) {
    if (
      typeof value === 'object' &&
      value !== null &&
      !Array.isArray(value) &&
      typeof result[key] === 'object' &&
      result[key] !== null &&
      !Array.isArray(result[key])
    ) {
      result[key] = mergeSchemas(
        result[key] as Record<string, unknown>,
        value as Record<string, unknown>,
      );
    } else {
      result[key] = value;
    }
  }

  return result;
};

// Navigate into a nested schema via dot-separated path
const navigateSchema = (
  schema: Record<string, unknown>,
  path: string,
): O.Option<{ readonly subSchema: Record<string, unknown>; readonly fieldName: string }> => {
  const parts = path.split('.');
  let current: unknown = schema;

  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];

    if (typeof current !== 'object' || current === null) {
      return O.none;
    }

    const obj = current as Record<string, unknown>;

    // Try direct property access
    if (part in obj) {
      current = obj[part];
      continue;
    }

    // Try "properties" object (JSON Schema style)
    if (typeof obj['properties'] === 'object' && obj['properties'] !== null) {
      const props = obj['properties'] as Record<string, unknown>;
      if (part in props) {
        current = props[part];
        continue;
      }
    }

    // Try "fields" object
    if (typeof obj['fields'] === 'object' && obj['fields'] !== null) {
      const fields = obj['fields'] as Record<string, unknown>;
      if (part in fields) {
        current = fields[part];
        continue;
      }
    }

    return O.none;
  }

  if (typeof current === 'object' && current !== null) {
    return O.some({
      subSchema: current as Record<string, unknown>,
      fieldName: parts[parts.length - 1],
    });
  }

  // Wrap primitive types
  return O.some({
    subSchema: { type: typeof current, value: current },
    fieldName: parts[parts.length - 1],
  });
};

// Serialize a value according to a type schema
const serializeValue = (
  value: string,
  schema: Record<string, unknown>,
): E.Either<string, string> => {
  const schemaType = String(schema['type'] ?? 'any');

  let parsed: unknown;
  try {
    parsed = JSON.parse(value);
  } catch {
    parsed = value;
  }

  switch (schemaType) {
    case 'string':
      return E.right(JSON.stringify(String(parsed)));

    case 'number':
    case 'integer': {
      const num = Number(parsed);
      if (isNaN(num)) return E.left(`Cannot serialize '${value}' as ${schemaType}`);
      if (schemaType === 'integer' && !Number.isInteger(num)) {
        return E.left(`Value '${value}' is not an integer`);
      }
      return E.right(JSON.stringify(num));
    }

    case 'boolean': {
      if (parsed === true || parsed === false) return E.right(JSON.stringify(parsed));
      if (parsed === 'true') return E.right('true');
      if (parsed === 'false') return E.right('false');
      return E.left(`Cannot serialize '${value}' as boolean`);
    }

    case 'array': {
      if (!Array.isArray(parsed)) return E.left(`Cannot serialize '${value}' as array`);
      return E.right(JSON.stringify(parsed));
    }

    case 'object': {
      if (typeof parsed !== 'object' || parsed === null || Array.isArray(parsed)) {
        return E.left(`Cannot serialize '${value}' as object`);
      }

      // Validate against properties if defined
      const properties = schema['properties'] as Record<string, unknown> | undefined;
      if (properties !== undefined) {
        const required = Array.isArray(schema['required'])
          ? new Set(schema['required'] as readonly string[])
          : new Set<string>();

        for (const reqField of required) {
          if (!(reqField in (parsed as Record<string, unknown>))) {
            return E.left(`Missing required field '${reqField}'`);
          }
        }
      }

      return E.right(JSON.stringify(parsed));
    }

    default:
      // For unknown types, serialize as-is
      return E.right(typeof parsed === 'string' ? parsed : JSON.stringify(parsed));
  }
};

// --- Implementation ---

export const typeSystemHandler: TypeSystemHandler = {
  registerType: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const existing = await storage.get('types', input.type);
          if (existing !== null) {
            return registerTypeExists(`Type '${input.type}' already exists`);
          }

          const schema = safeParseJson(input.schema);
          const constraints = safeParseJson(input.constraints);

          // Detect parent type from schema "$extends" or "extends" field
          const parentId = typeof schema['$extends'] === 'string'
            ? schema['$extends']
            : typeof schema['extends'] === 'string'
              ? schema['extends']
              : null;

          // Verify parent exists if specified
          if (parentId !== null) {
            const parentRecord = await storage.get('types', parentId);
            if (parentRecord === null) {
              return registerTypeExists(`Parent type '${parentId}' not found`);
            }
          }

          await storage.put('types', input.type, {
            id: input.type,
            schema: input.schema,
            constraints: input.constraints,
            parentId,
          });

          return registerTypeOk(input.type);
        },
        makeStorageError,
      ),
    ),

  resolve: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const result = await resolveTypeFull(input.type, storage, new Set());
          if (E.isLeft(result)) {
            return resolveNotfound(result.left);
          }
          return resolveOk(result.right.typeId, JSON.stringify(result.right.schema));
        },
        makeStorageError,
      ),
    ),

  navigate: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const typeResult = await resolveTypeFull(input.type, storage, new Set());
          if (E.isLeft(typeResult)) {
            return navigateNotfound(typeResult.left);
          }

          const schema = typeResult.right.schema;
          const navResult = navigateSchema(schema, input.path);

          return pipe(
            navResult,
            O.fold(
              () => navigateNotfound(
                `Path '${input.path}' not found in type '${input.type}'`,
              ),
              (nav) => navigateOk(
                `${input.type}.${input.path}`,
                JSON.stringify(nav.subSchema),
              ),
            ),
          );
        },
        makeStorageError,
      ),
    ),

  serialize: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const typeResult = await resolveTypeFull(input.type, storage, new Set());
          if (E.isLeft(typeResult)) {
            return serializeNotfound(typeResult.left);
          }

          const schema = typeResult.right.schema;
          const serResult = serializeValue(input.value, schema);

          return pipe(
            serResult,
            E.fold(
              (err) => serializeNotfound(err),
              (serialized) => serializeOk(serialized),
            ),
          );
        },
        makeStorageError,
      ),
    ),
};
