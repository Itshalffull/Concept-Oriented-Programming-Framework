// ManualResolution — handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import { pipe } from 'fp-ts/function';

import type {
  ManualResolutionStorage,
  ManualResolutionRegisterInput,
  ManualResolutionRegisterOutput,
  ManualResolutionAttemptResolveInput,
  ManualResolutionAttemptResolveOutput,
} from './types.js';

import {
  registerOk,
  attemptResolveCannotResolve,
} from './types.js';

export interface ManualResolutionError {
  readonly code: string;
  readonly message: string;
}

export interface ManualResolutionHandler {
  readonly register: (
    input: ManualResolutionRegisterInput,
    storage: ManualResolutionStorage,
  ) => TE.TaskEither<ManualResolutionError, ManualResolutionRegisterOutput>;
  readonly attemptResolve: (
    input: ManualResolutionAttemptResolveInput,
    storage: ManualResolutionStorage,
  ) => TE.TaskEither<ManualResolutionError, ManualResolutionAttemptResolveOutput>;
}

// --- Implementation ---
//
// ManualResolution is the last-resort policy. It never auto-resolves;
// it always escalates to human review by returning cannotResolve.
// The invariant states: attemptResolve always yields cannotResolve.

export const manualResolutionHandler: ManualResolutionHandler = {
  register: (_input, _storage) =>
    pipe(
      TE.right(registerOk('manual', 'conflict-resolution', 99)),
    ),

  attemptResolve: (_input, _storage) =>
    pipe(
      TE.right(
        attemptResolveCannotResolve(
          'Manual resolution always escalates to human review — no automatic resolution available',
        ),
      ),
    ),
};
