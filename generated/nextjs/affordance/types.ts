// Affordance â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as O from 'fp-ts/Option';

// Storage interface for Affordance
export interface AffordanceStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface AffordanceDeclareInput {
  readonly affordance: string;
  readonly widget: string;
  readonly interactor: string;
  readonly specificity: number;
  readonly conditions: O.Option<string>;
}

export interface AffordanceDeclareOutputOk {
  readonly variant: 'ok';
  readonly affordance: string;
}

export interface AffordanceDeclareOutputDuplicate {
  readonly variant: 'duplicate';
  readonly message: string;
}

export type AffordanceDeclareOutput = AffordanceDeclareOutputOk | AffordanceDeclareOutputDuplicate;

export interface AffordanceMatchInput {
  readonly affordance: string;
  readonly interactor: string;
  readonly context: string;
}

export interface AffordanceMatchOutputOk {
  readonly variant: 'ok';
  readonly matches: string;
}

export interface AffordanceMatchOutputNone {
  readonly variant: 'none';
  readonly message: string;
}

export type AffordanceMatchOutput = AffordanceMatchOutputOk | AffordanceMatchOutputNone;

export interface AffordanceExplainInput {
  readonly affordance: string;
}

export interface AffordanceExplainOutputOk {
  readonly variant: 'ok';
  readonly affordance: string;
  readonly reason: string;
}

export interface AffordanceExplainOutputNotfound {
  readonly variant: 'notfound';
  readonly message: string;
}

export type AffordanceExplainOutput = AffordanceExplainOutputOk | AffordanceExplainOutputNotfound;

export interface AffordanceRemoveInput {
  readonly affordance: string;
}

export interface AffordanceRemoveOutputOk {
  readonly variant: 'ok';
  readonly affordance: string;
}

export interface AffordanceRemoveOutputNotfound {
  readonly variant: 'notfound';
  readonly message: string;
}

export type AffordanceRemoveOutput = AffordanceRemoveOutputOk | AffordanceRemoveOutputNotfound;

// --- Variant constructors ---

export const declareOk = (affordance: string): AffordanceDeclareOutput => ({ variant: 'ok', affordance } as AffordanceDeclareOutput);
export const declareDuplicate = (message: string): AffordanceDeclareOutput => ({ variant: 'duplicate', message } as AffordanceDeclareOutput);

export const matchOk = (matches: string): AffordanceMatchOutput => ({ variant: 'ok', matches } as AffordanceMatchOutput);
export const matchNone = (message: string): AffordanceMatchOutput => ({ variant: 'none', message } as AffordanceMatchOutput);

export const explainOk = (affordance: string, reason: string): AffordanceExplainOutput => ({ variant: 'ok', affordance, reason } as AffordanceExplainOutput);
export const explainNotfound = (message: string): AffordanceExplainOutput => ({ variant: 'notfound', message } as AffordanceExplainOutput);

export const removeOk = (affordance: string): AffordanceRemoveOutput => ({ variant: 'ok', affordance } as AffordanceRemoveOutput);
export const removeNotfound = (message: string): AffordanceRemoveOutput => ({ variant: 'notfound', message } as AffordanceRemoveOutput);

