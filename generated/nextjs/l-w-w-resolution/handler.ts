// LWWResolution — handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  LWWResolutionStorage,
  LWWResolutionRegisterInput,
  LWWResolutionRegisterOutput,
  LWWResolutionAttemptResolveInput,
  LWWResolutionAttemptResolveOutput,
} from './types.js';

import {
  registerOk,
  attemptResolveResolved,
  attemptResolveCannotResolve,
} from './types.js';

export interface LWWResolutionError {
  readonly code: string;
  readonly message: string;
}

export interface LWWResolutionHandler {
  readonly register: (
    input: LWWResolutionRegisterInput,
    storage: LWWResolutionStorage,
  ) => TE.TaskEither<LWWResolutionError, LWWResolutionRegisterOutput>;
  readonly attemptResolve: (
    input: LWWResolutionAttemptResolveInput,
    storage: LWWResolutionStorage,
  ) => TE.TaskEither<LWWResolutionError, LWWResolutionAttemptResolveOutput>;
}

// --- Helpers ---

const storageError = (error: unknown): LWWResolutionError => ({
  code: 'STORAGE_ERROR',
  message: error instanceof Error ? error.message : String(error),
});

/**
 * LWW version envelope: { timestamp: number, value: unknown }
 * The buffer is expected to be a JSON-encoded object with a numeric
 * `timestamp` field representing milliseconds since epoch.
 */
interface LWWEnvelope {
  readonly timestamp: number;
  readonly value: unknown;
}

/** Parse a buffer as a LWW envelope. Returns None if the format is invalid. */
const parseEnvelope = (buf: Buffer): O.Option<LWWEnvelope> => {
  try {
    const parsed = JSON.parse(buf.toString('utf-8'));
    if (
      typeof parsed === 'object' &&
      parsed !== null &&
      typeof parsed.timestamp === 'number'
    ) {
      return O.some({ timestamp: parsed.timestamp, value: parsed.value });
    }
    return O.none;
  } catch {
    return O.none;
  }
};

// --- Implementation ---

export const lWWResolutionHandler: LWWResolutionHandler = {
  register: (_input, _storage) =>
    pipe(
      TE.right(registerOk('lww', 'conflict-resolution', 10)),
    ),

  attemptResolve: (input, _storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const env1 = parseEnvelope(input.v1);
          const env2 = parseEnvelope(input.v2);

          return pipe(
            env1,
            O.fold(
              // v1 is not a valid LWW envelope — fall back to raw byte comparison
              () =>
                pipe(
                  env2,
                  O.fold(
                    // Neither has a parseable timestamp — compare raw bytes as a
                    // deterministic tiebreaker (lexicographic on the buffer).
                    () => {
                      const cmp = Buffer.compare(input.v1, input.v2);
                      if (cmp === 0) {
                        return attemptResolveCannotResolve(
                          'Timestamps are identical — exactly concurrent writes with no ordering',
                        );
                      }
                      // Deterministic tiebreaker: higher byte value wins
                      return attemptResolveResolved(cmp > 0 ? input.v1 : input.v2);
                    },
                    // Only v2 has a timestamp — v2 wins by having temporal info
                    (_e2) => attemptResolveResolved(input.v2),
                  ),
                ),
              (e1) =>
                pipe(
                  env2,
                  O.fold(
                    // Only v1 has a timestamp — v1 wins
                    () => attemptResolveResolved(input.v1),
                    (e2) => {
                      // Both have timestamps — compare them
                      if (e1.timestamp > e2.timestamp) {
                        return attemptResolveResolved(input.v1);
                      }
                      if (e2.timestamp > e1.timestamp) {
                        return attemptResolveResolved(input.v2);
                      }
                      // Timestamps are exactly equal — cannot determine winner
                      return attemptResolveCannotResolve(
                        'Timestamps are identical — exactly concurrent writes with no ordering',
                      );
                    },
                  ),
                ),
            ),
          );
        },
        storageError,
      ),
    ),
};
