// ContentParser â€” handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  ContentParserStorage,
  ContentParserRegisterFormatInput,
  ContentParserRegisterFormatOutput,
  ContentParserRegisterExtractorInput,
  ContentParserRegisterExtractorOutput,
  ContentParserParseInput,
  ContentParserParseOutput,
  ContentParserExtractRefsInput,
  ContentParserExtractRefsOutput,
  ContentParserExtractTagsInput,
  ContentParserExtractTagsOutput,
  ContentParserExtractPropertiesInput,
  ContentParserExtractPropertiesOutput,
  ContentParserSerializeInput,
  ContentParserSerializeOutput,
} from './types.js';

import {
  registerFormatOk,
  registerFormatExists,
  registerExtractorOk,
  registerExtractorExists,
  parseOk,
  parseError,
  extractRefsOk,
  extractRefsNotfound,
  extractTagsOk,
  extractTagsNotfound,
  extractPropertiesOk,
  extractPropertiesNotfound,
  serializeOk,
  serializeNotfound,
} from './types.js';

export interface ContentParserError {
  readonly code: string;
  readonly message: string;
}

export interface ContentParserHandler {
  readonly registerFormat: (
    input: ContentParserRegisterFormatInput,
    storage: ContentParserStorage,
  ) => TE.TaskEither<ContentParserError, ContentParserRegisterFormatOutput>;
  readonly registerExtractor: (
    input: ContentParserRegisterExtractorInput,
    storage: ContentParserStorage,
  ) => TE.TaskEither<ContentParserError, ContentParserRegisterExtractorOutput>;
  readonly parse: (
    input: ContentParserParseInput,
    storage: ContentParserStorage,
  ) => TE.TaskEither<ContentParserError, ContentParserParseOutput>;
  readonly extractRefs: (
    input: ContentParserExtractRefsInput,
    storage: ContentParserStorage,
  ) => TE.TaskEither<ContentParserError, ContentParserExtractRefsOutput>;
  readonly extractTags: (
    input: ContentParserExtractTagsInput,
    storage: ContentParserStorage,
  ) => TE.TaskEither<ContentParserError, ContentParserExtractTagsOutput>;
  readonly extractProperties: (
    input: ContentParserExtractPropertiesInput,
    storage: ContentParserStorage,
  ) => TE.TaskEither<ContentParserError, ContentParserExtractPropertiesOutput>;
  readonly serialize: (
    input: ContentParserSerializeInput,
    storage: ContentParserStorage,
  ) => TE.TaskEither<ContentParserError, ContentParserSerializeOutput>;
}

// --- AST node types for content parser ---

interface ContentNode {
  readonly type: string;
  readonly content?: string;
  readonly children?: readonly ContentNode[];
  readonly attrs?: Record<string, string>;
}

const makeStorageError = (error: unknown): ContentParserError => ({
  code: 'STORAGE_ERROR',
  message: error instanceof Error ? error.message : String(error),
});

// --- Markdown parser ---

const parseMarkdown = (text: string): ContentNode => {
  const lines = text.split('\n');
  const children: ContentNode[] = [];

  let i = 0;
  while (i < lines.length) {
    const line = lines[i];

    // Headings
    const headingMatch = line.match(/^(#{1,6})\s+(.*)$/);
    if (headingMatch) {
      const level = headingMatch[1].length;
      children.push({
        type: 'heading',
        content: headingMatch[2],
        attrs: { level: String(level) },
      });
      i++;
      continue;
    }

    // Code block
    if (line.startsWith('```')) {
      const lang = line.slice(3).trim();
      const codeLines: string[] = [];
      i++;
      while (i < lines.length && !lines[i].startsWith('```')) {
        codeLines.push(lines[i]);
        i++;
      }
      children.push({
        type: 'code_block',
        content: codeLines.join('\n'),
        attrs: lang ? { language: lang } : {},
      });
      i++; // skip closing ```
      continue;
    }

    // Blockquote
    if (line.startsWith('> ')) {
      const quoteLines: string[] = [];
      while (i < lines.length && lines[i].startsWith('> ')) {
        quoteLines.push(lines[i].slice(2));
        i++;
      }
      children.push({
        type: 'blockquote',
        content: quoteLines.join('\n'),
      });
      continue;
    }

    // Unordered list item
    if (line.match(/^[-*+]\s+/)) {
      const listItems: ContentNode[] = [];
      while (i < lines.length && lines[i].match(/^[-*+]\s+/)) {
        listItems.push({
          type: 'list_item',
          content: lines[i].replace(/^[-*+]\s+/, ''),
        });
        i++;
      }
      children.push({ type: 'list', children: listItems, attrs: { ordered: 'false' } });
      continue;
    }

    // Ordered list item
    if (line.match(/^\d+\.\s+/)) {
      const listItems: ContentNode[] = [];
      while (i < lines.length && lines[i].match(/^\d+\.\s+/)) {
        listItems.push({
          type: 'list_item',
          content: lines[i].replace(/^\d+\.\s+/, ''),
        });
        i++;
      }
      children.push({ type: 'list', children: listItems, attrs: { ordered: 'true' } });
      continue;
    }

    // Horizontal rule
    if (line.match(/^(-{3,}|_{3,}|\*{3,})$/)) {
      children.push({ type: 'hr' });
      i++;
      continue;
    }

    // Empty line
    if (line.trim() === '') {
      i++;
      continue;
    }

    // Paragraph (collect consecutive non-empty lines)
    const paraLines: string[] = [];
    while (i < lines.length && lines[i].trim() !== '' && !lines[i].startsWith('#') && !lines[i].startsWith('```') && !lines[i].startsWith('> ')) {
      paraLines.push(lines[i]);
      i++;
    }
    if (paraLines.length > 0) {
      children.push({
        type: 'paragraph',
        content: paraLines.join(' '),
      });
    }
  }

  return {
    type: 'document',
    children,
    attrs: { format: 'markdown' },
  };
};

// --- Plain text parser ---

const parsePlainText = (text: string): ContentNode => ({
  type: 'document',
  children: text.split('\n\n').filter((p) => p.trim().length > 0).map((p) => ({
    type: 'paragraph',
    content: p.trim(),
  })),
  attrs: { format: 'plain' },
});

// --- Extraction utilities ---

// Extract [[wikilink]] and [text](url) references
const extractReferences = (ast: ContentNode): readonly string[] => {
  const refs: string[] = [];

  const walk = (node: ContentNode): void => {
    if (node.content) {
      // Wiki-style links: [[target]] or [[target|label]]
      const wikiLinks = node.content.matchAll(/\[\[([^\]|]+)(?:\|[^\]]+)?\]\]/g);
      for (const match of wikiLinks) {
        refs.push(match[1].trim());
      }

      // Markdown links: [text](url)
      const mdLinks = node.content.matchAll(/\[([^\]]+)\]\(([^)]+)\)/g);
      for (const match of mdLinks) {
        refs.push(match[2].trim());
      }

      // Bare URLs
      const urls = node.content.matchAll(/https?:\/\/[^\s)>\]]+/g);
      for (const match of urls) {
        refs.push(match[0]);
      }
    }
    if (node.children) {
      for (const child of node.children) walk(child);
    }
  };

  walk(ast);
  return [...new Set(refs)]; // deduplicate
};

// Extract #tags and #tag-name style tags
const extractTags = (ast: ContentNode): readonly string[] => {
  const tags: string[] = [];

  const walk = (node: ContentNode): void => {
    if (node.content) {
      // Hashtag-style tags: #tag or #multi-word-tag
      const tagMatches = node.content.matchAll(/(?:^|\s)#([a-zA-Z][a-zA-Z0-9_-]*)/g);
      for (const match of tagMatches) {
        tags.push(match[1]);
      }
    }
    if (node.children) {
      for (const child of node.children) walk(child);
    }
  };

  walk(ast);
  return [...new Set(tags)];
};

// Extract inline properties like `key:: value` or `key: value` patterns
const extractProperties = (ast: ContentNode): readonly { readonly key: string; readonly value: string }[] => {
  const properties: Array<{ readonly key: string; readonly value: string }> = [];

  const walk = (node: ContentNode): void => {
    if (node.content) {
      // Double-colon property style (used in Obsidian/Logseq): key:: value
      const dblColonProps = node.content.matchAll(/([a-zA-Z_][a-zA-Z0-9_-]*)::\s*(.+)/g);
      for (const match of dblColonProps) {
        properties.push({ key: match[1].trim(), value: match[2].trim() });
      }

      // YAML-like frontmatter property: key: value (only at line start)
      if (node.type === 'paragraph' || node.type === 'list_item') {
        const yamlProps = node.content.matchAll(/^([a-zA-Z_][a-zA-Z0-9_-]*):\s+(.+)$/gm);
        for (const match of yamlProps) {
          properties.push({ key: match[1].trim(), value: match[2].trim() });
        }
      }
    }
    if (node.children) {
      for (const child of node.children) walk(child);
    }
  };

  walk(ast);
  return properties;
};

// --- Serialization ---

const serializeToMarkdown = (ast: ContentNode): string => {
  const serializeNode = (node: ContentNode): string => {
    switch (node.type) {
      case 'document':
        return (node.children ?? []).map(serializeNode).join('\n\n');

      case 'heading': {
        const level = parseInt(node.attrs?.['level'] ?? '1', 10);
        return `${'#'.repeat(level)} ${node.content ?? ''}`;
      }

      case 'paragraph':
        return node.content ?? '';

      case 'code_block': {
        const lang = node.attrs?.['language'] ?? '';
        return `\`\`\`${lang}\n${node.content ?? ''}\n\`\`\``;
      }

      case 'blockquote':
        return (node.content ?? '').split('\n').map((l) => `> ${l}`).join('\n');

      case 'list': {
        const ordered = node.attrs?.['ordered'] === 'true';
        return (node.children ?? []).map((item, idx) =>
          ordered ? `${idx + 1}. ${item.content ?? ''}` : `- ${item.content ?? ''}`,
        ).join('\n');
      }

      case 'list_item':
        return `- ${node.content ?? ''}`;

      case 'hr':
        return '---';

      default:
        return node.content ?? '';
    }
  };

  return serializeNode(ast);
};

const serializeToPlainText = (ast: ContentNode): string => {
  const parts: string[] = [];

  const walk = (node: ContentNode): void => {
    if (node.content) parts.push(node.content);
    if (node.children) {
      for (const child of node.children) walk(child);
    }
  };

  walk(ast);
  return parts.join('\n');
};

// --- Implementation ---

export const contentParserHandler: ContentParserHandler = {
  registerFormat: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const existing = await storage.get('cp_formats', input.name);
          if (existing !== null) {
            return registerFormatExists(`Format '${input.name}' already registered`);
          }
          await storage.put('cp_formats', input.name, {
            name: input.name,
            grammar: input.grammar,
          });
          return registerFormatOk(input.name);
        },
        makeStorageError,
      ),
    ),

  registerExtractor: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const existing = await storage.get('cp_extractors', input.name);
          if (existing !== null) {
            return registerExtractorExists(`Extractor '${input.name}' already registered`);
          }
          await storage.put('cp_extractors', input.name, {
            name: input.name,
            pattern: input.pattern,
          });
          return registerExtractorOk(input.name);
        },
        makeStorageError,
      ),
    ),

  parse: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          // Verify format is registered
          const format = await storage.get('cp_formats', input.format);
          if (format === null) {
            return parseError(`Format '${input.format}' is not registered`);
          }

          // Parse according to format
          let ast: ContentNode;
          const formatName = input.format.toLowerCase();

          if (formatName === 'markdown' || formatName === 'md') {
            ast = parseMarkdown(input.text);
          } else if (formatName === 'plain' || formatName === 'text' || formatName === 'txt') {
            ast = parsePlainText(input.text);
          } else {
            // For custom formats, attempt markdown-like parsing as fallback
            ast = parseMarkdown(input.text);
            ast = { ...ast, attrs: { ...ast.attrs, format: input.format } };
          }

          // Cache the AST
          await storage.put('cp_ast_cache', input.content, {
            contentId: input.content,
            text: input.text,
            format: input.format,
            ast: JSON.stringify(ast),
          });

          return parseOk(JSON.stringify(ast));
        },
        makeStorageError,
      ),
    ),

  extractRefs: (input, storage) =>
    pipe(
      TE.tryCatch(
        () => storage.get('cp_ast_cache', input.content),
        makeStorageError,
      ),
      TE.chain((record) =>
        pipe(
          O.fromNullable(record),
          O.fold(
            () => TE.right<ContentParserError, ContentParserExtractRefsOutput>(
              extractRefsNotfound(`No AST cached for content '${input.content}'`),
            ),
            (found) => {
              const ast: ContentNode = JSON.parse(String(found['ast'] ?? '{}'));
              const refs = extractReferences(ast);
              return TE.right<ContentParserError, ContentParserExtractRefsOutput>(
                extractRefsOk(JSON.stringify(refs)),
              );
            },
          ),
        ),
      ),
    ),

  extractTags: (input, storage) =>
    pipe(
      TE.tryCatch(
        () => storage.get('cp_ast_cache', input.content),
        makeStorageError,
      ),
      TE.chain((record) =>
        pipe(
          O.fromNullable(record),
          O.fold(
            () => TE.right<ContentParserError, ContentParserExtractTagsOutput>(
              extractTagsNotfound(`No AST cached for content '${input.content}'`),
            ),
            (found) => {
              const ast: ContentNode = JSON.parse(String(found['ast'] ?? '{}'));
              const tags = extractTags(ast);
              return TE.right<ContentParserError, ContentParserExtractTagsOutput>(
                extractTagsOk(JSON.stringify(tags)),
              );
            },
          ),
        ),
      ),
    ),

  extractProperties: (input, storage) =>
    pipe(
      TE.tryCatch(
        () => storage.get('cp_ast_cache', input.content),
        makeStorageError,
      ),
      TE.chain((record) =>
        pipe(
          O.fromNullable(record),
          O.fold(
            () => TE.right<ContentParserError, ContentParserExtractPropertiesOutput>(
              extractPropertiesNotfound(`No AST cached for content '${input.content}'`),
            ),
            (found) => {
              const ast: ContentNode = JSON.parse(String(found['ast'] ?? '{}'));
              const properties = extractProperties(ast);
              return TE.right<ContentParserError, ContentParserExtractPropertiesOutput>(
                extractPropertiesOk(JSON.stringify(properties)),
              );
            },
          ),
        ),
      ),
    ),

  serialize: (input, storage) =>
    pipe(
      TE.tryCatch(
        () => storage.get('cp_ast_cache', input.content),
        makeStorageError,
      ),
      TE.chain((record) =>
        pipe(
          O.fromNullable(record),
          O.fold(
            () => TE.right<ContentParserError, ContentParserSerializeOutput>(
              serializeNotfound(`No AST cached for content '${input.content}'`),
            ),
            (found) => {
              const ast: ContentNode = JSON.parse(String(found['ast'] ?? '{}'));
              const formatName = input.format.toLowerCase();

              let text: string;
              if (formatName === 'markdown' || formatName === 'md') {
                text = serializeToMarkdown(ast);
              } else if (formatName === 'plain' || formatName === 'text' || formatName === 'txt') {
                text = serializeToPlainText(ast);
              } else {
                // Default to markdown serialization
                text = serializeToMarkdown(ast);
              }

              return TE.right<ContentParserError, ContentParserSerializeOutput>(
                serializeOk(text),
              );
            },
          ),
        ),
      ),
    ),
};
