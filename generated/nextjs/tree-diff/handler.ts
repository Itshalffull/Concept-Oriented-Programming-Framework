// TreeDiff â€” handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.
//
// Implements a simplified Zhang-Shasha tree edit distance algorithm
// for JSON tree structures. Computes the minimum-cost edit script
// (insert, delete, rename/update) to transform one tree into another,
// preserving structural relationships that line-oriented diffs lose.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  TreeDiffStorage,
  TreeDiffRegisterInput,
  TreeDiffRegisterOutput,
  TreeDiffComputeInput,
  TreeDiffComputeOutput,
} from './types.js';

import {
  registerOk,
  computeOk,
  computeUnsupportedContent,
} from './types.js';

export interface TreeDiffError {
  readonly code: string;
  readonly message: string;
}

export interface TreeDiffHandler {
  readonly register: (
    input: TreeDiffRegisterInput,
    storage: TreeDiffStorage,
  ) => TE.TaskEither<TreeDiffError, TreeDiffRegisterOutput>;
  readonly compute: (
    input: TreeDiffComputeInput,
    storage: TreeDiffStorage,
  ) => TE.TaskEither<TreeDiffError, TreeDiffComputeOutput>;
}

// --- Internal tree representation ---

interface TreeNode {
  readonly label: string;
  readonly children: readonly TreeNode[];
}

type TreeEditOp =
  | { readonly type: 'keep'; readonly label: string }
  | { readonly type: 'insert'; readonly label: string; readonly parent: string }
  | { readonly type: 'delete'; readonly label: string }
  | { readonly type: 'rename'; readonly from: string; readonly to: string };

// --- Flattened node for Zhang-Shasha ---

interface IndexedNode {
  readonly label: string;
  readonly children: readonly number[]; // indices into the flattened array
  readonly leftmost: number; // index of leftmost leaf descendant
}

// --- Pure helper functions ---

const serializeEditScript = (ops: readonly TreeEditOp[]): Buffer =>
  Buffer.from(JSON.stringify(ops), 'utf-8');

/**
 * Parse a JSON value into our internal TreeNode representation.
 * Objects become nodes with key as label and children for values.
 * Arrays become nodes with "[]" label and indexed children.
 * Primitives become leaf nodes with their stringified value.
 */
const jsonToTree = (value: unknown, label: string = 'root'): TreeNode => {
  if (value === null || value === undefined) {
    return { label: `${label}:null`, children: [] };
  }
  if (typeof value === 'object' && Array.isArray(value)) {
    const children = value.map((item, idx) =>
      jsonToTree(item, `[${idx}]`),
    );
    return { label: `${label}:[]`, children };
  }
  if (typeof value === 'object') {
    const obj = value as Record<string, unknown>;
    const children = Object.keys(obj).sort().map(key =>
      jsonToTree(obj[key], key),
    );
    return { label: `${label}:{}`, children };
  }
  // Primitive
  return { label: `${label}:${String(value)}`, children: [] };
};

/**
 * Flatten tree into post-order indexed array for Zhang-Shasha.
 * Returns the array of IndexedNodes and the root index.
 */
const flattenPostOrder = (
  root: TreeNode,
): { readonly nodes: readonly IndexedNode[]; readonly rootIdx: number } => {
  const nodes: IndexedNode[] = [];

  const visit = (node: TreeNode): number => {
    const childIndices: number[] = [];
    for (const child of node.children) {
      childIndices.push(visit(child));
    }

    const leftmost = childIndices.length > 0
      ? nodes[childIndices[0]].leftmost
      : nodes.length; // leaf: leftmost is itself

    const idx = nodes.length;
    nodes.push({
      label: node.label,
      children: childIndices,
      leftmost,
    });
    return idx;
  };

  const rootIdx = visit(root);
  return { nodes, rootIdx };
};

/**
 * Compute key roots for Zhang-Shasha algorithm.
 * A key root is a node whose leftmost leaf descendant differs
 * from its parent's leftmost leaf descendant, or the root itself.
 */
const computeKeyRoots = (nodes: readonly IndexedNode[]): readonly number[] => {
  const n = nodes.length;
  // Track which leftmost values have been seen
  const leftmostSeen = new Set<number>();
  const keyRoots: number[] = [];

  // Process in reverse post-order (highest index first)
  for (let i = n - 1; i >= 0; i--) {
    const lm = nodes[i].leftmost;
    if (!leftmostSeen.has(lm)) {
      leftmostSeen.add(lm);
      keyRoots.push(i);
    }
  }

  keyRoots.sort((a, b) => a - b);
  return keyRoots;
};

/**
 * Zhang-Shasha tree edit distance algorithm.
 * Returns the edit distance and the edit operations.
 */
const zhangShasha = (
  treeA: TreeNode,
  treeB: TreeNode,
): { readonly distance: number; readonly ops: readonly TreeEditOp[] } => {
  const { nodes: nodesA, rootIdx: _rootA } = flattenPostOrder(treeA);
  const { nodes: nodesB, rootIdx: _rootB } = flattenPostOrder(treeB);

  const nA = nodesA.length;
  const nB = nodesB.length;

  if (nA === 0 && nB === 0) return { distance: 0, ops: [] };
  if (nA === 0) {
    const ops: TreeEditOp[] = nodesB.map(n => ({
      type: 'insert' as const,
      label: n.label,
      parent: '',
    }));
    return { distance: nB, ops };
  }
  if (nB === 0) {
    const ops: TreeEditOp[] = nodesA.map(n => ({
      type: 'delete' as const,
      label: n.label,
    }));
    return { distance: nA, ops };
  }

  const keyRootsA = computeKeyRoots(nodesA);
  const keyRootsB = computeKeyRoots(nodesB);

  // Main tree distance matrix td[i][j]
  const td: number[][] = Array.from({ length: nA + 1 }, () =>
    new Array<number>(nB + 1).fill(0),
  );
  // Operation tracking: 0=keep/rename, 1=delete, 2=insert
  const tdOp: number[][] = Array.from({ length: nA + 1 }, () =>
    new Array<number>(nB + 1).fill(0),
  );

  for (const krA of keyRootsA) {
    for (const krB of keyRootsB) {
      const lmA = nodesA[krA].leftmost;
      const lmB = nodesB[krB].leftmost;

      // Forest distance fd[i - lmA + 1][j - lmB + 1]
      const rowsF = krA - lmA + 2;
      const colsF = krB - lmB + 2;
      const fd: number[][] = Array.from({ length: rowsF + 1 }, () =>
        new Array<number>(colsF + 1).fill(0),
      );

      // Base cases for forest distance
      fd[0][0] = 0;
      for (let i = 1; i <= krA - lmA + 1; i++) {
        fd[i][0] = fd[i - 1][0] + 1; // delete cost
      }
      for (let j = 1; j <= krB - lmB + 1; j++) {
        fd[0][j] = fd[0][j - 1] + 1; // insert cost
      }

      for (let i = lmA; i <= krA; i++) {
        for (let j = lmB; j <= krB; j++) {
          const fi = i - lmA + 1;
          const fj = j - lmB + 1;

          const lmI = nodesA[i].leftmost;
          const lmJ = nodesB[j].leftmost;

          if (lmI === lmA && lmJ === lmB) {
            // Both are key roots relative to the current subproblem
            const renameCost = nodesA[i].label === nodesB[j].label ? 0 : 1;
            const costDelete = fd[fi - 1][fj] + 1;
            const costInsert = fd[fi][fj - 1] + 1;
            const costRename = fd[fi - 1][fj - 1] + renameCost;

            fd[fi][fj] = Math.min(costDelete, costInsert, costRename);
            td[i + 1][j + 1] = fd[fi][fj];
          } else {
            // Use previously computed tree distances
            const lmIRel = lmI - lmA;
            const lmJRel = lmJ - lmB;
            const costDelete = fd[fi - 1][fj] + 1;
            const costInsert = fd[fi][fj - 1] + 1;
            const costTree = fd[lmIRel][lmJRel] + td[i + 1][j + 1];

            fd[fi][fj] = Math.min(costDelete, costInsert, costTree);
          }
        }
      }
    }
  }

  const distance = td[nA][nB];

  // Reconstruct edit operations from the distance matrix
  const ops: TreeEditOp[] = [];
  reconstructOps(nodesA, nodesB, nA - 1, nB - 1, td, ops);

  return { distance, ops };
};

/**
 * Reconstruct edit operations by comparing the two trees top-down.
 * Uses a simplified approach: walk both trees and emit operations.
 */
const reconstructOps = (
  nodesA: readonly IndexedNode[],
  nodesB: readonly IndexedNode[],
  idxA: number,
  idxB: number,
  td: readonly (readonly number[])[],
  ops: TreeEditOp[],
): void => {
  if (idxA < 0 && idxB < 0) return;

  if (idxA < 0) {
    // All remaining B nodes are inserts
    for (let j = 0; j <= idxB; j++) {
      ops.push({ type: 'insert', label: nodesB[j].label, parent: '' });
    }
    return;
  }

  if (idxB < 0) {
    // All remaining A nodes are deletes
    for (let i = 0; i <= idxA; i++) {
      ops.push({ type: 'delete', label: nodesA[i].label });
    }
    return;
  }

  const nodeA = nodesA[idxA];
  const nodeB = nodesB[idxB];

  if (nodeA.label === nodeB.label) {
    ops.push({ type: 'keep', label: nodeA.label });
  } else {
    ops.push({ type: 'rename', from: nodeA.label, to: nodeB.label });
  }

  // Recursively handle children by matching them greedily
  const childrenA = [...nodeA.children];
  const childrenB = [...nodeB.children];

  let ai = 0;
  let bi = 0;
  while (ai < childrenA.length && bi < childrenB.length) {
    reconstructOps(nodesA, nodesB, childrenA[ai], childrenB[bi], td, ops);
    ai++;
    bi++;
  }
  while (ai < childrenA.length) {
    collectAllDeletes(nodesA, childrenA[ai], ops);
    ai++;
  }
  while (bi < childrenB.length) {
    collectAllInserts(nodesB, childrenB[bi], ops);
    bi++;
  }
};

const collectAllDeletes = (
  nodes: readonly IndexedNode[],
  idx: number,
  ops: TreeEditOp[],
): void => {
  const node = nodes[idx];
  for (const childIdx of node.children) {
    collectAllDeletes(nodes, childIdx, ops);
  }
  ops.push({ type: 'delete', label: node.label });
};

const collectAllInserts = (
  nodes: readonly IndexedNode[],
  idx: number,
  ops: TreeEditOp[],
): void => {
  for (const childIdx of nodes[idx].children) {
    collectAllInserts(nodes, childIdx, ops);
  }
  ops.push({ type: 'insert', label: nodes[idx].label, parent: '' });
};

/**
 * Attempt to parse a Buffer as JSON and convert to a TreeNode.
 */
const parseJsonTree = (
  buf: Buffer,
  label: string,
): E.Either<TreeDiffError, TreeNode> =>
  pipe(
    E.tryCatch(
      () => JSON.parse(buf.toString('utf-8')) as unknown,
      (error): TreeDiffError => ({
        code: 'PARSE_ERROR',
        message: `Invalid JSON in ${label}: ${error instanceof Error ? error.message : String(error)}`,
      }),
    ),
    E.map(parsed => jsonToTree(parsed, 'root')),
  );

// --- Implementation ---

export const treeDiffHandler: TreeDiffHandler = {
  register: (_input, _storage) =>
    TE.right(
      registerOk('tree', 'diff', ['application/json', 'application/xml', 'text/xml']),
    ),

  compute: (input, _storage) =>
    pipe(
      TE.fromEither(
        pipe(
          parseJsonTree(input.contentA, 'contentA'),
          E.chain(treeA =>
            pipe(
              parseJsonTree(input.contentB, 'contentB'),
              E.map(treeB => ({ treeA, treeB })),
            ),
          ),
        ),
      ),
      TE.map(({ treeA, treeB }) => {
        const { distance, ops } = zhangShasha(treeA, treeB);
        return computeOk(serializeEditScript(ops), distance);
      }),
    ),
};
