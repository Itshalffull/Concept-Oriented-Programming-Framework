// Graph â€” handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  GraphStorage,
  GraphAddNodeInput,
  GraphAddNodeOutput,
  GraphRemoveNodeInput,
  GraphRemoveNodeOutput,
  GraphAddEdgeInput,
  GraphAddEdgeOutput,
  GraphRemoveEdgeInput,
  GraphRemoveEdgeOutput,
  GraphGetNeighborsInput,
  GraphGetNeighborsOutput,
  GraphFilterNodesInput,
  GraphFilterNodesOutput,
} from './types.js';

import {
  addNodeOk,
  addNodeNotfound,
  removeNodeOk,
  removeNodeNotfound,
  addEdgeOk,
  addEdgeNotfound,
  removeEdgeOk,
  removeEdgeNotfound,
  getNeighborsOk,
  getNeighborsNotfound,
  filterNodesOk,
  filterNodesNotfound,
} from './types.js';

export interface GraphError {
  readonly code: string;
  readonly message: string;
}

export interface GraphHandler {
  readonly addNode: (
    input: GraphAddNodeInput,
    storage: GraphStorage,
  ) => TE.TaskEither<GraphError, GraphAddNodeOutput>;
  readonly removeNode: (
    input: GraphRemoveNodeInput,
    storage: GraphStorage,
  ) => TE.TaskEither<GraphError, GraphRemoveNodeOutput>;
  readonly addEdge: (
    input: GraphAddEdgeInput,
    storage: GraphStorage,
  ) => TE.TaskEither<GraphError, GraphAddEdgeOutput>;
  readonly removeEdge: (
    input: GraphRemoveEdgeInput,
    storage: GraphStorage,
  ) => TE.TaskEither<GraphError, GraphRemoveEdgeOutput>;
  readonly getNeighbors: (
    input: GraphGetNeighborsInput,
    storage: GraphStorage,
  ) => TE.TaskEither<GraphError, GraphGetNeighborsOutput>;
  readonly filterNodes: (
    input: GraphFilterNodesInput,
    storage: GraphStorage,
  ) => TE.TaskEither<GraphError, GraphFilterNodesOutput>;
}

// --- Internal types ---

interface GraphData {
  readonly nodes: ReadonlySet<string>;
  readonly edges: readonly { readonly source: string; readonly target: string }[];
}

const makeStorageError = (error: unknown): GraphError => ({
  code: 'STORAGE_ERROR',
  message: error instanceof Error ? error.message : String(error),
});

// Graph data key: "graph_data:{graphId}"
const graphKey = (graphId: string): string => `graph_data:${graphId}`;

const loadGraph = (
  storage: GraphStorage,
  graphId: string,
): TE.TaskEither<GraphError, O.Option<GraphData>> =>
  TE.tryCatch(
    async () => {
      const record = await storage.get('graphs', graphKey(graphId));
      return pipe(
        O.fromNullable(record),
        O.map((r) => {
          const nodesArr: readonly string[] = JSON.parse(String(r['nodes'] ?? '[]'));
          const edgesArr: readonly { source: string; target: string }[] = JSON.parse(
            String(r['edges'] ?? '[]'),
          );
          return {
            nodes: new Set(nodesArr),
            edges: edgesArr,
          };
        }),
      );
    },
    makeStorageError,
  );

const saveGraph = (
  storage: GraphStorage,
  graphId: string,
  data: GraphData,
): TE.TaskEither<GraphError, void> =>
  TE.tryCatch(
    async () => {
      await storage.put('graphs', graphKey(graphId), {
        nodes: JSON.stringify(Array.from(data.nodes)),
        edges: JSON.stringify(data.edges),
      });
    },
    makeStorageError,
  );

const ensureGraph = (
  storage: GraphStorage,
  graphId: string,
): TE.TaskEither<GraphError, GraphData> =>
  pipe(
    loadGraph(storage, graphId),
    TE.chain((opt) =>
      pipe(
        opt,
        O.fold(
          () => {
            // Auto-create graph on first use
            const empty: GraphData = { nodes: new Set(), edges: [] };
            return pipe(
              saveGraph(storage, graphId, empty),
              TE.map(() => empty),
            );
          },
          (data) => TE.right<GraphError, GraphData>(data),
        ),
      ),
    ),
  );

// Build adjacency list from edges (undirected)
const buildAdjacency = (
  edges: readonly { readonly source: string; readonly target: string }[],
): ReadonlyMap<string, readonly string[]> => {
  const adj = new Map<string, string[]>();
  for (const edge of edges) {
    const fwd = adj.get(edge.source) ?? [];
    adj.set(edge.source, [...fwd, edge.target]);
    const rev = adj.get(edge.target) ?? [];
    adj.set(edge.target, [...rev, edge.source]);
  }
  return adj;
};

// BFS to find neighbors within a given depth
const bfsNeighbors = (
  start: string,
  adj: ReadonlyMap<string, readonly string[]>,
  maxDepth: number,
): readonly string[] => {
  const visited = new Set<string>();
  const queue: Array<{ readonly node: string; readonly depth: number }> = [
    { node: start, depth: 0 },
  ];
  const result: string[] = [];

  while (queue.length > 0) {
    const { node, depth } = queue.shift()!;
    if (visited.has(node)) continue;
    visited.add(node);

    if (node !== start) result.push(node);

    if (depth < maxDepth) {
      for (const neighbor of adj.get(node) ?? []) {
        if (!visited.has(neighbor)) {
          queue.push({ node: neighbor, depth: depth + 1 });
        }
      }
    }
  }

  return result;
};

// BFS shortest path between two nodes
const bfsShortestPath = (
  start: string,
  end: string,
  adj: ReadonlyMap<string, readonly string[]>,
): O.Option<readonly string[]> => {
  if (start === end) return O.some([start]);

  const visited = new Set<string>();
  const queue: Array<{ readonly node: string; readonly path: readonly string[] }> = [
    { node: start, path: [start] },
  ];

  while (queue.length > 0) {
    const { node, path } = queue.shift()!;
    if (visited.has(node)) continue;
    visited.add(node);

    for (const neighbor of adj.get(node) ?? []) {
      if (neighbor === end) return O.some([...path, neighbor]);
      if (!visited.has(neighbor)) {
        queue.push({ node: neighbor, path: [...path, neighbor] });
      }
    }
  }

  return O.none;
};

// Find connected components using BFS
const findConnectedComponents = (
  nodes: ReadonlySet<string>,
  adj: ReadonlyMap<string, readonly string[]>,
): readonly (readonly string[])[] => {
  const visited = new Set<string>();
  const components: Array<readonly string[]> = [];

  for (const node of nodes) {
    if (visited.has(node)) continue;

    const component: string[] = [];
    const queue: string[] = [node];

    while (queue.length > 0) {
      const current = queue.shift()!;
      if (visited.has(current)) continue;
      visited.add(current);
      component.push(current);

      for (const neighbor of adj.get(current) ?? []) {
        if (!visited.has(neighbor)) queue.push(neighbor);
      }
    }

    components.push(component);
  }

  return components;
};

// --- Implementation ---

export const graphHandler: GraphHandler = {
  addNode: (input, storage) =>
    pipe(
      ensureGraph(storage, input.graph),
      TE.chain((data) => {
        const newNodes = new Set(data.nodes);
        newNodes.add(input.node);
        const updated: GraphData = { nodes: newNodes, edges: data.edges };
        return pipe(
          saveGraph(storage, input.graph, updated),
          TE.map(() => addNodeOk()),
        );
      }),
    ),

  removeNode: (input, storage) =>
    pipe(
      loadGraph(storage, input.graph),
      TE.chain((opt) =>
        pipe(
          opt,
          O.fold(
            () => TE.right<GraphError, GraphRemoveNodeOutput>(removeNodeNotfound()),
            (data) => {
              if (!data.nodes.has(input.node)) {
                return TE.right<GraphError, GraphRemoveNodeOutput>(removeNodeNotfound());
              }

              const newNodes = new Set(data.nodes);
              newNodes.delete(input.node);
              // Remove all edges involving this node
              const newEdges = data.edges.filter(
                (e) => e.source !== input.node && e.target !== input.node,
              );
              const updated: GraphData = { nodes: newNodes, edges: newEdges };

              return pipe(
                saveGraph(storage, input.graph, updated),
                TE.map(() => removeNodeOk()),
              );
            },
          ),
        ),
      ),
    ),

  addEdge: (input, storage) =>
    pipe(
      loadGraph(storage, input.graph),
      TE.chain((opt) =>
        pipe(
          opt,
          O.fold(
            () => TE.right<GraphError, GraphAddEdgeOutput>(addEdgeNotfound()),
            (data) => {
              if (!data.nodes.has(input.source) || !data.nodes.has(input.target)) {
                return TE.right<GraphError, GraphAddEdgeOutput>(addEdgeNotfound());
              }

              // Check if edge already exists
              const exists = data.edges.some(
                (e) => e.source === input.source && e.target === input.target,
              );
              if (exists) {
                return TE.right<GraphError, GraphAddEdgeOutput>(addEdgeOk());
              }

              const newEdges = [...data.edges, { source: input.source, target: input.target }];
              const updated: GraphData = { nodes: data.nodes, edges: newEdges };

              return pipe(
                saveGraph(storage, input.graph, updated),
                TE.map(() => addEdgeOk()),
              );
            },
          ),
        ),
      ),
    ),

  removeEdge: (input, storage) =>
    pipe(
      loadGraph(storage, input.graph),
      TE.chain((opt) =>
        pipe(
          opt,
          O.fold(
            () => TE.right<GraphError, GraphRemoveEdgeOutput>(removeEdgeNotfound()),
            (data) => {
              const edgeIndex = data.edges.findIndex(
                (e) => e.source === input.source && e.target === input.target,
              );
              if (edgeIndex === -1) {
                return TE.right<GraphError, GraphRemoveEdgeOutput>(removeEdgeNotfound());
              }

              const newEdges = data.edges.filter((_, i) => i !== edgeIndex);
              const updated: GraphData = { nodes: data.nodes, edges: newEdges };

              return pipe(
                saveGraph(storage, input.graph, updated),
                TE.map(() => removeEdgeOk()),
              );
            },
          ),
        ),
      ),
    ),

  getNeighbors: (input, storage) =>
    pipe(
      loadGraph(storage, input.graph),
      TE.chain((opt) =>
        pipe(
          opt,
          O.fold(
            () => TE.right<GraphError, GraphGetNeighborsOutput>(getNeighborsNotfound()),
            (data) => {
              if (!data.nodes.has(input.node)) {
                return TE.right<GraphError, GraphGetNeighborsOutput>(getNeighborsNotfound());
              }

              const adj = buildAdjacency(data.edges);
              const depth = Math.max(1, input.depth);
              const neighbors = bfsNeighbors(input.node, adj, depth);

              return TE.right<GraphError, GraphGetNeighborsOutput>(
                getNeighborsOk(JSON.stringify(neighbors)),
              );
            },
          ),
        ),
      ),
    ),

  filterNodes: (input, storage) =>
    pipe(
      loadGraph(storage, input.graph),
      TE.chain((opt) =>
        pipe(
          opt,
          O.fold(
            () => TE.right<GraphError, GraphFilterNodesOutput>(filterNodesNotfound()),
            (data) => {
              // Parse filter as JSON object with optional criteria
              // Supported filter shapes:
              // - { "pattern": "regex" } - match node names
              // - { "prefix": "str" } - match by prefix
              // - { "connected_to": "node" } - nodes connected to a specific node
              // - { "component": "node" } - all nodes in the same connected component
              // - { "has_edges": true } - nodes that have at least one edge
              let filter: Record<string, unknown>;
              try {
                filter = JSON.parse(input.filter);
              } catch {
                // Treat as a simple substring filter
                filter = { pattern: input.filter };
              }

              const allNodes = Array.from(data.nodes);
              let filtered: readonly string[];

              if (typeof filter['pattern'] === 'string') {
                const regex = new RegExp(filter['pattern'] as string, 'i');
                filtered = allNodes.filter((n) => regex.test(n));
              } else if (typeof filter['prefix'] === 'string') {
                const prefix = filter['prefix'] as string;
                filtered = allNodes.filter((n) => n.startsWith(prefix));
              } else if (typeof filter['connected_to'] === 'string') {
                const target = filter['connected_to'] as string;
                const adj = buildAdjacency(data.edges);
                const neighbors = new Set(bfsNeighbors(target, adj, Infinity));
                filtered = allNodes.filter((n) => neighbors.has(n));
              } else if (typeof filter['component'] === 'string') {
                const target = filter['component'] as string;
                const adj = buildAdjacency(data.edges);
                const components = findConnectedComponents(data.nodes, adj);
                const targetComponent = components.find((c) => c.includes(target));
                filtered = targetComponent ?? [];
              } else if (filter['has_edges'] === true) {
                const nodesWithEdges = new Set<string>();
                for (const edge of data.edges) {
                  nodesWithEdges.add(edge.source);
                  nodesWithEdges.add(edge.target);
                }
                filtered = allNodes.filter((n) => nodesWithEdges.has(n));
              } else {
                filtered = allNodes;
              }

              return TE.right<GraphError, GraphFilterNodesOutput>(
                filterNodesOk(JSON.stringify(filtered)),
              );
            },
          ),
        ),
      ),
    ),
};
