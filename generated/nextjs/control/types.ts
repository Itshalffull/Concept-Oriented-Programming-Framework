// Control â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

// Storage interface for Control
export interface ControlStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface ControlCreateInput {
  readonly control: string;
  readonly type: string;
  readonly binding: string;
}

export interface ControlCreateOutputOk {
  readonly variant: 'ok';
}

export interface ControlCreateOutputExists {
  readonly variant: 'exists';
  readonly message: string;
}

export type ControlCreateOutput = ControlCreateOutputOk | ControlCreateOutputExists;

export interface ControlInteractInput {
  readonly control: string;
  readonly input: string;
}

export interface ControlInteractOutputOk {
  readonly variant: 'ok';
  readonly result: string;
}

export interface ControlInteractOutputNotfound {
  readonly variant: 'notfound';
  readonly message: string;
}

export type ControlInteractOutput = ControlInteractOutputOk | ControlInteractOutputNotfound;

export interface ControlGetValueInput {
  readonly control: string;
}

export interface ControlGetValueOutputOk {
  readonly variant: 'ok';
  readonly value: string;
}

export interface ControlGetValueOutputNotfound {
  readonly variant: 'notfound';
  readonly message: string;
}

export type ControlGetValueOutput = ControlGetValueOutputOk | ControlGetValueOutputNotfound;

export interface ControlSetValueInput {
  readonly control: string;
  readonly value: string;
}

export interface ControlSetValueOutputOk {
  readonly variant: 'ok';
}

export interface ControlSetValueOutputNotfound {
  readonly variant: 'notfound';
  readonly message: string;
}

export type ControlSetValueOutput = ControlSetValueOutputOk | ControlSetValueOutputNotfound;

export interface ControlTriggerActionInput {
  readonly control: string;
}

export interface ControlTriggerActionOutputOk {
  readonly variant: 'ok';
  readonly result: string;
}

export interface ControlTriggerActionOutputNotfound {
  readonly variant: 'notfound';
  readonly message: string;
}

export type ControlTriggerActionOutput = ControlTriggerActionOutputOk | ControlTriggerActionOutputNotfound;

// --- Variant constructors ---

export const createOk = (): ControlCreateOutput => ({ variant: 'ok' } as ControlCreateOutput);
export const createExists = (message: string): ControlCreateOutput => ({ variant: 'exists', message } as ControlCreateOutput);

export const interactOk = (result: string): ControlInteractOutput => ({ variant: 'ok', result } as ControlInteractOutput);
export const interactNotfound = (message: string): ControlInteractOutput => ({ variant: 'notfound', message } as ControlInteractOutput);

export const getValueOk = (value: string): ControlGetValueOutput => ({ variant: 'ok', value } as ControlGetValueOutput);
export const getValueNotfound = (message: string): ControlGetValueOutput => ({ variant: 'notfound', message } as ControlGetValueOutput);

export const setValueOk = (): ControlSetValueOutput => ({ variant: 'ok' } as ControlSetValueOutput);
export const setValueNotfound = (message: string): ControlSetValueOutput => ({ variant: 'notfound', message } as ControlSetValueOutput);

export const triggerActionOk = (result: string): ControlTriggerActionOutput => ({ variant: 'ok', result } as ControlTriggerActionOutput);
export const triggerActionNotfound = (message: string): ControlTriggerActionOutput => ({ variant: 'notfound', message } as ControlTriggerActionOutput);

