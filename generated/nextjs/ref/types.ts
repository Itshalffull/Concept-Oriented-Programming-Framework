// Ref â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

// Storage interface for Ref
export interface RefStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface RefCreateInput {
  readonly name: string;
  readonly hash: string;
}

export interface RefCreateOutputOk {
  readonly variant: 'ok';
  readonly ref: string;
}

export interface RefCreateOutputExists {
  readonly variant: 'exists';
  readonly message: string;
}

export interface RefCreateOutputInvalidHash {
  readonly variant: 'invalidHash';
  readonly message: string;
}

export type RefCreateOutput = RefCreateOutputOk | RefCreateOutputExists | RefCreateOutputInvalidHash;

export interface RefUpdateInput {
  readonly name: string;
  readonly newHash: string;
  readonly expectedOldHash: string;
}

export interface RefUpdateOutputOk {
  readonly variant: 'ok';
}

export interface RefUpdateOutputNotFound {
  readonly variant: 'notFound';
  readonly message: string;
}

export interface RefUpdateOutputConflict {
  readonly variant: 'conflict';
  readonly current: string;
}

export type RefUpdateOutput = RefUpdateOutputOk | RefUpdateOutputNotFound | RefUpdateOutputConflict;

export interface RefDeleteInput {
  readonly name: string;
}

export interface RefDeleteOutputOk {
  readonly variant: 'ok';
}

export interface RefDeleteOutputNotFound {
  readonly variant: 'notFound';
  readonly message: string;
}

export interface RefDeleteOutputProtected {
  readonly variant: 'protected';
  readonly message: string;
}

export type RefDeleteOutput = RefDeleteOutputOk | RefDeleteOutputNotFound | RefDeleteOutputProtected;

export interface RefResolveInput {
  readonly name: string;
}

export interface RefResolveOutputOk {
  readonly variant: 'ok';
  readonly hash: string;
}

export interface RefResolveOutputNotFound {
  readonly variant: 'notFound';
  readonly message: string;
}

export type RefResolveOutput = RefResolveOutputOk | RefResolveOutputNotFound;

export interface RefLogInput {
  readonly name: string;
}

export interface RefLogOutputOk {
  readonly variant: 'ok';
  readonly entries: readonly { readonly oldHash: string; readonly newHash: string; readonly timestamp: string; readonly agent: string }[];
}

export interface RefLogOutputNotFound {
  readonly variant: 'notFound';
  readonly message: string;
}

export type RefLogOutput = RefLogOutputOk | RefLogOutputNotFound;

// --- Variant constructors ---

export const createOk = (ref: string): RefCreateOutput => ({ variant: 'ok', ref } as RefCreateOutput);
export const createExists = (message: string): RefCreateOutput => ({ variant: 'exists', message } as RefCreateOutput);
export const createInvalidHash = (message: string): RefCreateOutput => ({ variant: 'invalidHash', message } as RefCreateOutput);

export const updateOk = (): RefUpdateOutput => ({ variant: 'ok' } as RefUpdateOutput);
export const updateNotFound = (message: string): RefUpdateOutput => ({ variant: 'notFound', message } as RefUpdateOutput);
export const updateConflict = (current: string): RefUpdateOutput => ({ variant: 'conflict', current } as RefUpdateOutput);

export const deleteOk = (): RefDeleteOutput => ({ variant: 'ok' } as RefDeleteOutput);
export const deleteNotFound = (message: string): RefDeleteOutput => ({ variant: 'notFound', message } as RefDeleteOutput);
export const deleteProtected = (message: string): RefDeleteOutput => ({ variant: 'protected', message } as RefDeleteOutput);

export const resolveOk = (hash: string): RefResolveOutput => ({ variant: 'ok', hash } as RefResolveOutput);
export const resolveNotFound = (message: string): RefResolveOutput => ({ variant: 'notFound', message } as RefResolveOutput);

export const logOk = (entries: readonly { readonly oldHash: string; readonly newHash: string; readonly timestamp: string; readonly agent: string }[]): RefLogOutput => ({ variant: 'ok', entries } as RefLogOutput);
export const logNotFound = (message: string): RefLogOutput => ({ variant: 'notFound', message } as RefLogOutput);

