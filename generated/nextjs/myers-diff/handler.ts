// MyersDiff â€” handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.
//
// Implements Myers' O(ND) difference algorithm (Eugene W. Myers, 1986).
// Finds the shortest edit script between two sequences by exploring
// the edit graph diagonally, preferring deletions before insertions.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe, identity } from 'fp-ts/function';

import type {
  MyersDiffStorage,
  MyersDiffRegisterInput,
  MyersDiffRegisterOutput,
  MyersDiffComputeInput,
  MyersDiffComputeOutput,
} from './types.js';

import {
  registerOk,
  computeOk,
  computeUnsupportedContent,
} from './types.js';

export interface MyersDiffError {
  readonly code: string;
  readonly message: string;
}

export interface MyersDiffHandler {
  readonly register: (
    input: MyersDiffRegisterInput,
    storage: MyersDiffStorage,
  ) => TE.TaskEither<MyersDiffError, MyersDiffRegisterOutput>;
  readonly compute: (
    input: MyersDiffComputeInput,
    storage: MyersDiffStorage,
  ) => TE.TaskEither<MyersDiffError, MyersDiffComputeOutput>;
}

// --- Edit operation types ---

type EditOp =
  | { readonly type: 'keep'; readonly line: string }
  | { readonly type: 'insert'; readonly line: string }
  | { readonly type: 'delete'; readonly line: string };

// --- Pure helper functions ---

const splitLines = (buf: Buffer): readonly string[] =>
  buf.toString('utf-8').split('\n');

const serializeEditScript = (ops: readonly EditOp[]): Buffer =>
  Buffer.from(
    JSON.stringify(ops.map(op => ({ t: op.type[0], l: op.line }))),
    'utf-8',
  );

/**
 * Myers' O(ND) shortest edit script algorithm.
 *
 * Explores the edit graph by increasing edit distance d = 0, 1, 2, ...
 * For each d, explores diagonals k = -d, -d+2, ..., d.
 * The V array stores the furthest-reaching x on each diagonal k.
 * We record the full V snapshot per d-step to backtrack the path.
 */
const myersDiff = (
  a: readonly string[],
  b: readonly string[],
): E.Either<MyersDiffError, { readonly ops: readonly EditOp[]; readonly distance: number }> => {
  const n = a.length;
  const m = b.length;
  const max = n + m;

  // V[k + offset] = furthest x on diagonal k
  // Diagonal k means x - y = k, so y = x - k
  const offset = max;
  const vSize = 2 * max + 1;

  // Store snapshots of V for backtracking
  const trace: readonly number[][] = [];

  const v = new Array<number>(vSize).fill(0);
  v[1 + offset] = 0;

  let found = false;
  let finalD = 0;

  outer:
  for (let d = 0; d <= max; d++) {
    // Snapshot current V before mutation
    trace.push([...v]);

    for (let k = -d; k <= d; k += 2) {
      // Decide: move down (insert) or right (delete)
      // Move down if k === -d, or if k !== d and the downward path is further
      let x: number;
      if (k === -d || (k !== d && v[k - 1 + offset] < v[k + 1 + offset])) {
        x = v[k + 1 + offset]; // move down: x stays, y increases
      } else {
        x = v[k - 1 + offset] + 1; // move right: x increases
      }

      let y = x - k;

      // Follow the diagonal (matching elements)
      while (x < n && y < m && a[x] === b[y]) {
        x++;
        y++;
      }

      v[k + offset] = x;

      if (x >= n && y >= m) {
        finalD = d;
        found = true;
        // Save the final V snapshot
        trace.push([...v]);
        break outer;
      }
    }
  }

  if (!found && max > 0) {
    return E.left({
      code: 'DIFF_FAILED',
      message: `Myers algorithm did not converge within max=${max} steps`,
    });
  }

  // Backtrack to reconstruct the edit script
  const ops: EditOp[] = [];
  let x = n;
  let y = m;

  for (let d = finalD; d > 0; d--) {
    const prevV = trace[d - 1];
    // On diagonal k at step d, we got here from step d-1
    const k = x - y;

    let prevK: number;
    if (k === -d || (k !== d && prevV[k - 1 + offset] < prevV[k + 1 + offset])) {
      prevK = k + 1; // came from above (insert)
    } else {
      prevK = k - 1; // came from left (delete)
    }

    const prevX = prevV[prevK + offset];
    const prevY = prevX - prevK;

    // Diagonal moves (keeps) from (prevX, prevY) to just before (x, y) adjusted
    while (x > prevX && y > prevY) {
      x--;
      y--;
      ops.push({ type: 'keep', line: a[x] });
    }

    if (d > 0) {
      if (x === prevX) {
        // Insert: y decreased
        y--;
        ops.push({ type: 'insert', line: b[y] });
      } else {
        // Delete: x decreased
        x--;
        ops.push({ type: 'delete', line: a[x] });
      }
    }
  }

  // Any remaining diagonal at d=0
  while (x > 0 && y > 0) {
    x--;
    y--;
    ops.push({ type: 'keep', line: a[x] });
  }

  ops.reverse();

  return E.right({ ops, distance: finalD });
};

// --- Implementation ---

export const myersDiffHandler: MyersDiffHandler = {
  register: (_input, _storage) =>
    TE.right(
      registerOk('myers', 'diff', ['text/plain', 'text/*', 'application/octet-stream']),
    ),

  compute: (input, _storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const linesA = splitLines(input.contentA);
          const linesB = splitLines(input.contentB);
          return { linesA, linesB };
        },
        (error): MyersDiffError => ({
          code: 'DECODE_ERROR',
          message: `Failed to decode input buffers: ${error instanceof Error ? error.message : String(error)}`,
        }),
      ),
      TE.chain(({ linesA, linesB }) =>
        pipe(
          myersDiff(linesA, linesB),
          E.fold(
            (err) => TE.left(err),
            ({ ops, distance }) =>
              TE.right(computeOk(serializeEditScript(ops), distance)),
          ),
        ),
      ),
    ),
};
