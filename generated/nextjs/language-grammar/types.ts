// LanguageGrammar â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

// Storage interface for LanguageGrammar
export interface LanguageGrammarStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface LanguageGrammarRegisterInput {
  readonly name: string;
  readonly extensions: string;
  readonly parserWasmPath: string;
  readonly nodeTypes: string;
}

export interface LanguageGrammarRegisterOutputOk {
  readonly variant: 'ok';
  readonly grammar: string;
}

export interface LanguageGrammarRegisterOutputAlreadyRegistered {
  readonly variant: 'alreadyRegistered';
  readonly existing: string;
}

export type LanguageGrammarRegisterOutput = LanguageGrammarRegisterOutputOk | LanguageGrammarRegisterOutputAlreadyRegistered;

export interface LanguageGrammarResolveInput {
  readonly fileExtension: string;
}

export interface LanguageGrammarResolveOutputOk {
  readonly variant: 'ok';
  readonly grammar: string;
}

export interface LanguageGrammarResolveOutputNoGrammar {
  readonly variant: 'noGrammar';
  readonly extension: string;
}

export type LanguageGrammarResolveOutput = LanguageGrammarResolveOutputOk | LanguageGrammarResolveOutputNoGrammar;

export interface LanguageGrammarResolveByMimeInput {
  readonly mimeType: string;
}

export interface LanguageGrammarResolveByMimeOutputOk {
  readonly variant: 'ok';
  readonly grammar: string;
}

export interface LanguageGrammarResolveByMimeOutputNoGrammar {
  readonly variant: 'noGrammar';
  readonly mimeType: string;
}

export type LanguageGrammarResolveByMimeOutput = LanguageGrammarResolveByMimeOutputOk | LanguageGrammarResolveByMimeOutputNoGrammar;

export interface LanguageGrammarGetInput {
  readonly grammar: string;
}

export interface LanguageGrammarGetOutputOk {
  readonly variant: 'ok';
  readonly grammar: string;
  readonly name: string;
  readonly extensions: string;
  readonly parserWasmPath: string;
}

export interface LanguageGrammarGetOutputNotfound {
  readonly variant: 'notfound';
  readonly message: string;
}

export type LanguageGrammarGetOutput = LanguageGrammarGetOutputOk | LanguageGrammarGetOutputNotfound;

export interface LanguageGrammarListInput {
}

export interface LanguageGrammarListOutput {
  readonly variant: 'ok';
  readonly grammars: string;
}

// --- Variant constructors ---

export const registerOk = (grammar: string): LanguageGrammarRegisterOutput => ({ variant: 'ok', grammar } as LanguageGrammarRegisterOutput);
export const registerAlreadyRegistered = (existing: string): LanguageGrammarRegisterOutput => ({ variant: 'alreadyRegistered', existing } as LanguageGrammarRegisterOutput);

export const resolveOk = (grammar: string): LanguageGrammarResolveOutput => ({ variant: 'ok', grammar } as LanguageGrammarResolveOutput);
export const resolveNoGrammar = (extension: string): LanguageGrammarResolveOutput => ({ variant: 'noGrammar', extension } as LanguageGrammarResolveOutput);

export const resolveByMimeOk = (grammar: string): LanguageGrammarResolveByMimeOutput => ({ variant: 'ok', grammar } as LanguageGrammarResolveByMimeOutput);
export const resolveByMimeNoGrammar = (mimeType: string): LanguageGrammarResolveByMimeOutput => ({ variant: 'noGrammar', mimeType } as LanguageGrammarResolveByMimeOutput);

export const getOk = (grammar: string, name: string, extensions: string, parserWasmPath: string): LanguageGrammarGetOutput => ({ variant: 'ok', grammar, name, extensions, parserWasmPath } as LanguageGrammarGetOutput);
export const getNotfound = (message: string): LanguageGrammarGetOutput => ({ variant: 'notfound', message } as LanguageGrammarGetOutput);

export const listOk = (grammars: string): LanguageGrammarListOutput => ({ variant: 'ok', grammars } as LanguageGrammarListOutput);

