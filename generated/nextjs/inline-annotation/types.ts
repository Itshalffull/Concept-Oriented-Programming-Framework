// InlineAnnotation â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

// Storage interface for InlineAnnotation
export interface InlineAnnotationStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface InlineAnnotationAnnotateInput {
  readonly contentRef: string;
  readonly changeType: string;
  readonly scope: Buffer;
  readonly author: string;
}

export interface InlineAnnotationAnnotateOutputOk {
  readonly variant: 'ok';
  readonly annotationId: string;
}

export interface InlineAnnotationAnnotateOutputTrackingDisabled {
  readonly variant: 'trackingDisabled';
  readonly message: string;
}

export interface InlineAnnotationAnnotateOutputInvalidChangeType {
  readonly variant: 'invalidChangeType';
  readonly message: string;
}

export type InlineAnnotationAnnotateOutput = InlineAnnotationAnnotateOutputOk | InlineAnnotationAnnotateOutputTrackingDisabled | InlineAnnotationAnnotateOutputInvalidChangeType;

export interface InlineAnnotationAcceptInput {
  readonly annotationId: string;
}

export interface InlineAnnotationAcceptOutputOk {
  readonly variant: 'ok';
  readonly cleanContent: Buffer;
}

export interface InlineAnnotationAcceptOutputNotFound {
  readonly variant: 'notFound';
  readonly message: string;
}

export interface InlineAnnotationAcceptOutputAlreadyResolved {
  readonly variant: 'alreadyResolved';
  readonly message: string;
}

export type InlineAnnotationAcceptOutput = InlineAnnotationAcceptOutputOk | InlineAnnotationAcceptOutputNotFound | InlineAnnotationAcceptOutputAlreadyResolved;

export interface InlineAnnotationRejectInput {
  readonly annotationId: string;
}

export interface InlineAnnotationRejectOutputOk {
  readonly variant: 'ok';
  readonly cleanContent: Buffer;
}

export interface InlineAnnotationRejectOutputNotFound {
  readonly variant: 'notFound';
  readonly message: string;
}

export interface InlineAnnotationRejectOutputAlreadyResolved {
  readonly variant: 'alreadyResolved';
  readonly message: string;
}

export type InlineAnnotationRejectOutput = InlineAnnotationRejectOutputOk | InlineAnnotationRejectOutputNotFound | InlineAnnotationRejectOutputAlreadyResolved;

export interface InlineAnnotationAcceptAllInput {
  readonly contentRef: string;
}

export interface InlineAnnotationAcceptAllOutput {
  readonly variant: 'ok';
  readonly cleanContent: Buffer;
  readonly count: number;
}

export interface InlineAnnotationRejectAllInput {
  readonly contentRef: string;
}

export interface InlineAnnotationRejectAllOutput {
  readonly variant: 'ok';
  readonly cleanContent: Buffer;
  readonly count: number;
}

export interface InlineAnnotationToggleTrackingInput {
  readonly contentRef: string;
  readonly enabled: boolean;
}

export interface InlineAnnotationToggleTrackingOutput {
  readonly variant: 'ok';
}

export interface InlineAnnotationListPendingInput {
  readonly contentRef: string;
}

export interface InlineAnnotationListPendingOutput {
  readonly variant: 'ok';
  readonly annotations: readonly string[];
}

// --- Variant constructors ---

export const annotateOk = (annotationId: string): InlineAnnotationAnnotateOutput => ({ variant: 'ok', annotationId } as InlineAnnotationAnnotateOutput);
export const annotateTrackingDisabled = (message: string): InlineAnnotationAnnotateOutput => ({ variant: 'trackingDisabled', message } as InlineAnnotationAnnotateOutput);
export const annotateInvalidChangeType = (message: string): InlineAnnotationAnnotateOutput => ({ variant: 'invalidChangeType', message } as InlineAnnotationAnnotateOutput);

export const acceptOk = (cleanContent: Buffer): InlineAnnotationAcceptOutput => ({ variant: 'ok', cleanContent } as InlineAnnotationAcceptOutput);
export const acceptNotFound = (message: string): InlineAnnotationAcceptOutput => ({ variant: 'notFound', message } as InlineAnnotationAcceptOutput);
export const acceptAlreadyResolved = (message: string): InlineAnnotationAcceptOutput => ({ variant: 'alreadyResolved', message } as InlineAnnotationAcceptOutput);

export const rejectOk = (cleanContent: Buffer): InlineAnnotationRejectOutput => ({ variant: 'ok', cleanContent } as InlineAnnotationRejectOutput);
export const rejectNotFound = (message: string): InlineAnnotationRejectOutput => ({ variant: 'notFound', message } as InlineAnnotationRejectOutput);
export const rejectAlreadyResolved = (message: string): InlineAnnotationRejectOutput => ({ variant: 'alreadyResolved', message } as InlineAnnotationRejectOutput);

export const acceptAllOk = (cleanContent: Buffer, count: number): InlineAnnotationAcceptAllOutput => ({ variant: 'ok', cleanContent, count } as InlineAnnotationAcceptAllOutput);

export const rejectAllOk = (cleanContent: Buffer, count: number): InlineAnnotationRejectAllOutput => ({ variant: 'ok', cleanContent, count } as InlineAnnotationRejectAllOutput);

export const toggleTrackingOk = (): InlineAnnotationToggleTrackingOutput => ({ variant: 'ok' } as InlineAnnotationToggleTrackingOutput);

export const listPendingOk = (annotations: readonly string[]): InlineAnnotationListPendingOutput => ({ variant: 'ok', annotations } as InlineAnnotationListPendingOutput);

