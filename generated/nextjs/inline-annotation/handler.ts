// InlineAnnotation — handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  InlineAnnotationStorage,
  InlineAnnotationAnnotateInput,
  InlineAnnotationAnnotateOutput,
  InlineAnnotationAcceptInput,
  InlineAnnotationAcceptOutput,
  InlineAnnotationRejectInput,
  InlineAnnotationRejectOutput,
  InlineAnnotationAcceptAllInput,
  InlineAnnotationAcceptAllOutput,
  InlineAnnotationRejectAllInput,
  InlineAnnotationRejectAllOutput,
  InlineAnnotationToggleTrackingInput,
  InlineAnnotationToggleTrackingOutput,
  InlineAnnotationListPendingInput,
  InlineAnnotationListPendingOutput,
} from './types.js';

import {
  annotateOk,
  annotateTrackingDisabled,
  annotateInvalidChangeType,
  acceptOk,
  acceptNotFound,
  acceptAlreadyResolved,
  rejectOk,
  rejectNotFound,
  rejectAlreadyResolved,
  acceptAllOk,
  rejectAllOk,
  toggleTrackingOk,
  listPendingOk,
} from './types.js';

export interface InlineAnnotationError {
  readonly code: string;
  readonly message: string;
}

export interface InlineAnnotationHandler {
  readonly annotate: (
    input: InlineAnnotationAnnotateInput,
    storage: InlineAnnotationStorage,
  ) => TE.TaskEither<InlineAnnotationError, InlineAnnotationAnnotateOutput>;
  readonly accept: (
    input: InlineAnnotationAcceptInput,
    storage: InlineAnnotationStorage,
  ) => TE.TaskEither<InlineAnnotationError, InlineAnnotationAcceptOutput>;
  readonly reject: (
    input: InlineAnnotationRejectInput,
    storage: InlineAnnotationStorage,
  ) => TE.TaskEither<InlineAnnotationError, InlineAnnotationRejectOutput>;
  readonly acceptAll: (
    input: InlineAnnotationAcceptAllInput,
    storage: InlineAnnotationStorage,
  ) => TE.TaskEither<InlineAnnotationError, InlineAnnotationAcceptAllOutput>;
  readonly rejectAll: (
    input: InlineAnnotationRejectAllInput,
    storage: InlineAnnotationStorage,
  ) => TE.TaskEither<InlineAnnotationError, InlineAnnotationRejectAllOutput>;
  readonly toggleTracking: (
    input: InlineAnnotationToggleTrackingInput,
    storage: InlineAnnotationStorage,
  ) => TE.TaskEither<InlineAnnotationError, InlineAnnotationToggleTrackingOutput>;
  readonly listPending: (
    input: InlineAnnotationListPendingInput,
    storage: InlineAnnotationStorage,
  ) => TE.TaskEither<InlineAnnotationError, InlineAnnotationListPendingOutput>;
}

// --- Helpers ---

const storageError = (error: unknown): InlineAnnotationError => ({
  code: 'STORAGE_ERROR',
  message: error instanceof Error ? error.message : String(error),
});

const VALID_CHANGE_TYPES: ReadonlySet<string> = new Set([
  'insertion',
  'deletion',
  'formatting',
  'move',
]);

const generateAnnotationId = (): string =>
  `ann_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;

/** Check whether tracking is enabled for a given contentRef. Default is true. */
const isTrackingEnabled = async (
  storage: InlineAnnotationStorage,
  contentRef: string,
): Promise<boolean> => {
  const record = await storage.get('tracking', contentRef);
  return pipe(
    O.fromNullable(record),
    O.fold(
      () => true, // Default: tracking enabled
      (r) => r['enabled'] !== false,
    ),
  );
};

/** Retrieve all annotations for a given contentRef with a specific status. */
const findAnnotationsByStatus = async (
  storage: InlineAnnotationStorage,
  contentRef: string,
  status: string,
): Promise<readonly Record<string, unknown>[]> => {
  const all = await storage.find('annotations', { contentRef, status });
  return all;
};

// --- Implementation ---

export const inlineAnnotationHandler: InlineAnnotationHandler = {
  annotate: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          // Validate changeType
          if (!VALID_CHANGE_TYPES.has(input.changeType)) {
            return annotateInvalidChangeType(
              `changeType "${input.changeType}" is not valid. Must be one of: insertion, deletion, formatting, move`,
            );
          }

          // Check if tracking is enabled for this content
          const trackingEnabled = await isTrackingEnabled(storage, input.contentRef);
          if (!trackingEnabled) {
            return annotateTrackingDisabled(
              `Tracking is disabled for document "${input.contentRef}"`,
            );
          }

          const annotationId = generateAnnotationId();
          await storage.put('annotations', annotationId, {
            id: annotationId,
            contentRef: input.contentRef,
            changeType: input.changeType,
            scope: input.scope.toString('base64'),
            author: input.author,
            timestamp: new Date().toISOString(),
            status: 'pending',
          });

          return annotateOk(annotationId);
        },
        storageError,
      ),
    ),

  accept: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const record = await storage.get('annotations', input.annotationId);
          return pipe(
            O.fromNullable(record),
            O.fold(
              async () =>
                acceptNotFound(
                  `Annotation "${input.annotationId}" not found`,
                ),
              async (ann) => {
                const status = ann['status'] as string;
                if (status !== 'pending') {
                  return acceptAlreadyResolved(
                    `Annotation "${input.annotationId}" is already ${status}`,
                  );
                }

                // Accept: keep the change content, remove the annotation wrapper
                await storage.put('annotations', input.annotationId, {
                  ...ann,
                  status: 'accepted',
                  resolvedAt: new Date().toISOString(),
                });

                // Return the scope content as the "clean" content — the change
                // that was accepted is now part of the document
                const scope = ann['scope'] as string;
                const cleanContent = Buffer.from(scope, 'base64');
                return acceptOk(cleanContent);
              },
            ),
          );
        },
        storageError,
      ),
      TE.flatten,
    ),

  reject: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const record = await storage.get('annotations', input.annotationId);
          return pipe(
            O.fromNullable(record),
            O.fold(
              async () =>
                rejectNotFound(
                  `Annotation "${input.annotationId}" not found`,
                ),
              async (ann) => {
                const status = ann['status'] as string;
                if (status !== 'pending') {
                  return rejectAlreadyResolved(
                    `Annotation "${input.annotationId}" is already ${status}`,
                  );
                }

                // Reject: remove both the annotation wrapper and the change content
                await storage.put('annotations', input.annotationId, {
                  ...ann,
                  status: 'rejected',
                  resolvedAt: new Date().toISOString(),
                });

                // Clean content after rejection is empty — the change was removed
                return rejectOk(Buffer.alloc(0));
              },
            ),
          );
        },
        storageError,
      ),
      TE.flatten,
    ),

  acceptAll: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const pending = await findAnnotationsByStatus(
            storage,
            input.contentRef,
            'pending',
          );

          const scopeParts: Buffer[] = [];

          for (const ann of pending) {
            await storage.put('annotations', ann['id'] as string, {
              ...ann,
              status: 'accepted',
              resolvedAt: new Date().toISOString(),
            });
            const scope = ann['scope'] as string;
            scopeParts.push(Buffer.from(scope, 'base64'));
          }

          // Clean content is the concatenation of all accepted scopes
          const cleanContent = Buffer.concat(scopeParts);
          return acceptAllOk(cleanContent, pending.length);
        },
        storageError,
      ),
    ),

  rejectAll: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const pending = await findAnnotationsByStatus(
            storage,
            input.contentRef,
            'pending',
          );

          for (const ann of pending) {
            await storage.put('annotations', ann['id'] as string, {
              ...ann,
              status: 'rejected',
              resolvedAt: new Date().toISOString(),
            });
          }

          // All changes rejected — document returns to pre-annotation state
          return rejectAllOk(Buffer.alloc(0), pending.length);
        },
        storageError,
      ),
    ),

  toggleTracking: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          await storage.put('tracking', input.contentRef, {
            contentRef: input.contentRef,
            enabled: input.enabled,
          });
          return toggleTrackingOk();
        },
        storageError,
      ),
    ),

  listPending: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const pending = await findAnnotationsByStatus(
            storage,
            input.contentRef,
            'pending',
          );
          const ids = pending.map((ann) => ann['id'] as string);
          return listPendingOk(ids);
        },
        storageError,
      ),
    ),
};
