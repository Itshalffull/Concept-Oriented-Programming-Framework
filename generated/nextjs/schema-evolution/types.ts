// SchemaEvolution â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

// Storage interface for SchemaEvolution
export interface SchemaEvolutionStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface SchemaEvolutionRegisterInput {
  readonly subject: string;
  readonly schema: Buffer;
  readonly compatibility: string;
}

export interface SchemaEvolutionRegisterOutputOk {
  readonly variant: 'ok';
  readonly version: number;
  readonly schemaId: string;
}

export interface SchemaEvolutionRegisterOutputIncompatible {
  readonly variant: 'incompatible';
  readonly reasons: readonly string[];
}

export interface SchemaEvolutionRegisterOutputInvalidCompatibility {
  readonly variant: 'invalidCompatibility';
  readonly message: string;
}

export type SchemaEvolutionRegisterOutput = SchemaEvolutionRegisterOutputOk | SchemaEvolutionRegisterOutputIncompatible | SchemaEvolutionRegisterOutputInvalidCompatibility;

export interface SchemaEvolutionCheckInput {
  readonly oldSchema: Buffer;
  readonly newSchema: Buffer;
  readonly mode: string;
}

export interface SchemaEvolutionCheckOutputCompatible {
  readonly variant: 'compatible';
}

export interface SchemaEvolutionCheckOutputIncompatible {
  readonly variant: 'incompatible';
  readonly reasons: readonly string[];
}

export type SchemaEvolutionCheckOutput = SchemaEvolutionCheckOutputCompatible | SchemaEvolutionCheckOutputIncompatible;

export interface SchemaEvolutionUpcastInput {
  readonly data: Buffer;
  readonly fromVersion: number;
  readonly toVersion: number;
  readonly subject: string;
}

export interface SchemaEvolutionUpcastOutputOk {
  readonly variant: 'ok';
  readonly transformed: Buffer;
}

export interface SchemaEvolutionUpcastOutputNoPath {
  readonly variant: 'noPath';
  readonly message: string;
}

export interface SchemaEvolutionUpcastOutputNotFound {
  readonly variant: 'notFound';
  readonly message: string;
}

export type SchemaEvolutionUpcastOutput = SchemaEvolutionUpcastOutputOk | SchemaEvolutionUpcastOutputNoPath | SchemaEvolutionUpcastOutputNotFound;

export interface SchemaEvolutionResolveInput {
  readonly readerSchema: Buffer;
  readonly writerSchema: Buffer;
}

export interface SchemaEvolutionResolveOutputOk {
  readonly variant: 'ok';
  readonly resolved: Buffer;
}

export interface SchemaEvolutionResolveOutputIncompatible {
  readonly variant: 'incompatible';
  readonly reasons: readonly string[];
}

export type SchemaEvolutionResolveOutput = SchemaEvolutionResolveOutputOk | SchemaEvolutionResolveOutputIncompatible;

export interface SchemaEvolutionGetSchemaInput {
  readonly subject: string;
  readonly version: number;
}

export interface SchemaEvolutionGetSchemaOutputOk {
  readonly variant: 'ok';
  readonly schema: Buffer;
  readonly compatibility: string;
}

export interface SchemaEvolutionGetSchemaOutputNotFound {
  readonly variant: 'notFound';
  readonly message: string;
}

export type SchemaEvolutionGetSchemaOutput = SchemaEvolutionGetSchemaOutputOk | SchemaEvolutionGetSchemaOutputNotFound;

// --- Variant constructors ---

export const registerOk = (version: number, schemaId: string): SchemaEvolutionRegisterOutput => ({ variant: 'ok', version, schemaId } as SchemaEvolutionRegisterOutput);
export const registerIncompatible = (reasons: readonly string[]): SchemaEvolutionRegisterOutput => ({ variant: 'incompatible', reasons } as SchemaEvolutionRegisterOutput);
export const registerInvalidCompatibility = (message: string): SchemaEvolutionRegisterOutput => ({ variant: 'invalidCompatibility', message } as SchemaEvolutionRegisterOutput);

export const checkCompatible = (): SchemaEvolutionCheckOutput => ({ variant: 'compatible' } as SchemaEvolutionCheckOutput);
export const checkIncompatible = (reasons: readonly string[]): SchemaEvolutionCheckOutput => ({ variant: 'incompatible', reasons } as SchemaEvolutionCheckOutput);

export const upcastOk = (transformed: Buffer): SchemaEvolutionUpcastOutput => ({ variant: 'ok', transformed } as SchemaEvolutionUpcastOutput);
export const upcastNoPath = (message: string): SchemaEvolutionUpcastOutput => ({ variant: 'noPath', message } as SchemaEvolutionUpcastOutput);
export const upcastNotFound = (message: string): SchemaEvolutionUpcastOutput => ({ variant: 'notFound', message } as SchemaEvolutionUpcastOutput);

export const resolveOk = (resolved: Buffer): SchemaEvolutionResolveOutput => ({ variant: 'ok', resolved } as SchemaEvolutionResolveOutput);
export const resolveIncompatible = (reasons: readonly string[]): SchemaEvolutionResolveOutput => ({ variant: 'incompatible', reasons } as SchemaEvolutionResolveOutput);

export const getSchemaOk = (schema: Buffer, compatibility: string): SchemaEvolutionGetSchemaOutput => ({ variant: 'ok', schema, compatibility } as SchemaEvolutionGetSchemaOutput);
export const getSchemaNotFound = (message: string): SchemaEvolutionGetSchemaOutput => ({ variant: 'notFound', message } as SchemaEvolutionGetSchemaOutput);

