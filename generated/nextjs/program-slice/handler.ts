// ProgramSlice â€” handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  ProgramSliceStorage,
  ProgramSliceComputeInput,
  ProgramSliceComputeOutput,
  ProgramSliceFilesInSliceInput,
  ProgramSliceFilesInSliceOutput,
  ProgramSliceSymbolsInSliceInput,
  ProgramSliceSymbolsInSliceOutput,
  ProgramSliceGetInput,
  ProgramSliceGetOutput,
} from './types.js';

import {
  computeOk,
  computeNoDependenceData,
  filesInSliceOk,
  symbolsInSliceOk,
  getOk,
  getNotfound,
} from './types.js';

export interface ProgramSliceError {
  readonly code: string;
  readonly message: string;
}

export interface ProgramSliceHandler {
  readonly compute: (
    input: ProgramSliceComputeInput,
    storage: ProgramSliceStorage,
  ) => TE.TaskEither<ProgramSliceError, ProgramSliceComputeOutput>;
  readonly filesInSlice: (
    input: ProgramSliceFilesInSliceInput,
    storage: ProgramSliceStorage,
  ) => TE.TaskEither<ProgramSliceError, ProgramSliceFilesInSliceOutput>;
  readonly symbolsInSlice: (
    input: ProgramSliceSymbolsInSliceInput,
    storage: ProgramSliceStorage,
  ) => TE.TaskEither<ProgramSliceError, ProgramSliceSymbolsInSliceOutput>;
  readonly get: (
    input: ProgramSliceGetInput,
    storage: ProgramSliceStorage,
  ) => TE.TaskEither<ProgramSliceError, ProgramSliceGetOutput>;
}

// --- Internal types ---

interface DepEdge {
  readonly from: string;
  readonly to: string;
  readonly kind: string;
}

interface SliceData {
  readonly id: string;
  readonly criterionSymbol: string;
  readonly criterionLocation: string;
  readonly direction: string;
  readonly includedSymbols: readonly string[];
  readonly includedFiles: readonly string[];
  readonly edgeCount: number;
}

const makeStorageError = (error: unknown): ProgramSliceError => ({
  code: 'STORAGE_ERROR',
  message: error instanceof Error ? error.message : String(error),
});

const generateId = (): string =>
  `slice-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;

// Extract file path from a fully-qualified symbol name
// e.g., "ts/function/src/handler.ts/connect" -> "src/handler.ts"
// e.g., "clef/state-field/Article/title" -> "Article"
const extractFileFromSymbol = (symbol: string): string => {
  const parts = symbol.split('/');
  // Heuristic: find the part that looks like a file path (contains '.')
  const filePart = parts.find((p) => p.includes('.'));
  if (filePart !== undefined) return filePart;
  // Fallback: use the second-to-last segment as the "file" (module)
  return parts.length >= 2 ? parts[parts.length - 2] : parts[0];
};

// BFS traversal collecting reachable nodes
const bfsReachable = (
  start: string,
  adj: ReadonlyMap<string, readonly string[]>,
): readonly string[] => {
  const visited = new Set<string>();
  const queue: string[] = [start];
  const result: string[] = [];

  while (queue.length > 0) {
    const current = queue.shift()!;
    if (visited.has(current)) continue;
    visited.add(current);
    if (current !== start) result.push(current);
    for (const neighbor of adj.get(current) ?? []) {
      if (!visited.has(neighbor)) queue.push(neighbor);
    }
  }

  return result;
};

// Build forward adjacency: from -> [to]  (symbol depends on these)
const buildForwardAdj = (
  edges: readonly DepEdge[],
): ReadonlyMap<string, readonly string[]> => {
  const adj = new Map<string, string[]>();
  for (const edge of edges) {
    const existing = adj.get(edge.from) ?? [];
    adj.set(edge.from, [...existing, edge.to]);
  }
  return adj;
};

// Build reverse adjacency: to -> [from]  (these depend on symbol)
const buildReverseAdj = (
  edges: readonly DepEdge[],
): ReadonlyMap<string, readonly string[]> => {
  const adj = new Map<string, string[]>();
  for (const edge of edges) {
    const existing = adj.get(edge.to) ?? [];
    adj.set(edge.to, [...existing, edge.from]);
  }
  return adj;
};

const loadEdges = (
  storage: ProgramSliceStorage,
): TE.TaskEither<ProgramSliceError, readonly DepEdge[]> =>
  TE.tryCatch(
    async () => {
      const records = await storage.find('dep_edges');
      return records.map((r) => ({
        from: String(r['from'] ?? ''),
        to: String(r['to'] ?? ''),
        kind: String(r['kind'] ?? 'data-dep'),
      }));
    },
    makeStorageError,
  );

const loadSlice = (
  storage: ProgramSliceStorage,
  sliceId: string,
): TE.TaskEither<ProgramSliceError, O.Option<SliceData>> =>
  TE.tryCatch(
    async () => {
      const record = await storage.get('slices', sliceId);
      return pipe(
        O.fromNullable(record),
        O.map((r) => ({
          id: String(r['id'] ?? ''),
          criterionSymbol: String(r['criterionSymbol'] ?? ''),
          criterionLocation: String(r['criterionLocation'] ?? ''),
          direction: String(r['direction'] ?? ''),
          includedSymbols: JSON.parse(String(r['includedSymbols'] ?? '[]')),
          includedFiles: JSON.parse(String(r['includedFiles'] ?? '[]')),
          edgeCount: Number(r['edgeCount'] ?? 0),
        })),
      );
    },
    makeStorageError,
  );

// --- Implementation ---

export const programSliceHandler: ProgramSliceHandler = {
  compute: (input, storage) =>
    pipe(
      loadEdges(storage),
      TE.chain((edges) => {
        if (edges.length === 0) {
          return TE.right<ProgramSliceError, ProgramSliceComputeOutput>(
            computeNoDependenceData(
              `No dependence graph data available for criterion '${input.criterion}'`,
            ),
          );
        }

        const direction = input.direction.toLowerCase();
        const isForward = direction === 'forward';

        // Forward slice: who is affected by changes to criterion (reverse edges)
        // Backward slice: what contributes to criterion (forward edges)
        const adj = isForward ? buildReverseAdj(edges) : buildForwardAdj(edges);
        const reachable = bfsReachable(input.criterion, adj);
        const allSymbols = [input.criterion, ...reachable];

        // Extract unique files from symbols
        const fileSet = new Set(allSymbols.map(extractFileFromSymbol));
        const files = Array.from(fileSet);

        // Count edges within the slice
        const sliceSet = new Set(allSymbols);
        const sliceEdgeCount = edges.filter(
          (e) => sliceSet.has(e.from) && sliceSet.has(e.to),
        ).length;

        const sliceId = generateId();

        return pipe(
          TE.tryCatch(
            async () => {
              await storage.put('slices', sliceId, {
                id: sliceId,
                criterionSymbol: input.criterion,
                criterionLocation: extractFileFromSymbol(input.criterion),
                direction: input.direction,
                includedSymbols: JSON.stringify(allSymbols),
                includedFiles: JSON.stringify(files),
                edgeCount: sliceEdgeCount,
              });
              return computeOk(sliceId);
            },
            makeStorageError,
          ),
        );
      }),
    ),

  filesInSlice: (input, storage) =>
    pipe(
      loadSlice(storage, input.slice),
      TE.map((optSlice) =>
        pipe(
          optSlice,
          O.fold(
            () => filesInSliceOk(JSON.stringify([])),
            (slice) => filesInSliceOk(JSON.stringify(slice.includedFiles)),
          ),
        ),
      ),
    ),

  symbolsInSlice: (input, storage) =>
    pipe(
      loadSlice(storage, input.slice),
      TE.map((optSlice) =>
        pipe(
          optSlice,
          O.fold(
            () => symbolsInSliceOk(JSON.stringify([])),
            (slice) => symbolsInSliceOk(JSON.stringify(slice.includedSymbols)),
          ),
        ),
      ),
    ),

  get: (input, storage) =>
    pipe(
      loadSlice(storage, input.slice),
      TE.map((optSlice) =>
        pipe(
          optSlice,
          O.fold(
            () => getNotfound() as ProgramSliceGetOutput,
            (slice) =>
              getOk(
                slice.id,
                slice.criterionSymbol,
                slice.direction,
                slice.includedSymbols.length,
                slice.includedFiles.length,
                slice.edgeCount,
              ),
          ),
        ),
      ),
    ),
};
