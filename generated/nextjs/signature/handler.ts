// Signature — handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';
import { createHmac, randomBytes } from 'crypto';

import type {
  SignatureStorage,
  SignatureSignInput,
  SignatureSignOutput,
  SignatureVerifyInput,
  SignatureVerifyOutput,
  SignatureTimestampInput,
  SignatureTimestampOutput,
  SignatureAddTrustedSignerInput,
  SignatureAddTrustedSignerOutput,
} from './types.js';

import {
  signOk,
  signUnknownIdentity,
  signHashNotFound,
  verifyValid,
  verifyInvalid,
  verifyExpired,
  verifyUntrustedSigner,
  timestampOk,
  timestampUnavailable,
  addTrustedSignerOk,
  addTrustedSignerAlreadyTrusted,
} from './types.js';

export interface SignatureError {
  readonly code: string;
  readonly message: string;
}

export interface SignatureHandler {
  readonly sign: (
    input: SignatureSignInput,
    storage: SignatureStorage,
  ) => TE.TaskEither<SignatureError, SignatureSignOutput>;
  readonly verify: (
    input: SignatureVerifyInput,
    storage: SignatureStorage,
  ) => TE.TaskEither<SignatureError, SignatureVerifyOutput>;
  readonly timestamp: (
    input: SignatureTimestampInput,
    storage: SignatureStorage,
  ) => TE.TaskEither<SignatureError, SignatureTimestampOutput>;
  readonly addTrustedSigner: (
    input: SignatureAddTrustedSignerInput,
    storage: SignatureStorage,
  ) => TE.TaskEither<SignatureError, SignatureAddTrustedSignerOutput>;
}

// --- Helpers ---

const storageError = (error: unknown): SignatureError => ({
  code: 'STORAGE_ERROR',
  message: error instanceof Error ? error.message : String(error),
});

const generateSignatureId = (): string =>
  `sig_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;

/**
 * Create an HMAC-SHA256 signature of the content hash using the identity
 * as a key. In a production system this would use proper PKI; here we
 * use HMAC as a deterministic stand-in that can be verified.
 */
const computeHmac = (contentHash: string, identity: string): string =>
  createHmac('sha256', identity).update(contentHash).digest('hex');

/**
 * Build a self-signed certificate buffer representing the signer's identity
 * and the signing timestamp. This is a simplified model of a real X.509
 * certificate chain.
 */
const buildCertificate = (
  identity: string,
  signedAt: string,
): Buffer =>
  Buffer.from(
    JSON.stringify({
      subject: identity,
      issuer: identity,
      notBefore: signedAt,
      notAfter: new Date(
        new Date(signedAt).getTime() + 365 * 24 * 60 * 60 * 1000,
      ).toISOString(),
      serialNumber: randomBytes(8).toString('hex'),
    }),
  );

/** Parse a certificate buffer and check if it is expired. */
const isCertificateExpired = (certBuf: Buffer): boolean => {
  try {
    const cert = JSON.parse(certBuf.toString('utf-8'));
    const notAfter = new Date(cert.notAfter).getTime();
    return Date.now() > notAfter;
  } catch {
    return true;
  }
};

/** Extract the subject identity from a certificate buffer. */
const extractSubject = (certBuf: Buffer): O.Option<string> => {
  try {
    const cert = JSON.parse(certBuf.toString('utf-8'));
    return typeof cert.subject === 'string' ? O.some(cert.subject) : O.none;
  } catch {
    return O.none;
  }
};

// --- Implementation ---

export const signatureHandler: SignatureHandler = {
  sign: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          // Verify the identity is in the trusted signers set
          const trustedSigner = await storage.get('trusted_signers', input.identity);
          if (trustedSigner === null) {
            return signUnknownIdentity(
              `Identity "${input.identity}" is not in the trusted signers set`,
            );
          }

          // Verify the content hash exists in storage (basic sanity check)
          const contentRecord = await storage.get('content_hashes', input.contentHash);
          if (contentRecord === null) {
            // Store the content hash reference so it can be verified later
            await storage.put('content_hashes', input.contentHash, {
              hash: input.contentHash,
              registeredAt: new Date().toISOString(),
            });
          }

          const signedAt = new Date().toISOString();
          const signatureId = generateSignatureId();
          const hmac = computeHmac(input.contentHash, input.identity);
          const certificate = buildCertificate(input.identity, signedAt);

          // Build an RFC 3161-style timestamp token
          const timestampToken = Buffer.from(
            JSON.stringify({
              algorithm: 'sha256',
              hashedMessage: input.contentHash,
              generationTime: signedAt,
              nonce: randomBytes(8).toString('hex'),
            }),
          );

          await storage.put('signatures', signatureId, {
            id: signatureId,
            contentHash: input.contentHash,
            signer: input.identity,
            hmac,
            certificate: certificate.toString('base64'),
            timestamp: timestampToken.toString('base64'),
            signedAt,
            valid: true,
          });

          return signOk(signatureId);
        },
        storageError,
      ),
    ),

  verify: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const sigRecord = await storage.get('signatures', input.signatureId);
          return pipe(
            O.fromNullable(sigRecord),
            O.fold(
              async () =>
                verifyInvalid(
                  `Signature "${input.signatureId}" not found`,
                ),
              async (record) => {
                const storedHash = record['contentHash'] as string;
                const storedHmac = record['hmac'] as string;
                const signer = record['signer'] as string;
                const certBase64 = record['certificate'] as string;
                const signedAt = record['signedAt'] as string;
                const certBuf = Buffer.from(certBase64, 'base64');

                // Check if the signer is in the trusted set
                const trustedSigner = await storage.get('trusted_signers', signer);
                if (trustedSigner === null) {
                  return verifyUntrustedSigner(signer);
                }

                // Check certificate expiry
                if (isCertificateExpired(certBuf)) {
                  return verifyExpired(
                    `Certificate for "${signer}" has expired`,
                  );
                }

                // Verify the HMAC: recompute and compare
                if (storedHash !== input.contentHash) {
                  return verifyInvalid(
                    `Content hash mismatch: signature was for "${storedHash}" but verification requested for "${input.contentHash}"`,
                  );
                }

                const expectedHmac = computeHmac(input.contentHash, signer);
                if (storedHmac !== expectedHmac) {
                  return verifyInvalid(
                    'Signature does not match content hash — HMAC verification failed',
                  );
                }

                return verifyValid(signer, signedAt);
              },
            ),
          );
        },
        storageError,
      ),
      TE.flatten,
    ),

  timestamp: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const now = new Date().toISOString();
          const proof = Buffer.from(
            JSON.stringify({
              version: 1,
              policy: 'rfc3161',
              algorithm: 'sha256',
              hashedMessage: input.contentHash,
              generationTime: now,
              serialNumber: randomBytes(8).toString('hex'),
              nonce: randomBytes(8).toString('hex'),
              tsa: 'local-timestamp-authority',
            }),
          );

          // Persist the timestamp proof for later verification
          await storage.put(
            'timestamps',
            `${input.contentHash}_${Date.now()}`,
            {
              contentHash: input.contentHash,
              proof: proof.toString('base64'),
              generatedAt: now,
            },
          );

          return timestampOk(proof);
        },
        storageError,
      ),
    ),

  addTrustedSigner: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const existing = await storage.get('trusted_signers', input.identity);
          return pipe(
            O.fromNullable(existing),
            O.fold(
              async () => {
                await storage.put('trusted_signers', input.identity, {
                  identity: input.identity,
                  addedAt: new Date().toISOString(),
                });
                return addTrustedSignerOk();
              },
              async () =>
                addTrustedSignerAlreadyTrusted(
                  `Identity "${input.identity}" is already in the trusted set`,
                ),
            ),
          );
        },
        storageError,
      ),
      TE.flatten,
    ),
};
