// ContentHash â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

// Storage interface for ContentHash
export interface ContentHashStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface ContentHashStoreInput {
  readonly content: Buffer;
}

export interface ContentHashStoreOutputOk {
  readonly variant: 'ok';
  readonly hash: string;
}

export interface ContentHashStoreOutputAlreadyExists {
  readonly variant: 'alreadyExists';
  readonly hash: string;
}

export type ContentHashStoreOutput = ContentHashStoreOutputOk | ContentHashStoreOutputAlreadyExists;

export interface ContentHashRetrieveInput {
  readonly hash: string;
}

export interface ContentHashRetrieveOutputOk {
  readonly variant: 'ok';
  readonly content: Buffer;
}

export interface ContentHashRetrieveOutputNotFound {
  readonly variant: 'notFound';
  readonly message: string;
}

export type ContentHashRetrieveOutput = ContentHashRetrieveOutputOk | ContentHashRetrieveOutputNotFound;

export interface ContentHashVerifyInput {
  readonly hash: string;
  readonly content: Buffer;
}

export interface ContentHashVerifyOutputValid {
  readonly variant: 'valid';
}

export interface ContentHashVerifyOutputCorrupt {
  readonly variant: 'corrupt';
  readonly expected: string;
  readonly actual: string;
}

export interface ContentHashVerifyOutputNotFound {
  readonly variant: 'notFound';
  readonly message: string;
}

export type ContentHashVerifyOutput = ContentHashVerifyOutputValid | ContentHashVerifyOutputCorrupt | ContentHashVerifyOutputNotFound;

export interface ContentHashDeleteInput {
  readonly hash: string;
}

export interface ContentHashDeleteOutputOk {
  readonly variant: 'ok';
}

export interface ContentHashDeleteOutputNotFound {
  readonly variant: 'notFound';
  readonly message: string;
}

export interface ContentHashDeleteOutputReferenced {
  readonly variant: 'referenced';
  readonly message: string;
}

export type ContentHashDeleteOutput = ContentHashDeleteOutputOk | ContentHashDeleteOutputNotFound | ContentHashDeleteOutputReferenced;

// --- Variant constructors ---

export const storeOk = (hash: string): ContentHashStoreOutput => ({ variant: 'ok', hash } as ContentHashStoreOutput);
export const storeAlreadyExists = (hash: string): ContentHashStoreOutput => ({ variant: 'alreadyExists', hash } as ContentHashStoreOutput);

export const retrieveOk = (content: Buffer): ContentHashRetrieveOutput => ({ variant: 'ok', content } as ContentHashRetrieveOutput);
export const retrieveNotFound = (message: string): ContentHashRetrieveOutput => ({ variant: 'notFound', message } as ContentHashRetrieveOutput);

export const verifyValid = (): ContentHashVerifyOutput => ({ variant: 'valid' } as ContentHashVerifyOutput);
export const verifyCorrupt = (expected: string, actual: string): ContentHashVerifyOutput => ({ variant: 'corrupt', expected, actual } as ContentHashVerifyOutput);
export const verifyNotFound = (message: string): ContentHashVerifyOutput => ({ variant: 'notFound', message } as ContentHashVerifyOutput);

export const deleteOk = (): ContentHashDeleteOutput => ({ variant: 'ok' } as ContentHashDeleteOutput);
export const deleteNotFound = (message: string): ContentHashDeleteOutput => ({ variant: 'notFound', message } as ContentHashDeleteOutput);
export const deleteReferenced = (message: string): ContentHashDeleteOutput => ({ variant: 'referenced', message } as ContentHashDeleteOutput);

