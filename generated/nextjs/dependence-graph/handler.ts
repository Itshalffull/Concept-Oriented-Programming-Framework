// DependenceGraph â€” handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  DependenceGraphStorage,
  DependenceGraphComputeInput,
  DependenceGraphComputeOutput,
  DependenceGraphQueryDependentsInput,
  DependenceGraphQueryDependentsOutput,
  DependenceGraphQueryDependenciesInput,
  DependenceGraphQueryDependenciesOutput,
  DependenceGraphSliceForwardInput,
  DependenceGraphSliceForwardOutput,
  DependenceGraphSliceBackwardInput,
  DependenceGraphSliceBackwardOutput,
  DependenceGraphImpactAnalysisInput,
  DependenceGraphImpactAnalysisOutput,
  DependenceGraphGetInput,
  DependenceGraphGetOutput,
} from './types.js';

import {
  computeOk,
  computeUnsupportedLanguage,
  queryDependentsOk,
  queryDependenciesOk,
  sliceForwardOk,
  sliceBackwardOk,
  impactAnalysisOk,
  getOk,
  getNotfound,
} from './types.js';

export interface DependenceGraphError {
  readonly code: string;
  readonly message: string;
}

export interface DependenceGraphHandler {
  readonly compute: (
    input: DependenceGraphComputeInput,
    storage: DependenceGraphStorage,
  ) => TE.TaskEither<DependenceGraphError, DependenceGraphComputeOutput>;
  readonly queryDependents: (
    input: DependenceGraphQueryDependentsInput,
    storage: DependenceGraphStorage,
  ) => TE.TaskEither<DependenceGraphError, DependenceGraphQueryDependentsOutput>;
  readonly queryDependencies: (
    input: DependenceGraphQueryDependenciesInput,
    storage: DependenceGraphStorage,
  ) => TE.TaskEither<DependenceGraphError, DependenceGraphQueryDependenciesOutput>;
  readonly sliceForward: (
    input: DependenceGraphSliceForwardInput,
    storage: DependenceGraphStorage,
  ) => TE.TaskEither<DependenceGraphError, DependenceGraphSliceForwardOutput>;
  readonly sliceBackward: (
    input: DependenceGraphSliceBackwardInput,
    storage: DependenceGraphStorage,
  ) => TE.TaskEither<DependenceGraphError, DependenceGraphSliceBackwardOutput>;
  readonly impactAnalysis: (
    input: DependenceGraphImpactAnalysisInput,
    storage: DependenceGraphStorage,
  ) => TE.TaskEither<DependenceGraphError, DependenceGraphImpactAnalysisOutput>;
  readonly get: (
    input: DependenceGraphGetInput,
    storage: DependenceGraphStorage,
  ) => TE.TaskEither<DependenceGraphError, DependenceGraphGetOutput>;
}

// --- Internal graph representation ---

interface DepEdge {
  readonly from: string;
  readonly to: string;
  readonly kind: string;
}

interface DepGraph {
  readonly id: string;
  readonly scope: string;
  readonly scopeRef: string;
  readonly nodes: readonly string[];
  readonly edges: readonly DepEdge[];
}

const makeStorageError = (error: unknown): DependenceGraphError => ({
  code: 'STORAGE_ERROR',
  message: error instanceof Error ? error.message : String(error),
});

const generateId = (): string =>
  `depgraph-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;

const SUPPORTED_EXTENSIONS: ReadonlySet<string> = new Set([
  '.ts', '.tsx', '.js', '.jsx', '.rs', '.concept', '.sync',
]);

const detectLanguage = (scopeRef: string): O.Option<string> => {
  const ext = scopeRef.includes('.') ? `.${scopeRef.split('.').pop()}` : '';
  if (SUPPORTED_EXTENSIONS.has(ext)) return O.some(ext.slice(1));
  if (scopeRef.startsWith('module:') || scopeRef.startsWith('project:')) return O.some('scope');
  return O.none;
};

const detectScope = (scopeRef: string): string => {
  if (scopeRef.startsWith('project:')) return 'project';
  if (scopeRef.startsWith('module:')) return 'module';
  return 'file';
};

const loadAllEdges = (
  storage: DependenceGraphStorage,
): TE.TaskEither<DependenceGraphError, readonly DepEdge[]> =>
  TE.tryCatch(
    async () => {
      const records = await storage.find('dep_edges');
      return records.map((r) => ({
        from: String(r['from'] ?? ''),
        to: String(r['to'] ?? ''),
        kind: String(r['kind'] ?? 'data-dep'),
      }));
    },
    makeStorageError,
  );

// Build forward adjacency: from -> [to]
const buildForwardAdj = (
  edges: readonly DepEdge[],
  kindFilter: ReadonlySet<string> | null,
): ReadonlyMap<string, readonly string[]> => {
  const adj = new Map<string, string[]>();
  for (const edge of edges) {
    if (kindFilter !== null && !kindFilter.has(edge.kind)) continue;
    const existing = adj.get(edge.from) ?? [];
    adj.set(edge.from, [...existing, edge.to]);
  }
  return adj;
};

// Build reverse adjacency: to -> [from]
const buildReverseAdj = (
  edges: readonly DepEdge[],
  kindFilter: ReadonlySet<string> | null,
): ReadonlyMap<string, readonly string[]> => {
  const adj = new Map<string, string[]>();
  for (const edge of edges) {
    if (kindFilter !== null && !kindFilter.has(edge.kind)) continue;
    const existing = adj.get(edge.to) ?? [];
    adj.set(edge.to, [...existing, edge.from]);
  }
  return adj;
};

// BFS forward reachability from a start node
const bfsForward = (
  start: string,
  adj: ReadonlyMap<string, readonly string[]>,
): readonly string[] => {
  const visited = new Set<string>();
  const queue: string[] = [start];
  const result: string[] = [];

  while (queue.length > 0) {
    const current = queue.shift()!;
    if (visited.has(current)) continue;
    visited.add(current);
    if (current !== start) result.push(current);
    for (const neighbor of adj.get(current) ?? []) {
      if (!visited.has(neighbor)) queue.push(neighbor);
    }
  }

  return result;
};

// Collect edges within a node set
const edgesInSubgraph = (
  edges: readonly DepEdge[],
  nodeSet: ReadonlySet<string>,
): readonly DepEdge[] =>
  edges.filter((e) => nodeSet.has(e.from) && nodeSet.has(e.to));

// Parse comma-separated edge kinds filter
const parseEdgeKinds = (edgeKinds: string): ReadonlySet<string> | null => {
  const trimmed = edgeKinds.trim();
  if (trimmed === '' || trimmed === '*') return null;
  return new Set(trimmed.split(',').map((k) => k.trim()).filter((k) => k.length > 0));
};

// Find all paths from a set of changed symbols using BFS
const findImpactPaths = (
  changed: readonly string[],
  forwardAdj: ReadonlyMap<string, readonly string[]>,
): { readonly affected: readonly string[]; readonly paths: ReadonlyMap<string, readonly string[]> } => {
  const allAffected = new Set<string>();
  const pathMap = new Map<string, string[]>();

  for (const root of changed) {
    const visited = new Set<string>();
    const queue: Array<{ readonly node: string; readonly path: readonly string[] }> = [
      { node: root, path: [root] },
    ];

    while (queue.length > 0) {
      const { node, path } = queue.shift()!;
      if (visited.has(node)) continue;
      visited.add(node);

      if (node !== root) {
        allAffected.add(node);
        if (!pathMap.has(node)) {
          pathMap.set(node, [...path]);
        }
      }

      for (const neighbor of forwardAdj.get(node) ?? []) {
        if (!visited.has(neighbor)) {
          queue.push({ node: neighbor, path: [...path, neighbor] });
        }
      }
    }
  }

  return { affected: Array.from(allAffected), paths: pathMap };
};

// --- Implementation ---

export const dependenceGraphHandler: DependenceGraphHandler = {
  compute: (input, storage) =>
    pipe(
      TE.of(detectLanguage(input.scopeRef)),
      TE.chain((langOpt) =>
        pipe(
          langOpt,
          O.fold(
            () => TE.right<DependenceGraphError, DependenceGraphComputeOutput>(
              computeUnsupportedLanguage(input.scopeRef),
            ),
            (_lang) =>
              TE.tryCatch(
                async () => {
                  const graphId = generateId();
                  const scope = detectScope(input.scopeRef);

                  await storage.put('dep_graphs', graphId, {
                    id: graphId,
                    scope,
                    scopeRef: input.scopeRef,
                    nodes: JSON.stringify([]),
                    edges: JSON.stringify([]),
                    createdAt: new Date().toISOString(),
                  });

                  return computeOk(graphId);
                },
                makeStorageError,
              ),
          ),
        ),
      ),
    ),

  queryDependents: (input, storage) =>
    pipe(
      loadAllEdges(storage),
      TE.map((edges) => {
        const kindFilter = parseEdgeKinds(input.edgeKinds);
        const reverseAdj = buildReverseAdj(edges, kindFilter);
        // Direct dependents only (one hop reverse)
        const dependents = reverseAdj.get(input.symbol) ?? [];
        return queryDependentsOk(JSON.stringify(dependents));
      }),
    ),

  queryDependencies: (input, storage) =>
    pipe(
      loadAllEdges(storage),
      TE.map((edges) => {
        const kindFilter = parseEdgeKinds(input.edgeKinds);
        const forwardAdj = buildForwardAdj(edges, kindFilter);
        // Direct dependencies only (one hop forward from symbol means symbol depends on them)
        // Actually: edges where from=symbol means symbol depends on .to
        // But in dependence semantics: an edge from A -> B means A depends on B
        // queryDependencies(symbol) = all B where symbol -> B
        const dependencies = forwardAdj.get(input.symbol) ?? [];
        return queryDependenciesOk(JSON.stringify(dependencies));
      }),
    ),

  sliceForward: (input, storage) =>
    pipe(
      loadAllEdges(storage),
      TE.map((edges) => {
        // Forward slice: all symbols reachable from criterion via reverse edges
        // (who depends on criterion, transitively)
        const reverseAdj = buildReverseAdj(edges, null);
        const sliceNodes = bfsForward(input.criterion, reverseAdj);
        const sliceNodeSet = new Set([input.criterion, ...sliceNodes]);
        const sliceEdges = edgesInSubgraph(edges, sliceNodeSet);

        return sliceForwardOk(
          JSON.stringify([input.criterion, ...sliceNodes]),
          JSON.stringify(sliceEdges),
        );
      }),
    ),

  sliceBackward: (input, storage) =>
    pipe(
      loadAllEdges(storage),
      TE.map((edges) => {
        // Backward slice: all symbols the criterion transitively depends on
        const forwardAdj = buildForwardAdj(edges, null);
        const sliceNodes = bfsForward(input.criterion, forwardAdj);
        const sliceNodeSet = new Set([input.criterion, ...sliceNodes]);
        const sliceEdges = edgesInSubgraph(edges, sliceNodeSet);

        return sliceBackwardOk(
          JSON.stringify([input.criterion, ...sliceNodes]),
          JSON.stringify(sliceEdges),
        );
      }),
    ),

  impactAnalysis: (input, storage) =>
    pipe(
      loadAllEdges(storage),
      TE.map((edges) => {
        const changedSymbols: readonly string[] = JSON.parse(input.changed);
        const reverseAdj = buildReverseAdj(edges, null);
        const { affected, paths } = findImpactPaths(changedSymbols, reverseAdj);

        const pathEntries: Record<string, readonly string[]> = {};
        paths.forEach((path, node) => {
          pathEntries[node] = path;
        });

        return impactAnalysisOk(
          JSON.stringify(affected),
          JSON.stringify(pathEntries),
        );
      }),
    ),

  get: (input, storage) =>
    pipe(
      TE.tryCatch(
        () => storage.get('dep_graphs', input.graph),
        makeStorageError,
      ),
      TE.chain((record) =>
        pipe(
          O.fromNullable(record),
          O.fold(
            () => TE.right<DependenceGraphError, DependenceGraphGetOutput>(getNotfound()),
            (found) => {
              const nodes: readonly unknown[] = JSON.parse(String(found['nodes'] ?? '[]'));
              const edges: readonly unknown[] = JSON.parse(String(found['edges'] ?? '[]'));
              return TE.right<DependenceGraphError, DependenceGraphGetOutput>(
                getOk(
                  input.graph,
                  String(found['scope'] ?? 'file'),
                  nodes.length,
                  edges.length,
                ),
              );
            },
          ),
        ),
      ),
    ),
};
