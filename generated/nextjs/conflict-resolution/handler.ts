// ConflictResolution — handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  ConflictResolutionStorage,
  ConflictResolutionRegisterPolicyInput,
  ConflictResolutionRegisterPolicyOutput,
  ConflictResolutionDetectInput,
  ConflictResolutionDetectOutput,
  ConflictResolutionResolveInput,
  ConflictResolutionResolveOutput,
  ConflictResolutionManualResolveInput,
  ConflictResolutionManualResolveOutput,
} from './types.js';

import {
  registerPolicyOk,
  registerPolicyDuplicate,
  detectNoConflict,
  detectDetected,
  resolveResolved,
  resolveRequiresHuman,
  resolveNoPolicy,
  manualResolveOk,
  manualResolveNotPending,
} from './types.js';

export interface ConflictResolutionError {
  readonly code: string;
  readonly message: string;
}

export interface ConflictResolutionHandler {
  readonly registerPolicy: (
    input: ConflictResolutionRegisterPolicyInput,
    storage: ConflictResolutionStorage,
  ) => TE.TaskEither<ConflictResolutionError, ConflictResolutionRegisterPolicyOutput>;
  readonly detect: (
    input: ConflictResolutionDetectInput,
    storage: ConflictResolutionStorage,
  ) => TE.TaskEither<ConflictResolutionError, ConflictResolutionDetectOutput>;
  readonly resolve: (
    input: ConflictResolutionResolveInput,
    storage: ConflictResolutionStorage,
  ) => TE.TaskEither<ConflictResolutionError, ConflictResolutionResolveOutput>;
  readonly manualResolve: (
    input: ConflictResolutionManualResolveInput,
    storage: ConflictResolutionStorage,
  ) => TE.TaskEither<ConflictResolutionError, ConflictResolutionManualResolveOutput>;
}

// --- Helpers ---

const storageError = (error: unknown): ConflictResolutionError => ({
  code: 'STORAGE_ERROR',
  message: error instanceof Error ? error.message : String(error),
});

const generateId = (): string =>
  `conflict_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;

/** Retrieve all registered policies sorted by priority (ascending). */
const loadPoliciesSorted = async (
  storage: ConflictResolutionStorage,
): Promise<readonly Record<string, unknown>[]> => {
  const policies = await storage.find('policies');
  return [...policies].sort(
    (a, b) => ((a['priority'] as number) ?? 99) - ((b['priority'] as number) ?? 99),
  );
};

// --- Implementation ---

export const conflictResolutionHandler: ConflictResolutionHandler = {
  registerPolicy: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const existing = await storage.get('policies', input.name);
          return pipe(
            O.fromNullable(existing),
            O.fold(
              async () => {
                const policyId = `policy_${input.name}`;
                await storage.put('policies', input.name, {
                  id: policyId,
                  name: input.name,
                  priority: input.priority,
                });
                return registerPolicyOk(policyId);
              },
              async () =>
                registerPolicyDuplicate(
                  `Policy "${input.name}" is already registered`,
                ),
            ),
          );
        },
        storageError,
      ),
      TE.flatten,
    ),

  detect: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const { version1, version2 } = input;
          // If both versions are identical, there is no conflict
          if (version1 === version2) {
            return detectNoConflict();
          }
          // Versions differ — conflict detected
          const conflictId = generateId();
          const detail = Buffer.from(
            JSON.stringify({
              version1,
              version2,
              base: pipe(
                input.base,
                O.getOrElse(() => ''),
              ),
              context: input.context,
            }),
          );
          // Persist the conflict record for later resolution
          await storage.put('conflicts', conflictId, {
            id: conflictId,
            base: pipe(
              input.base,
              O.getOrElse(() => ''),
            ),
            version1,
            version2,
            context: input.context,
            status: 'pending',
            resolution: null,
          });
          return detectDetected(conflictId, detail);
        },
        storageError,
      ),
    ),

  resolve: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const conflictRecord = await storage.get(
            'conflicts',
            input.conflictId as string,
          );
          if (conflictRecord === null) {
            return resolveNoPolicy(
              `Conflict "${String(input.conflictId)}" not found`,
            );
          }
          // If a specific policy override is requested, try that first
          const overrideName = pipe(
            input.policyOverride,
            O.toNullable,
          );
          const policies = await loadPoliciesSorted(storage);
          if (policies.length === 0) {
            return resolveNoPolicy('No resolution policies registered');
          }
          // When an override is given, filter to just that policy
          const candidates = overrideName !== null
            ? policies.filter((p) => p['name'] === overrideName)
            : policies;

          if (candidates.length === 0) {
            return resolveNoPolicy(
              `Policy "${overrideName}" not found`,
            );
          }

          const version1 = conflictRecord['version1'] as string;
          const version2 = conflictRecord['version2'] as string;

          // Try policies in priority order; LWW is simplest auto-resolve
          for (const policy of candidates) {
            const policyName = policy['name'] as string;
            if (policyName === 'lww') {
              // Last-Write-Wins: pick version2 as the "later" write by convention
              const resolved = version2;
              await storage.put('conflicts', input.conflictId as string, {
                ...conflictRecord,
                status: 'resolved',
                resolution: resolved,
              });
              return resolveResolved(resolved);
            }
            if (policyName === 'add-wins') {
              // Add-Wins: merge both versions (union semantics)
              const resolved = version1 + version2;
              await storage.put('conflicts', input.conflictId as string, {
                ...conflictRecord,
                status: 'resolved',
                resolution: resolved,
              });
              return resolveResolved(resolved);
            }
            if (policyName === 'multi-value') {
              // Multi-value: keep both as-is, still auto-resolved
              const resolved = JSON.stringify([version1, version2]);
              await storage.put('conflicts', input.conflictId as string, {
                ...conflictRecord,
                status: 'resolved',
                resolution: resolved,
              });
              return resolveResolved(resolved);
            }
            // "manual" or unknown policy — skip to next or fall through
          }

          // No policy could auto-resolve; escalate to human
          const options = [
            Buffer.from(version1),
            Buffer.from(version2),
          ];
          return resolveRequiresHuman(input.conflictId, options);
        },
        storageError,
      ),
    ),

  manualResolve: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const conflictRecord = await storage.get(
            'conflicts',
            input.conflictId as string,
          );
          return pipe(
            O.fromNullable(conflictRecord),
            O.fold(
              async () =>
                manualResolveNotPending(
                  `Conflict "${String(input.conflictId)}" not found`,
                ),
              async (record) => {
                const status = record['status'] as string;
                if (status === 'resolved') {
                  return manualResolveNotPending(
                    `Conflict "${String(input.conflictId)}" is already resolved`,
                  );
                }
                await storage.put('conflicts', input.conflictId as string, {
                  ...record,
                  status: 'resolved',
                  resolution: input.chosen,
                });
                return manualResolveOk(input.chosen);
              },
            ),
          );
        },
        storageError,
      ),
      TE.flatten,
    ),
};
