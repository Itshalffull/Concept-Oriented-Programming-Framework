// ConflictResolution â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as O from 'fp-ts/Option';

// Storage interface for ConflictResolution
export interface ConflictResolutionStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface ConflictResolutionRegisterPolicyInput {
  readonly name: string;
  readonly priority: number;
}

export interface ConflictResolutionRegisterPolicyOutputOk {
  readonly variant: 'ok';
  readonly policy: unknown;
}

export interface ConflictResolutionRegisterPolicyOutputDuplicate {
  readonly variant: 'duplicate';
  readonly message: string;
}

export type ConflictResolutionRegisterPolicyOutput = ConflictResolutionRegisterPolicyOutputOk | ConflictResolutionRegisterPolicyOutputDuplicate;

export interface ConflictResolutionDetectInput {
  readonly base: O.Option<string>;
  readonly version1: string;
  readonly version2: string;
  readonly context: string;
}

export interface ConflictResolutionDetectOutputNoConflict {
  readonly variant: 'noConflict';
}

export interface ConflictResolutionDetectOutputDetected {
  readonly variant: 'detected';
  readonly conflictId: unknown;
  readonly detail: Buffer;
}

export type ConflictResolutionDetectOutput = ConflictResolutionDetectOutputNoConflict | ConflictResolutionDetectOutputDetected;

export interface ConflictResolutionResolveInput {
  readonly conflictId: unknown;
  readonly policyOverride: O.Option<string>;
}

export interface ConflictResolutionResolveOutputResolved {
  readonly variant: 'resolved';
  readonly result: string;
}

export interface ConflictResolutionResolveOutputRequiresHuman {
  readonly variant: 'requiresHuman';
  readonly conflictId: unknown;
  readonly options: readonly Buffer[];
}

export interface ConflictResolutionResolveOutputNoPolicy {
  readonly variant: 'noPolicy';
  readonly message: string;
}

export type ConflictResolutionResolveOutput = ConflictResolutionResolveOutputResolved | ConflictResolutionResolveOutputRequiresHuman | ConflictResolutionResolveOutputNoPolicy;

export interface ConflictResolutionManualResolveInput {
  readonly conflictId: unknown;
  readonly chosen: string;
}

export interface ConflictResolutionManualResolveOutputOk {
  readonly variant: 'ok';
  readonly result: string;
}

export interface ConflictResolutionManualResolveOutputNotPending {
  readonly variant: 'notPending';
  readonly message: string;
}

export type ConflictResolutionManualResolveOutput = ConflictResolutionManualResolveOutputOk | ConflictResolutionManualResolveOutputNotPending;

// --- Variant constructors ---

export const registerPolicyOk = (policy: unknown): ConflictResolutionRegisterPolicyOutput => ({ variant: 'ok', policy } as ConflictResolutionRegisterPolicyOutput);
export const registerPolicyDuplicate = (message: string): ConflictResolutionRegisterPolicyOutput => ({ variant: 'duplicate', message } as ConflictResolutionRegisterPolicyOutput);

export const detectNoConflict = (): ConflictResolutionDetectOutput => ({ variant: 'noConflict' } as ConflictResolutionDetectOutput);
export const detectDetected = (conflictId: unknown, detail: Buffer): ConflictResolutionDetectOutput => ({ variant: 'detected', conflictId, detail } as ConflictResolutionDetectOutput);

export const resolveResolved = (result: string): ConflictResolutionResolveOutput => ({ variant: 'resolved', result } as ConflictResolutionResolveOutput);
export const resolveRequiresHuman = (conflictId: unknown, options: readonly Buffer[]): ConflictResolutionResolveOutput => ({ variant: 'requiresHuman', conflictId, options } as ConflictResolutionResolveOutput);
export const resolveNoPolicy = (message: string): ConflictResolutionResolveOutput => ({ variant: 'noPolicy', message } as ConflictResolutionResolveOutput);

export const manualResolveOk = (result: string): ConflictResolutionManualResolveOutput => ({ variant: 'ok', result } as ConflictResolutionManualResolveOutput);
export const manualResolveNotPending = (message: string): ConflictResolutionManualResolveOutput => ({ variant: 'notPending', message } as ConflictResolutionManualResolveOutput);

