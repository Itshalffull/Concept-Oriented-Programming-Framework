// Shell â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as O from 'fp-ts/Option';

// Storage interface for Shell
export interface ShellStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface ShellInitializeInput {
  readonly shell: string;
  readonly zones: string;
}

export interface ShellInitializeOutputOk {
  readonly variant: 'ok';
  readonly shell: string;
}

export interface ShellInitializeOutputInvalid {
  readonly variant: 'invalid';
  readonly message: string;
}

export type ShellInitializeOutput = ShellInitializeOutputOk | ShellInitializeOutputInvalid;

export interface ShellAssignToZoneInput {
  readonly shell: string;
  readonly zone: string;
  readonly ref: string;
}

export interface ShellAssignToZoneOutputOk {
  readonly variant: 'ok';
  readonly shell: string;
}

export interface ShellAssignToZoneOutputNotfound {
  readonly variant: 'notfound';
  readonly message: string;
}

export type ShellAssignToZoneOutput = ShellAssignToZoneOutputOk | ShellAssignToZoneOutputNotfound;

export interface ShellClearZoneInput {
  readonly shell: string;
  readonly zone: string;
}

export interface ShellClearZoneOutputOk {
  readonly variant: 'ok';
  readonly shell: string;
  readonly previous: O.Option<string>;
}

export interface ShellClearZoneOutputNotfound {
  readonly variant: 'notfound';
  readonly message: string;
}

export type ShellClearZoneOutput = ShellClearZoneOutputOk | ShellClearZoneOutputNotfound;

export interface ShellPushOverlayInput {
  readonly shell: string;
  readonly ref: string;
}

export interface ShellPushOverlayOutputOk {
  readonly variant: 'ok';
  readonly shell: string;
}

export interface ShellPushOverlayOutputInvalid {
  readonly variant: 'invalid';
  readonly message: string;
}

export type ShellPushOverlayOutput = ShellPushOverlayOutputOk | ShellPushOverlayOutputInvalid;

export interface ShellPopOverlayInput {
  readonly shell: string;
}

export interface ShellPopOverlayOutputOk {
  readonly variant: 'ok';
  readonly shell: string;
  readonly overlay: string;
}

export interface ShellPopOverlayOutputEmpty {
  readonly variant: 'empty';
  readonly message: string;
}

export type ShellPopOverlayOutput = ShellPopOverlayOutputOk | ShellPopOverlayOutputEmpty;

// --- Variant constructors ---

export const initializeOk = (shell: string): ShellInitializeOutput => ({ variant: 'ok', shell } as ShellInitializeOutput);
export const initializeInvalid = (message: string): ShellInitializeOutput => ({ variant: 'invalid', message } as ShellInitializeOutput);

export const assignToZoneOk = (shell: string): ShellAssignToZoneOutput => ({ variant: 'ok', shell } as ShellAssignToZoneOutput);
export const assignToZoneNotfound = (message: string): ShellAssignToZoneOutput => ({ variant: 'notfound', message } as ShellAssignToZoneOutput);

export const clearZoneOk = (shell: string, previous: O.Option<string>): ShellClearZoneOutput => ({ variant: 'ok', shell, previous } as ShellClearZoneOutput);
export const clearZoneNotfound = (message: string): ShellClearZoneOutput => ({ variant: 'notfound', message } as ShellClearZoneOutput);

export const pushOverlayOk = (shell: string): ShellPushOverlayOutput => ({ variant: 'ok', shell } as ShellPushOverlayOutput);
export const pushOverlayInvalid = (message: string): ShellPushOverlayOutput => ({ variant: 'invalid', message } as ShellPushOverlayOutput);

export const popOverlayOk = (shell: string, overlay: string): ShellPopOverlayOutput => ({ variant: 'ok', shell, overlay } as ShellPopOverlayOutput);
export const popOverlayEmpty = (message: string): ShellPopOverlayOutput => ({ variant: 'empty', message } as ShellPopOverlayOutput);

