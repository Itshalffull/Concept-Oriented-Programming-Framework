// SemanticMerge â€” handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.
//
// Implements AST-aware merge that understands code structure. Parses
// source code into a simplified AST of top-level declarations (imports,
// functions, classes, exports, statements), then merges at the
// declaration level. This resolves text-level conflicts that are
// semantically non-conflicting, such as independently added imports
// or reordered function definitions.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  SemanticMergeStorage,
  SemanticMergeRegisterInput,
  SemanticMergeRegisterOutput,
  SemanticMergeExecuteInput,
  SemanticMergeExecuteOutput,
} from './types.js';

import {
  registerOk,
  executeClean,
  executeConflicts,
  executeUnsupportedContent,
} from './types.js';

export interface SemanticMergeError {
  readonly code: string;
  readonly message: string;
}

export interface SemanticMergeHandler {
  readonly register: (
    input: SemanticMergeRegisterInput,
    storage: SemanticMergeStorage,
  ) => TE.TaskEither<SemanticMergeError, SemanticMergeRegisterOutput>;
  readonly execute: (
    input: SemanticMergeExecuteInput,
    storage: SemanticMergeStorage,
  ) => TE.TaskEither<SemanticMergeError, SemanticMergeExecuteOutput>;
}

// --- AST node types ---

type DeclKind = 'import' | 'function' | 'class' | 'variable' | 'export' | 'statement';

interface ASTDeclaration {
  readonly kind: DeclKind;
  readonly name: string; // identifier or canonical key for deduplication
  readonly text: string; // full source text of the declaration
  readonly lineStart: number;
  readonly lineEnd: number;
}

type MergedDecl =
  | { readonly type: 'clean'; readonly decl: ASTDeclaration }
  | { readonly type: 'conflict'; readonly ours: ASTDeclaration; readonly theirs: ASTDeclaration };

// --- Pure helper functions ---

const splitLines = (buf: Buffer): readonly string[] =>
  buf.toString('utf-8').split('\n');

const joinLines = (lines: readonly string[]): Buffer =>
  Buffer.from(lines.join('\n'), 'utf-8');

/**
 * Classify a line to determine what kind of declaration it starts.
 * Uses heuristic pattern matching for TypeScript/JavaScript/Python/Java.
 */
const classifyLine = (line: string): O.Option<{ readonly kind: DeclKind; readonly name: string }> => {
  const trimmed = line.trim();

  // Import statements
  if (/^import\s/.test(trimmed) || /^from\s/.test(trimmed)) {
    // Use the full import text as the name for dedup
    return O.some({ kind: 'import', name: trimmed });
  }

  // Export statements (named and default)
  if (/^export\s+(default\s+)?(function|class|const|let|var|interface|type|enum)\s+/.test(trimmed)) {
    const match = trimmed.match(/^export\s+(?:default\s+)?(?:function|class|const|let|var|interface|type|enum)\s+(\w+)/);
    return O.some({
      kind: 'export',
      name: match ? `export:${match[1]}` : `export:${trimmed.slice(0, 40)}`,
    });
  }
  if (/^export\s+\{/.test(trimmed)) {
    return O.some({ kind: 'export', name: trimmed });
  }

  // Function declarations
  if (/^(async\s+)?function\s+/.test(trimmed)) {
    const match = trimmed.match(/function\s+(\w+)/);
    return O.some({
      kind: 'function',
      name: match ? match[1] : `fn:${trimmed.slice(0, 40)}`,
    });
  }
  // Arrow functions assigned to const/let
  if (/^(const|let|var)\s+\w+\s*=\s*(async\s+)?\(/.test(trimmed) || /^(const|let|var)\s+\w+\s*=\s*(async\s+)?(\w+)\s*=>/.test(trimmed)) {
    const match = trimmed.match(/^(?:const|let|var)\s+(\w+)/);
    return O.some({
      kind: 'function',
      name: match ? match[1] : `fn:${trimmed.slice(0, 40)}`,
    });
  }

  // Class declarations
  if (/^class\s+/.test(trimmed)) {
    const match = trimmed.match(/class\s+(\w+)/);
    return O.some({
      kind: 'class',
      name: match ? match[1] : `class:${trimmed.slice(0, 40)}`,
    });
  }

  // Variable declarations (const, let, var) not already caught by arrow functions
  if (/^(const|let|var)\s+/.test(trimmed)) {
    const match = trimmed.match(/^(?:const|let|var)\s+(\w+)/);
    return O.some({
      kind: 'variable',
      name: match ? match[1] : `var:${trimmed.slice(0, 40)}`,
    });
  }

  // Python: def/class
  if (/^def\s+/.test(trimmed)) {
    const match = trimmed.match(/^def\s+(\w+)/);
    return O.some({
      kind: 'function',
      name: match ? match[1] : `def:${trimmed.slice(0, 40)}`,
    });
  }

  // Java: method/class patterns
  if (/^(public|private|protected|static)\s+/.test(trimmed)) {
    if (/\bclass\s+/.test(trimmed)) {
      const match = trimmed.match(/class\s+(\w+)/);
      return O.some({ kind: 'class', name: match ? match[1] : `class:${trimmed.slice(0, 40)}` });
    }
    // Method
    const match = trimmed.match(/(\w+)\s*\(/);
    if (match) {
      return O.some({ kind: 'function', name: match[1] });
    }
  }

  return O.none;
};

/**
 * Determine if a line is a continuation of a previous declaration
 * (i.e., it is indented or inside a block). Simple heuristic: if
 * the line starts with whitespace (and is not blank) or starts with
 * a closing brace, it is a continuation.
 */
const isContinuation = (line: string): boolean => {
  if (line.trim() === '') return false;
  if (line.trim() === '}' || line.trim() === '};') return true;
  return /^\s+/.test(line) && line.trim().length > 0;
};

/**
 * Parse source code into a list of top-level AST declarations.
 * Uses heuristic line-based parsing suitable for JS/TS/Python/Java.
 */
const parseDeclarations = (lines: readonly string[]): readonly ASTDeclaration[] => {
  const decls: ASTDeclaration[] = [];
  let i = 0;

  while (i < lines.length) {
    const line = lines[i];

    // Skip blank lines between declarations
    if (line.trim() === '') {
      i++;
      continue;
    }

    const classification = classifyLine(line);

    if (O.isSome(classification)) {
      const { kind, name } = classification.value;
      const startLine = i;

      // Collect the full extent of this declaration
      // Track brace depth to handle multi-line declarations
      let braceDepth = 0;
      let j = i;
      do {
        const l = lines[j];
        for (const ch of l) {
          if (ch === '{') braceDepth++;
          if (ch === '}') braceDepth--;
        }
        j++;
      } while (j < lines.length && (braceDepth > 0 || isContinuation(lines[j] ?? '')));

      const text = lines.slice(startLine, j).join('\n');
      decls.push({ kind, name, text, lineStart: startLine, lineEnd: j });
      i = j;
    } else {
      // Unclassified lines: group as a statement block
      const startLine = i;
      let j = i + 1;
      while (j < lines.length && O.isNone(classifyLine(lines[j])) && lines[j].trim() !== '') {
        j++;
      }
      const text = lines.slice(startLine, j).join('\n');
      decls.push({
        kind: 'statement',
        name: `stmt:${startLine}:${text.slice(0, 40)}`,
        text,
        lineStart: startLine,
        lineEnd: j,
      });
      i = j;
    }
  }

  return decls;
};

/**
 * Build a map from declaration name to declaration for lookup.
 */
const buildDeclMap = (
  decls: readonly ASTDeclaration[],
): ReadonlyMap<string, ASTDeclaration> => {
  const map = new Map<string, ASTDeclaration>();
  for (const decl of decls) {
    map.set(decl.name, decl);
  }
  return map;
};

/**
 * Semantic three-way merge at the declaration level.
 *
 * Strategy:
 * 1. Parse base, ours, theirs into declaration lists
 * 2. For each declaration in base:
 *    - If unchanged in both: keep
 *    - If changed in one side only: take the changed version
 *    - If changed in both sides identically: take one copy
 *    - If changed in both sides differently: conflict
 * 3. For new declarations added by ours or theirs: include them
 *    (imports are merged by union; other decls by ordering)
 */
const semanticThreeWayMerge = (
  baseLines: readonly string[],
  oursLines: readonly string[],
  theirsLines: readonly string[],
): { readonly merged: readonly string[]; readonly conflicts: readonly { readonly ours: string; readonly theirs: string }[] } => {
  const baseDecls = parseDeclarations(baseLines);
  const oursDecls = parseDeclarations(oursLines);
  const theirsDecls = parseDeclarations(theirsLines);

  const baseMap = buildDeclMap(baseDecls);
  const oursMap = buildDeclMap(oursDecls);
  const theirsMap = buildDeclMap(theirsDecls);

  const allNames = new Set<string>();
  for (const decl of baseDecls) allNames.add(decl.name);
  for (const decl of oursDecls) allNames.add(decl.name);
  for (const decl of theirsDecls) allNames.add(decl.name);

  // Maintain ordering: start with ours order, then add theirs-only additions
  const orderedNames: string[] = [];
  const seen = new Set<string>();

  // Add all names in ours order
  for (const decl of oursDecls) {
    if (!seen.has(decl.name)) {
      orderedNames.push(decl.name);
      seen.add(decl.name);
    }
  }

  // Add theirs-only additions (not in base, not in ours)
  for (const decl of theirsDecls) {
    if (!seen.has(decl.name)) {
      // Find insertion point: after the declaration that precedes it in theirs
      const theirsIdx = theirsDecls.indexOf(decl);
      let insertAt = orderedNames.length;
      for (let k = theirsIdx - 1; k >= 0; k--) {
        const prevName = theirsDecls[k].name;
        const prevIdx = orderedNames.indexOf(prevName);
        if (prevIdx >= 0) {
          insertAt = prevIdx + 1;
          break;
        }
      }
      orderedNames.splice(insertAt, 0, decl.name);
      seen.add(decl.name);
    }
  }

  const mergedTexts: string[] = [];
  const conflicts: { readonly ours: string; readonly theirs: string }[] = [];

  for (const name of orderedNames) {
    const baseDecl = baseMap.get(name);
    const oursDecl = oursMap.get(name);
    const theirsDecl = theirsMap.get(name);

    if (baseDecl === undefined) {
      // New declaration: added by one or both sides
      if (oursDecl !== undefined && theirsDecl !== undefined) {
        if (oursDecl.text === theirsDecl.text) {
          // Both added identically
          mergedTexts.push(oursDecl.text);
        } else if (oursDecl.kind === 'import' && theirsDecl.kind === 'import') {
          // Both added different imports: include both (import union)
          mergedTexts.push(oursDecl.text);
          mergedTexts.push(theirsDecl.text);
        } else {
          // Both added differently: conflict
          mergedTexts.push(oursDecl.text); // include ours in output
          conflicts.push({ ours: oursDecl.text, theirs: theirsDecl.text });
        }
      } else if (oursDecl !== undefined) {
        mergedTexts.push(oursDecl.text);
      } else if (theirsDecl !== undefined) {
        mergedTexts.push(theirsDecl.text);
      }
      continue;
    }

    // Declaration exists in base
    const oursChanged = oursDecl !== undefined && oursDecl.text !== baseDecl.text;
    const theirsChanged = theirsDecl !== undefined && theirsDecl.text !== baseDecl.text;
    const oursDeleted = oursDecl === undefined;
    const theirsDeleted = theirsDecl === undefined;

    if (oursDeleted && theirsDeleted) {
      // Both deleted: skip
      continue;
    }
    if (oursDeleted && !theirsChanged) {
      // Ours deleted, theirs unchanged: keep deleted
      continue;
    }
    if (theirsDeleted && !oursChanged) {
      // Theirs deleted, ours unchanged: keep deleted
      continue;
    }
    if (oursDeleted && theirsChanged) {
      // Ours deleted but theirs modified: conflict
      conflicts.push({ ours: '(deleted)', theirs: theirsDecl!.text });
      mergedTexts.push(theirsDecl!.text);
      continue;
    }
    if (theirsDeleted && oursChanged) {
      // Theirs deleted but ours modified: conflict
      conflicts.push({ ours: oursDecl!.text, theirs: '(deleted)' });
      mergedTexts.push(oursDecl!.text);
      continue;
    }

    if (!oursChanged && !theirsChanged) {
      // Neither changed: keep base
      mergedTexts.push(baseDecl.text);
    } else if (oursChanged && !theirsChanged) {
      // Only ours changed: take ours
      mergedTexts.push(oursDecl!.text);
    } else if (!oursChanged && theirsChanged) {
      // Only theirs changed: take theirs
      mergedTexts.push(theirsDecl!.text);
    } else {
      // Both changed
      if (oursDecl!.text === theirsDecl!.text) {
        // Both changed identically: take one
        mergedTexts.push(oursDecl!.text);
      } else {
        // Both changed differently: conflict
        mergedTexts.push(oursDecl!.text);
        conflicts.push({ ours: oursDecl!.text, theirs: theirsDecl!.text });
      }
    }
  }

  return { merged: mergedTexts, conflicts };
};

const formatConflictRegion = (
  ours: string,
  theirs: string,
): string =>
  [
    '<<<<<<< ours',
    ours,
    '=======',
    theirs,
    '>>>>>>> theirs',
  ].join('\n');

// --- Implementation ---

export const semanticMergeHandler: SemanticMergeHandler = {
  register: (_input, _storage) =>
    TE.right(
      registerOk('semantic', 'merge', [
        'text/x-python',
        'text/typescript',
        'text/javascript',
        'text/x-java',
      ]),
    ),

  execute: (input, _storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const baseLines = splitLines(input.base);
          const oursLines = splitLines(input.ours);
          const theirsLines = splitLines(input.theirs);
          return { baseLines, oursLines, theirsLines };
        },
        (error): SemanticMergeError => ({
          code: 'DECODE_ERROR',
          message: `Failed to decode input buffers: ${error instanceof Error ? error.message : String(error)}`,
        }),
      ),
      TE.map(({ baseLines, oursLines, theirsLines }) => {
        const { merged, conflicts } = semanticThreeWayMerge(
          baseLines,
          oursLines,
          theirsLines,
        );

        if (conflicts.length === 0) {
          return executeClean(Buffer.from(merged.join('\n'), 'utf-8'));
        }

        const conflictRegions: Buffer[] = conflicts.map(c =>
          Buffer.from(formatConflictRegion(c.ours, c.theirs), 'utf-8'),
        );

        return executeConflicts(conflictRegions);
      }),
    ),
};
