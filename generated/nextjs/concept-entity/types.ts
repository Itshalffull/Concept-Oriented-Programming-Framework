// ConceptEntity â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

// Storage interface for ConceptEntity
export interface ConceptEntityStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface ConceptEntityRegisterInput {
  readonly name: string;
  readonly source: string;
  readonly ast: string;
}

export interface ConceptEntityRegisterOutputOk {
  readonly variant: 'ok';
  readonly entity: string;
}

export interface ConceptEntityRegisterOutputAlreadyRegistered {
  readonly variant: 'alreadyRegistered';
  readonly existing: string;
}

export type ConceptEntityRegisterOutput = ConceptEntityRegisterOutputOk | ConceptEntityRegisterOutputAlreadyRegistered;

export interface ConceptEntityGetInput {
  readonly name: string;
}

export interface ConceptEntityGetOutputOk {
  readonly variant: 'ok';
  readonly entity: string;
}

export interface ConceptEntityGetOutputNotfound {
  readonly variant: 'notfound';
}

export type ConceptEntityGetOutput = ConceptEntityGetOutputOk | ConceptEntityGetOutputNotfound;

export interface ConceptEntityFindByCapabilityInput {
  readonly capability: string;
}

export interface ConceptEntityFindByCapabilityOutput {
  readonly variant: 'ok';
  readonly entities: string;
}

export interface ConceptEntityFindByKitInput {
  readonly kit: string;
}

export interface ConceptEntityFindByKitOutput {
  readonly variant: 'ok';
  readonly entities: string;
}

export interface ConceptEntityGeneratedArtifactsInput {
  readonly entity: string;
}

export interface ConceptEntityGeneratedArtifactsOutput {
  readonly variant: 'ok';
  readonly artifacts: string;
}

export interface ConceptEntityParticipatingSyncsInput {
  readonly entity: string;
}

export interface ConceptEntityParticipatingSyncsOutput {
  readonly variant: 'ok';
  readonly syncs: string;
}

export interface ConceptEntityCheckCompatibilityInput {
  readonly a: string;
  readonly b: string;
}

export interface ConceptEntityCheckCompatibilityOutputCompatible {
  readonly variant: 'compatible';
  readonly sharedTypeParams: string;
}

export interface ConceptEntityCheckCompatibilityOutputIncompatible {
  readonly variant: 'incompatible';
  readonly reason: string;
}

export type ConceptEntityCheckCompatibilityOutput = ConceptEntityCheckCompatibilityOutputCompatible | ConceptEntityCheckCompatibilityOutputIncompatible;

// --- Variant constructors ---

export const registerOk = (entity: string): ConceptEntityRegisterOutput => ({ variant: 'ok', entity } as ConceptEntityRegisterOutput);
export const registerAlreadyRegistered = (existing: string): ConceptEntityRegisterOutput => ({ variant: 'alreadyRegistered', existing } as ConceptEntityRegisterOutput);

export const getOk = (entity: string): ConceptEntityGetOutput => ({ variant: 'ok', entity } as ConceptEntityGetOutput);
export const getNotfound = (): ConceptEntityGetOutput => ({ variant: 'notfound' } as ConceptEntityGetOutput);

export const findByCapabilityOk = (entities: string): ConceptEntityFindByCapabilityOutput => ({ variant: 'ok', entities } as ConceptEntityFindByCapabilityOutput);

export const findByKitOk = (entities: string): ConceptEntityFindByKitOutput => ({ variant: 'ok', entities } as ConceptEntityFindByKitOutput);

export const generatedArtifactsOk = (artifacts: string): ConceptEntityGeneratedArtifactsOutput => ({ variant: 'ok', artifacts } as ConceptEntityGeneratedArtifactsOutput);

export const participatingSyncsOk = (syncs: string): ConceptEntityParticipatingSyncsOutput => ({ variant: 'ok', syncs } as ConceptEntityParticipatingSyncsOutput);

export const checkCompatibilityCompatible = (sharedTypeParams: string): ConceptEntityCheckCompatibilityOutput => ({ variant: 'compatible', sharedTypeParams } as ConceptEntityCheckCompatibilityOutput);
export const checkCompatibilityIncompatible = (reason: string): ConceptEntityCheckCompatibilityOutput => ({ variant: 'incompatible', reason } as ConceptEntityCheckCompatibilityOutput);

