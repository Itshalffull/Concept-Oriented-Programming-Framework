// Emitter â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as O from 'fp-ts/Option';

// Storage interface for Emitter
export interface EmitterStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface EmitterWriteInput {
  readonly path: string;
  readonly content: string;
  readonly formatHint: O.Option<string>;
  readonly sources: O.Option<readonly { readonly sourcePath: string; readonly sourceRange: O.Option<string>; readonly conceptName: O.Option<string>; readonly actionName: O.Option<string> }[]>;
}

export interface EmitterWriteOutputOk {
  readonly variant: 'ok';
  readonly written: boolean;
  readonly path: string;
  readonly contentHash: string;
}

export interface EmitterWriteOutputError {
  readonly variant: 'error';
  readonly message: string;
  readonly path: string;
}

export type EmitterWriteOutput = EmitterWriteOutputOk | EmitterWriteOutputError;

export interface EmitterWriteBatchInput {
  readonly files: readonly { readonly path: string; readonly content: string; readonly formatHint: O.Option<string>; readonly sources: O.Option<readonly { readonly sourcePath: string; readonly sourceRange: O.Option<string>; readonly conceptName: O.Option<string>; readonly actionName: O.Option<string> }[]> }[];
}

export interface EmitterWriteBatchOutputOk {
  readonly variant: 'ok';
  readonly results: readonly { readonly path: string; readonly written: boolean; readonly contentHash: string }[];
}

export interface EmitterWriteBatchOutputError {
  readonly variant: 'error';
  readonly message: string;
  readonly failedPath: string;
}

export type EmitterWriteBatchOutput = EmitterWriteBatchOutputOk | EmitterWriteBatchOutputError;

export interface EmitterFormatInput {
  readonly path: string;
}

export interface EmitterFormatOutputOk {
  readonly variant: 'ok';
  readonly changed: boolean;
}

export interface EmitterFormatOutputError {
  readonly variant: 'error';
  readonly message: string;
}

export type EmitterFormatOutput = EmitterFormatOutputOk | EmitterFormatOutputError;

export interface EmitterCleanInput {
  readonly outputDir: string;
  readonly currentManifest: readonly string[];
}

export interface EmitterCleanOutput {
  readonly variant: 'ok';
  readonly removed: readonly string[];
}

export interface EmitterManifestInput {
  readonly outputDir: string;
}

export interface EmitterManifestOutput {
  readonly variant: 'ok';
  readonly files: readonly { readonly path: string; readonly hash: string; readonly lastWritten: Date }[];
}

export interface EmitterTraceInput {
  readonly outputPath: string;
}

export interface EmitterTraceOutputOk {
  readonly variant: 'ok';
  readonly sources: readonly { readonly sourcePath: string; readonly sourceRange: O.Option<string>; readonly conceptName: O.Option<string>; readonly actionName: O.Option<string> }[];
}

export interface EmitterTraceOutputNotFound {
  readonly variant: 'notFound';
  readonly path: string;
}

export type EmitterTraceOutput = EmitterTraceOutputOk | EmitterTraceOutputNotFound;

export interface EmitterAffectedInput {
  readonly sourcePath: string;
}

export interface EmitterAffectedOutput {
  readonly variant: 'ok';
  readonly outputs: readonly string[];
}

export interface EmitterAuditInput {
  readonly outputDir: string;
}

export interface EmitterAuditOutput {
  readonly variant: 'ok';
  readonly status: readonly { readonly path: string; readonly state: string; readonly expectedHash: O.Option<string>; readonly actualHash: O.Option<string> }[];
}

// --- Variant constructors ---

export const writeOk = (written: boolean, path: string, contentHash: string): EmitterWriteOutput => ({ variant: 'ok', written, path, contentHash } as EmitterWriteOutput);
export const writeError = (message: string, path: string): EmitterWriteOutput => ({ variant: 'error', message, path } as EmitterWriteOutput);

export const writeBatchOk = (results: readonly { readonly path: string; readonly written: boolean; readonly contentHash: string }[]): EmitterWriteBatchOutput => ({ variant: 'ok', results } as EmitterWriteBatchOutput);
export const writeBatchError = (message: string, failedPath: string): EmitterWriteBatchOutput => ({ variant: 'error', message, failedPath } as EmitterWriteBatchOutput);

export const formatOk = (changed: boolean): EmitterFormatOutput => ({ variant: 'ok', changed } as EmitterFormatOutput);
export const formatError = (message: string): EmitterFormatOutput => ({ variant: 'error', message } as EmitterFormatOutput);

export const cleanOk = (removed: readonly string[]): EmitterCleanOutput => ({ variant: 'ok', removed } as EmitterCleanOutput);

export const manifestOk = (files: readonly { readonly path: string; readonly hash: string; readonly lastWritten: Date }[]): EmitterManifestOutput => ({ variant: 'ok', files } as EmitterManifestOutput);

export const traceOk = (sources: readonly { readonly sourcePath: string; readonly sourceRange: O.Option<string>; readonly conceptName: O.Option<string>; readonly actionName: O.Option<string> }[]): EmitterTraceOutput => ({ variant: 'ok', sources } as EmitterTraceOutput);
export const traceNotFound = (path: string): EmitterTraceOutput => ({ variant: 'notFound', path } as EmitterTraceOutput);

export const affectedOk = (outputs: readonly string[]): EmitterAffectedOutput => ({ variant: 'ok', outputs } as EmitterAffectedOutput);

export const auditOk = (status: readonly { readonly path: string; readonly state: string; readonly expectedHash: O.Option<string>; readonly actualHash: O.Option<string> }[]): EmitterAuditOutput => ({ variant: 'ok', status } as EmitterAuditOutput);

