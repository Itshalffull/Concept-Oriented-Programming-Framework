// ScopeGraph â€” handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  ScopeGraphStorage,
  ScopeGraphBuildInput,
  ScopeGraphBuildOutput,
  ScopeGraphResolveReferenceInput,
  ScopeGraphResolveReferenceOutput,
  ScopeGraphVisibleSymbolsInput,
  ScopeGraphVisibleSymbolsOutput,
  ScopeGraphResolveCrossFileInput,
  ScopeGraphResolveCrossFileOutput,
  ScopeGraphGetInput,
  ScopeGraphGetOutput,
} from './types.js';

import {
  buildOk,
  buildUnsupportedLanguage,
  resolveReferenceOk,
  resolveReferenceUnresolved,
  resolveReferenceAmbiguous,
  visibleSymbolsOk,
  resolveCrossFileOk,
  resolveCrossFileNoUnresolved,
  getOk,
  getNotfound,
} from './types.js';

export interface ScopeGraphError {
  readonly code: string;
  readonly message: string;
}

export interface ScopeGraphHandler {
  readonly build: (
    input: ScopeGraphBuildInput,
    storage: ScopeGraphStorage,
  ) => TE.TaskEither<ScopeGraphError, ScopeGraphBuildOutput>;
  readonly resolveReference: (
    input: ScopeGraphResolveReferenceInput,
    storage: ScopeGraphStorage,
  ) => TE.TaskEither<ScopeGraphError, ScopeGraphResolveReferenceOutput>;
  readonly visibleSymbols: (
    input: ScopeGraphVisibleSymbolsInput,
    storage: ScopeGraphStorage,
  ) => TE.TaskEither<ScopeGraphError, ScopeGraphVisibleSymbolsOutput>;
  readonly resolveCrossFile: (
    input: ScopeGraphResolveCrossFileInput,
    storage: ScopeGraphStorage,
  ) => TE.TaskEither<ScopeGraphError, ScopeGraphResolveCrossFileOutput>;
  readonly get: (
    input: ScopeGraphGetInput,
    storage: ScopeGraphStorage,
  ) => TE.TaskEither<ScopeGraphError, ScopeGraphGetOutput>;
}

// --- Internal scope graph types ---

interface Scope {
  readonly id: string;
  readonly parentId: string | null;
  readonly declarations: readonly Declaration[];
  readonly references: readonly Reference[];
  readonly importEdges: readonly ImportEdge[];
}

interface Declaration {
  readonly name: string;
  readonly symbol: string;
  readonly scopeId: string;
  readonly exported: boolean;
}

interface Reference {
  readonly name: string;
  readonly scopeId: string;
  readonly resolvedSymbol: string | null;
}

interface ImportEdge {
  readonly fromScopeId: string;
  readonly toScopeId: string;
  readonly importedNames: readonly string[];
}

interface ScopeGraphData {
  readonly id: string;
  readonly file: string;
  readonly scopes: readonly Scope[];
  readonly declarations: readonly Declaration[];
  readonly references: readonly Reference[];
  readonly importEdges: readonly ImportEdge[];
}

const makeStorageError = (error: unknown): ScopeGraphError => ({
  code: 'STORAGE_ERROR',
  message: error instanceof Error ? error.message : String(error),
});

const generateId = (): string =>
  `sg-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;

const SUPPORTED_LANGUAGES: ReadonlySet<string> = new Set([
  'ts', 'tsx', 'js', 'jsx', 'rs', 'concept', 'sync', 'theme', 'widget',
]);

const detectLanguage = (file: string): O.Option<string> => {
  const ext = file.includes('.') ? file.split('.').pop() ?? '' : '';
  if (SUPPORTED_LANGUAGES.has(ext)) return O.some(ext);
  return O.none;
};

// Build a scope graph from a syntax tree representation (JSON).
// The tree is expected as a JSON string with scope/declaration/reference info.
const buildScopeGraph = (file: string, treeJson: string): E.Either<string, ScopeGraphData> => {
  let tree: Record<string, unknown>;
  try {
    tree = JSON.parse(treeJson);
  } catch {
    // If tree is not JSON, create a minimal scope graph with a global scope
    const globalScopeId = `scope-global-${generateId()}`;
    return E.right({
      id: generateId(),
      file,
      scopes: [{
        id: globalScopeId,
        parentId: null,
        declarations: [],
        references: [],
        importEdges: [],
      }],
      declarations: [],
      references: [],
      importEdges: [],
    });
  }

  const graphId = generateId();
  const scopes: Scope[] = [];
  const allDeclarations: Declaration[] = [];
  const allReferences: Reference[] = [];
  const allImportEdges: ImportEdge[] = [];

  // Parse scopes from the tree
  const rawScopes = Array.isArray(tree['scopes']) ? tree['scopes'] as readonly Record<string, unknown>[] : [];
  const rawDecls = Array.isArray(tree['declarations']) ? tree['declarations'] as readonly Record<string, unknown>[] : [];
  const rawRefs = Array.isArray(tree['references']) ? tree['references'] as readonly Record<string, unknown>[] : [];
  const rawImports = Array.isArray(tree['imports']) ? tree['imports'] as readonly Record<string, unknown>[] : [];

  // Create global scope if none provided
  if (rawScopes.length === 0) {
    const globalScopeId = `scope-global-${generateId()}`;
    scopes.push({
      id: globalScopeId,
      parentId: null,
      declarations: [],
      references: [],
      importEdges: [],
    });
  }

  for (const rawScope of rawScopes) {
    const scopeId = String(rawScope['id'] ?? generateId());
    const parentId = rawScope['parentId'] !== null && rawScope['parentId'] !== undefined
      ? String(rawScope['parentId'])
      : null;

    scopes.push({
      id: scopeId,
      parentId,
      declarations: [],
      references: [],
      importEdges: [],
    });
  }

  for (const rawDecl of rawDecls) {
    const decl: Declaration = {
      name: String(rawDecl['name'] ?? ''),
      symbol: String(rawDecl['symbol'] ?? rawDecl['name'] ?? ''),
      scopeId: String(rawDecl['scopeId'] ?? scopes[0]?.id ?? ''),
      exported: Boolean(rawDecl['exported'] ?? false),
    };
    allDeclarations.push(decl);
  }

  for (const rawRef of rawRefs) {
    const ref: Reference = {
      name: String(rawRef['name'] ?? ''),
      scopeId: String(rawRef['scopeId'] ?? scopes[0]?.id ?? ''),
      resolvedSymbol: null,
    };
    allReferences.push(ref);
  }

  for (const rawImport of rawImports) {
    const importEdge: ImportEdge = {
      fromScopeId: String(rawImport['fromScopeId'] ?? ''),
      toScopeId: String(rawImport['toScopeId'] ?? ''),
      importedNames: Array.isArray(rawImport['names'])
        ? (rawImport['names'] as readonly string[])
        : [],
    };
    allImportEdges.push(importEdge);
  }

  return E.right({
    id: graphId,
    file,
    scopes,
    declarations: allDeclarations,
    references: allReferences,
    importEdges: allImportEdges,
  });
};

// Resolve a name by walking the scope chain upward and following import edges
const resolveInScopeChain = (
  name: string,
  scopeId: string,
  graphData: ScopeGraphData,
): readonly Declaration[] => {
  const scopeMap = new Map<string, Scope>();
  for (const scope of graphData.scopes) {
    scopeMap.set(scope.id, scope);
  }

  const visited = new Set<string>();
  const matches: Declaration[] = [];

  const resolve = (currentScopeId: string): void => {
    if (visited.has(currentScopeId)) return;
    visited.add(currentScopeId);

    // Check declarations in current scope
    const scopeDecls = graphData.declarations.filter(
      (d) => d.scopeId === currentScopeId && d.name === name,
    );
    matches.push(...scopeDecls);

    // If found, stop (innermost scope wins)
    if (matches.length > 0) return;

    // Check import edges into this scope
    for (const importEdge of graphData.importEdges) {
      if (importEdge.toScopeId === currentScopeId) {
        if (importEdge.importedNames.length === 0 || importEdge.importedNames.includes(name)) {
          // Follow import edge to source scope
          const importedDecls = graphData.declarations.filter(
            (d) => d.scopeId === importEdge.fromScopeId && d.name === name && d.exported,
          );
          matches.push(...importedDecls);
        }
      }
    }

    if (matches.length > 0) return;

    // Walk up to parent scope
    const scope = scopeMap.get(currentScopeId);
    if (scope?.parentId !== null && scope?.parentId !== undefined) {
      resolve(scope.parentId);
    }
  };

  resolve(scopeId);
  return matches;
};

// Collect all symbols visible from a scope (scope chain + imports)
const collectVisibleSymbols = (
  scopeId: string,
  graphData: ScopeGraphData,
): readonly Declaration[] => {
  const scopeMap = new Map<string, Scope>();
  for (const scope of graphData.scopes) {
    scopeMap.set(scope.id, scope);
  }

  const visited = new Set<string>();
  const symbols: Declaration[] = [];
  const seenNames = new Set<string>();

  const collect = (currentScopeId: string): void => {
    if (visited.has(currentScopeId)) return;
    visited.add(currentScopeId);

    // Declarations in this scope (inner scopes shadow outer)
    for (const decl of graphData.declarations) {
      if (decl.scopeId === currentScopeId && !seenNames.has(decl.name)) {
        symbols.push(decl);
        seenNames.add(decl.name);
      }
    }

    // Imported declarations
    for (const importEdge of graphData.importEdges) {
      if (importEdge.toScopeId === currentScopeId) {
        for (const decl of graphData.declarations) {
          if (
            decl.scopeId === importEdge.fromScopeId &&
            decl.exported &&
            !seenNames.has(decl.name) &&
            (importEdge.importedNames.length === 0 || importEdge.importedNames.includes(decl.name))
          ) {
            symbols.push(decl);
            seenNames.add(decl.name);
          }
        }
      }
    }

    // Walk up to parent
    const scope = scopeMap.get(currentScopeId);
    if (scope?.parentId !== null && scope?.parentId !== undefined) {
      collect(scope.parentId);
    }
  };

  collect(scopeId);
  return symbols;
};

const loadGraphData = (
  storage: ScopeGraphStorage,
  graphId: string,
): TE.TaskEither<ScopeGraphError, O.Option<ScopeGraphData>> =>
  TE.tryCatch(
    async () => {
      const record = await storage.get('scope_graphs', graphId);
      return pipe(
        O.fromNullable(record),
        O.map((r) => ({
          id: String(r['id'] ?? ''),
          file: String(r['file'] ?? ''),
          scopes: JSON.parse(String(r['scopes'] ?? '[]')),
          declarations: JSON.parse(String(r['declarations'] ?? '[]')),
          references: JSON.parse(String(r['references'] ?? '[]')),
          importEdges: JSON.parse(String(r['importEdges'] ?? '[]')),
        })),
      );
    },
    makeStorageError,
  );

// --- Implementation ---

export const scopeGraphHandler: ScopeGraphHandler = {
  build: (input, storage) =>
    pipe(
      TE.of(detectLanguage(input.file)),
      TE.chain((langOpt) =>
        pipe(
          langOpt,
          O.fold(
            () => TE.right<ScopeGraphError, ScopeGraphBuildOutput>(
              buildUnsupportedLanguage(input.file.split('.').pop() ?? 'unknown'),
            ),
            (_lang) => {
              const graphResult = buildScopeGraph(input.file, input.tree);

              if (E.isLeft(graphResult)) {
                return TE.right<ScopeGraphError, ScopeGraphBuildOutput>(
                  buildUnsupportedLanguage(graphResult.left),
                );
              }

              const graphData = graphResult.right;

              return pipe(
                TE.tryCatch(
                  async () => {
                    await storage.put('scope_graphs', graphData.id, {
                      id: graphData.id,
                      file: input.file,
                      scopes: JSON.stringify(graphData.scopes),
                      declarations: JSON.stringify(graphData.declarations),
                      references: JSON.stringify(graphData.references),
                      importEdges: JSON.stringify(graphData.importEdges),
                    });
                    return buildOk(graphData.id);
                  },
                  makeStorageError,
                ),
              );
            },
          ),
        ),
      ),
    ),

  resolveReference: (input, storage) =>
    pipe(
      loadGraphData(storage, input.graph),
      TE.chain((optGraph) =>
        pipe(
          optGraph,
          O.fold(
            () => TE.right<ScopeGraphError, ScopeGraphResolveReferenceOutput>(
              resolveReferenceUnresolved(JSON.stringify([])),
            ),
            (graphData) => {
              const matches = resolveInScopeChain(input.name, input.scope, graphData);

              if (matches.length === 0) {
                // Gather near-miss candidates: declarations with similar names
                const allNames = graphData.declarations.map((d) => d.name);
                const candidates = allNames.filter((n) =>
                  n.toLowerCase().includes(input.name.toLowerCase()) ||
                  input.name.toLowerCase().includes(n.toLowerCase()),
                );
                return TE.right<ScopeGraphError, ScopeGraphResolveReferenceOutput>(
                  resolveReferenceUnresolved(JSON.stringify(candidates)),
                );
              }

              if (matches.length === 1) {
                return TE.right<ScopeGraphError, ScopeGraphResolveReferenceOutput>(
                  resolveReferenceOk(matches[0].symbol),
                );
              }

              // Multiple matches = ambiguous
              const symbols = matches.map((m) => m.symbol);
              return TE.right<ScopeGraphError, ScopeGraphResolveReferenceOutput>(
                resolveReferenceAmbiguous(JSON.stringify(symbols)),
              );
            },
          ),
        ),
      ),
    ),

  visibleSymbols: (input, storage) =>
    pipe(
      loadGraphData(storage, input.graph),
      TE.map((optGraph) =>
        pipe(
          optGraph,
          O.fold(
            () => visibleSymbolsOk(JSON.stringify([])),
            (graphData) => {
              const visible = collectVisibleSymbols(input.scope, graphData);
              const symbolNames = visible.map((d) => ({
                name: d.name,
                symbol: d.symbol,
                exported: d.exported,
              }));
              return visibleSymbolsOk(JSON.stringify(symbolNames));
            },
          ),
        ),
      ),
    ),

  resolveCrossFile: (input, storage) =>
    pipe(
      loadGraphData(storage, input.graph),
      TE.chain((optGraph) =>
        pipe(
          optGraph,
          O.fold(
            () => TE.right<ScopeGraphError, ScopeGraphResolveCrossFileOutput>(
              resolveCrossFileNoUnresolved(),
            ),
            (graphData) => {
              // Find unresolved references
              const unresolved = graphData.references.filter((r) => r.resolvedSymbol === null);

              if (unresolved.length === 0) {
                return TE.right<ScopeGraphError, ScopeGraphResolveCrossFileOutput>(
                  resolveCrossFileNoUnresolved(),
                );
              }

              return pipe(
                TE.tryCatch(
                  async () => {
                    // Load all other scope graphs to find exported declarations
                    const allGraphs = await storage.find('scope_graphs');
                    const otherGraphs = allGraphs.filter(
                      (g) => String(g['id'] ?? '') !== input.graph,
                    );

                    // Build a map of exported names -> symbols across all other files
                    const exportedSymbols = new Map<string, string[]>();
                    for (const otherRecord of otherGraphs) {
                      const otherDecls: readonly Declaration[] = JSON.parse(
                        String(otherRecord['declarations'] ?? '[]'),
                      );
                      for (const decl of otherDecls) {
                        if (decl.exported) {
                          const existing = exportedSymbols.get(decl.name) ?? [];
                          exportedSymbols.set(decl.name, [...existing, decl.symbol]);
                        }
                      }
                    }

                    // Try to resolve each unresolved reference
                    let resolvedCount = 0;
                    const updatedRefs = graphData.references.map((ref) => {
                      if (ref.resolvedSymbol !== null) return ref;
                      const candidates = exportedSymbols.get(ref.name);
                      if (candidates !== undefined && candidates.length === 1) {
                        resolvedCount++;
                        return { ...ref, resolvedSymbol: candidates[0] };
                      }
                      return ref;
                    });

                    // Persist updated references
                    await storage.put('scope_graphs', input.graph, {
                      id: graphData.id,
                      file: graphData.file,
                      scopes: JSON.stringify(graphData.scopes),
                      declarations: JSON.stringify(graphData.declarations),
                      references: JSON.stringify(updatedRefs),
                      importEdges: JSON.stringify(graphData.importEdges),
                    });

                    return resolveCrossFileOk(resolvedCount);
                  },
                  makeStorageError,
                ),
              );
            },
          ),
        ),
      ),
    ),

  get: (input, storage) =>
    pipe(
      loadGraphData(storage, input.graph),
      TE.map((optGraph) =>
        pipe(
          optGraph,
          O.fold(
            () => getNotfound() as ScopeGraphGetOutput,
            (graphData) => {
              const unresolvedCount = graphData.references.filter(
                (r) => r.resolvedSymbol === null,
              ).length;
              return getOk(
                graphData.id,
                graphData.file,
                graphData.scopes.length,
                graphData.declarations.length,
                unresolvedCount,
              );
            },
          ),
        ),
      ),
    ),
};
