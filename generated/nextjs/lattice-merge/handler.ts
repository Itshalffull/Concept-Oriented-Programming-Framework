// LatticeMerge â€” handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.
//
// Implements join-semilattice merge for CRDT-compatible data structures.
// The lattice join operation is conflict-free by construction: for any
// two states, the join produces a unique least upper bound. Supports
// G-Counter, PN-Counter, OR-Set, LWW-Register, and MV-Register CRDTs
// encoded as JSON with a "type" discriminator field.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  LatticeMergeStorage,
  LatticeMergeRegisterInput,
  LatticeMergeRegisterOutput,
  LatticeMergeExecuteInput,
  LatticeMergeExecuteOutput,
} from './types.js';

import {
  registerOk,
  executeClean,
  executeUnsupportedContent,
} from './types.js';

export interface LatticeMergeError {
  readonly code: string;
  readonly message: string;
}

export interface LatticeMergeHandler {
  readonly register: (
    input: LatticeMergeRegisterInput,
    storage: LatticeMergeStorage,
  ) => TE.TaskEither<LatticeMergeError, LatticeMergeRegisterOutput>;
  readonly execute: (
    input: LatticeMergeExecuteInput,
    storage: LatticeMergeStorage,
  ) => TE.TaskEither<LatticeMergeError, LatticeMergeExecuteOutput>;
}

// --- CRDT lattice type definitions ---

/**
 * G-Counter (Grow-only Counter):
 * Each replica has an entry; join = pointwise max.
 * { type: "g-counter", counters: { [replicaId]: number } }
 */
interface GCounter {
  readonly type: 'g-counter';
  readonly counters: Readonly<Record<string, number>>;
}

/**
 * PN-Counter (Positive-Negative Counter):
 * Two G-Counters: one for increments, one for decrements.
 * { type: "pn-counter", positive: { ... }, negative: { ... } }
 */
interface PNCounter {
  readonly type: 'pn-counter';
  readonly positive: Readonly<Record<string, number>>;
  readonly negative: Readonly<Record<string, number>>;
}

/**
 * OR-Set (Observed-Remove Set):
 * Each element is tagged with unique add-tokens; remove removes tokens.
 * { type: "or-set", elements: { [value]: string[] } }
 * where string[] are the surviving unique tags.
 */
interface ORSet {
  readonly type: 'or-set';
  readonly elements: Readonly<Record<string, readonly string[]>>;
}

/**
 * LWW-Register (Last-Writer-Wins Register):
 * { type: "lww-register", value: unknown, timestamp: number }
 */
interface LWWRegister {
  readonly type: 'lww-register';
  readonly value: unknown;
  readonly timestamp: number;
}

/**
 * MV-Register (Multi-Value Register):
 * Keeps all concurrent values; join merges value sets.
 * { type: "mv-register", values: { value: unknown, vclock: Record<string, number> }[] }
 */
interface MVRegister {
  readonly type: 'mv-register';
  readonly values: readonly { readonly value: unknown; readonly vclock: Readonly<Record<string, number>> }[];
}

type CRDTState = GCounter | PNCounter | ORSet | LWWRegister | MVRegister;

// --- Pure lattice join functions ---

/**
 * Pointwise max of two counter maps.
 */
const joinCounterMaps = (
  a: Readonly<Record<string, number>>,
  b: Readonly<Record<string, number>>,
): Readonly<Record<string, number>> => {
  const result: Record<string, number> = { ...a };
  for (const [key, val] of Object.entries(b)) {
    result[key] = Math.max(result[key] ?? 0, val);
  }
  return result;
};

/**
 * G-Counter lattice join: pointwise max of all replica counters.
 */
const joinGCounter = (a: GCounter, b: GCounter): GCounter => ({
  type: 'g-counter',
  counters: joinCounterMaps(a.counters, b.counters),
});

/**
 * PN-Counter lattice join: join both the positive and negative G-Counters.
 */
const joinPNCounter = (a: PNCounter, b: PNCounter): PNCounter => ({
  type: 'pn-counter',
  positive: joinCounterMaps(a.positive, b.positive),
  negative: joinCounterMaps(a.negative, b.negative),
});

/**
 * OR-Set lattice join: union of element tags.
 * An element is present if it has any surviving tags.
 */
const joinORSet = (a: ORSet, b: ORSet): ORSet => {
  const result: Record<string, string[]> = {};

  const allKeys = new Set([
    ...Object.keys(a.elements),
    ...Object.keys(b.elements),
  ]);

  for (const key of allKeys) {
    const tagsA = a.elements[key] ?? [];
    const tagsB = b.elements[key] ?? [];
    // Union of unique tags
    const tagSet = new Set([...tagsA, ...tagsB]);
    if (tagSet.size > 0) {
      result[key] = [...tagSet].sort();
    }
  }

  return { type: 'or-set', elements: result };
};

/**
 * LWW-Register lattice join: highest timestamp wins.
 * Ties broken by deterministic comparison of serialized values.
 */
const joinLWWRegister = (a: LWWRegister, b: LWWRegister): LWWRegister => {
  if (a.timestamp > b.timestamp) return a;
  if (b.timestamp > a.timestamp) return b;
  // Tie-break: deterministic string comparison of values
  const aStr = JSON.stringify(a.value);
  const bStr = JSON.stringify(b.value);
  return aStr >= bStr ? a : b;
};

/**
 * Check if vector clock a dominates (or equals) vector clock b.
 */
const vclockDominates = (
  a: Readonly<Record<string, number>>,
  b: Readonly<Record<string, number>>,
): boolean => {
  for (const [key, val] of Object.entries(b)) {
    if ((a[key] ?? 0) < val) return false;
  }
  return true;
};

/**
 * MV-Register lattice join: keep only values not dominated by
 * another value's vector clock. If a dominates b, drop b.
 */
const joinMVRegister = (a: MVRegister, b: MVRegister): MVRegister => {
  const allValues = [...a.values, ...b.values];

  // Remove dominated entries
  const surviving = allValues.filter((entry, idx) => {
    for (let other = 0; other < allValues.length; other++) {
      if (other === idx) continue;
      const otherEntry = allValues[other];
      // If other strictly dominates this entry, drop this entry
      if (
        vclockDominates(otherEntry.vclock, entry.vclock) &&
        JSON.stringify(otherEntry.vclock) !== JSON.stringify(entry.vclock)
      ) {
        return false;
      }
    }
    return true;
  });

  // Deduplicate by vclock identity
  const seen = new Set<string>();
  const deduped = surviving.filter(entry => {
    const key = JSON.stringify(entry.vclock) + '|' + JSON.stringify(entry.value);
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });

  return { type: 'mv-register', values: deduped };
};

/**
 * Parse a Buffer as a CRDT state JSON object.
 */
const parseCRDTState = (
  buf: Buffer,
  label: string,
): E.Either<LatticeMergeError, CRDTState> =>
  pipe(
    E.tryCatch(
      () => JSON.parse(buf.toString('utf-8')) as unknown,
      (error): LatticeMergeError => ({
        code: 'PARSE_ERROR',
        message: `Invalid JSON in ${label}: ${error instanceof Error ? error.message : String(error)}`,
      }),
    ),
    E.chain(parsed => {
      if (
        typeof parsed !== 'object' ||
        parsed === null ||
        !('type' in parsed)
      ) {
        return E.left({
          code: 'INVALID_CRDT',
          message: `${label} is not a recognized CRDT lattice type: missing "type" field`,
        });
      }
      const obj = parsed as Record<string, unknown>;
      const validTypes = ['g-counter', 'pn-counter', 'or-set', 'lww-register', 'mv-register'];
      if (!validTypes.includes(obj.type as string)) {
        return E.left({
          code: 'UNSUPPORTED_CRDT',
          message: `${label} has unsupported CRDT type "${obj.type}". Supported: ${validTypes.join(', ')}`,
        });
      }
      return E.right(parsed as CRDTState);
    }),
  );

/**
 * Compute the lattice join of two CRDT states.
 * Both must be the same CRDT type.
 */
const latticeJoin = (
  a: CRDTState,
  b: CRDTState,
): E.Either<LatticeMergeError, CRDTState> => {
  if (a.type !== b.type) {
    return E.left({
      code: 'TYPE_MISMATCH',
      message: `Cannot join CRDT types "${a.type}" and "${b.type}": types must match`,
    });
  }

  switch (a.type) {
    case 'g-counter':
      return E.right(joinGCounter(a, b as GCounter));
    case 'pn-counter':
      return E.right(joinPNCounter(a, b as PNCounter));
    case 'or-set':
      return E.right(joinORSet(a, b as ORSet));
    case 'lww-register':
      return E.right(joinLWWRegister(a, b as LWWRegister));
    case 'mv-register':
      return E.right(joinMVRegister(a, b as MVRegister));
    default: {
      const _exhaustive: never = a;
      return E.left({
        code: 'UNSUPPORTED_CRDT',
        message: `Unsupported CRDT type`,
      });
    }
  }
};

// --- Implementation ---

export const latticeMergeHandler: LatticeMergeHandler = {
  register: (_input, _storage) =>
    TE.right(
      registerOk('lattice', 'merge', ['application/crdt+json']),
    ),

  execute: (input, _storage) =>
    pipe(
      // Parse both ours and theirs as CRDT states
      // Base is used for provenance but the lattice join is defined
      // on the two divergent states alone (it is commutative + idempotent)
      TE.fromEither(
        pipe(
          parseCRDTState(input.ours, 'ours'),
          E.chain(oursState =>
            pipe(
              parseCRDTState(input.theirs, 'theirs'),
              E.map(theirsState => ({ oursState, theirsState })),
            ),
          ),
        ),
      ),
      TE.chain(({ oursState, theirsState }) =>
        pipe(
          latticeJoin(oursState, theirsState),
          E.fold(
            err => TE.left(err),
            joined => TE.right(
              executeClean(Buffer.from(JSON.stringify(joined, null, 2), 'utf-8')),
            ),
          ),
        ),
      ),
    ),
};
