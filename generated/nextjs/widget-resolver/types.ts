// WidgetResolver â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

// Storage interface for WidgetResolver
export interface WidgetResolverStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface WidgetResolverResolveInput {
  readonly resolver: string;
  readonly element: string;
  readonly context: string;
}

export interface WidgetResolverResolveOutputOk {
  readonly variant: 'ok';
  readonly resolver: string;
  readonly widget: string;
  readonly score: number;
  readonly reason: string;
}

export interface WidgetResolverResolveOutputAmbiguous {
  readonly variant: 'ambiguous';
  readonly resolver: string;
  readonly candidates: string;
}

export interface WidgetResolverResolveOutputNone {
  readonly variant: 'none';
  readonly resolver: string;
  readonly element: string;
}

export type WidgetResolverResolveOutput = WidgetResolverResolveOutputOk | WidgetResolverResolveOutputAmbiguous | WidgetResolverResolveOutputNone;

export interface WidgetResolverResolveAllInput {
  readonly resolver: string;
  readonly elements: string;
  readonly context: string;
}

export interface WidgetResolverResolveAllOutputOk {
  readonly variant: 'ok';
  readonly resolver: string;
  readonly resolutions: string;
}

export interface WidgetResolverResolveAllOutputPartial {
  readonly variant: 'partial';
  readonly resolver: string;
  readonly resolved: string;
  readonly unresolved: string;
}

export type WidgetResolverResolveAllOutput = WidgetResolverResolveAllOutputOk | WidgetResolverResolveAllOutputPartial;

export interface WidgetResolverOverrideInput {
  readonly resolver: string;
  readonly element: string;
  readonly widget: string;
}

export interface WidgetResolverOverrideOutputOk {
  readonly variant: 'ok';
  readonly resolver: string;
}

export interface WidgetResolverOverrideOutputInvalid {
  readonly variant: 'invalid';
  readonly message: string;
}

export type WidgetResolverOverrideOutput = WidgetResolverOverrideOutputOk | WidgetResolverOverrideOutputInvalid;

export interface WidgetResolverSetWeightsInput {
  readonly resolver: string;
  readonly weights: string;
}

export interface WidgetResolverSetWeightsOutputOk {
  readonly variant: 'ok';
  readonly resolver: string;
}

export interface WidgetResolverSetWeightsOutputInvalid {
  readonly variant: 'invalid';
  readonly message: string;
}

export type WidgetResolverSetWeightsOutput = WidgetResolverSetWeightsOutputOk | WidgetResolverSetWeightsOutputInvalid;

export interface WidgetResolverExplainInput {
  readonly resolver: string;
  readonly element: string;
  readonly context: string;
}

export interface WidgetResolverExplainOutputOk {
  readonly variant: 'ok';
  readonly resolver: string;
  readonly explanation: string;
}

export interface WidgetResolverExplainOutputNotfound {
  readonly variant: 'notfound';
  readonly message: string;
}

export type WidgetResolverExplainOutput = WidgetResolverExplainOutputOk | WidgetResolverExplainOutputNotfound;

// --- Variant constructors ---

export const resolveOk = (resolver: string, widget: string, score: number, reason: string): WidgetResolverResolveOutput => ({ variant: 'ok', resolver, widget, score, reason } as WidgetResolverResolveOutput);
export const resolveAmbiguous = (resolver: string, candidates: string): WidgetResolverResolveOutput => ({ variant: 'ambiguous', resolver, candidates } as WidgetResolverResolveOutput);
export const resolveNone = (resolver: string, element: string): WidgetResolverResolveOutput => ({ variant: 'none', resolver, element } as WidgetResolverResolveOutput);

export const resolveAllOk = (resolver: string, resolutions: string): WidgetResolverResolveAllOutput => ({ variant: 'ok', resolver, resolutions } as WidgetResolverResolveAllOutput);
export const resolveAllPartial = (resolver: string, resolved: string, unresolved: string): WidgetResolverResolveAllOutput => ({ variant: 'partial', resolver, resolved, unresolved } as WidgetResolverResolveAllOutput);

export const overrideOk = (resolver: string): WidgetResolverOverrideOutput => ({ variant: 'ok', resolver } as WidgetResolverOverrideOutput);
export const overrideInvalid = (message: string): WidgetResolverOverrideOutput => ({ variant: 'invalid', message } as WidgetResolverOverrideOutput);

export const setWeightsOk = (resolver: string): WidgetResolverSetWeightsOutput => ({ variant: 'ok', resolver } as WidgetResolverSetWeightsOutput);
export const setWeightsInvalid = (message: string): WidgetResolverSetWeightsOutput => ({ variant: 'invalid', message } as WidgetResolverSetWeightsOutput);

export const explainOk = (resolver: string, explanation: string): WidgetResolverExplainOutput => ({ variant: 'ok', resolver, explanation } as WidgetResolverExplainOutput);
export const explainNotfound = (message: string): WidgetResolverExplainOutput => ({ variant: 'notfound', message } as WidgetResolverExplainOutput);

