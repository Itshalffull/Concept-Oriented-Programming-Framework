// Patch â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

// Storage interface for Patch
export interface PatchStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface PatchCreateInput {
  readonly base: string;
  readonly target: string;
  readonly effect: Buffer;
}

export interface PatchCreateOutputOk {
  readonly variant: 'ok';
  readonly patchId: string;
}

export interface PatchCreateOutputInvalidEffect {
  readonly variant: 'invalidEffect';
  readonly message: string;
}

export type PatchCreateOutput = PatchCreateOutputOk | PatchCreateOutputInvalidEffect;

export interface PatchApplyInput {
  readonly patchId: string;
  readonly content: Buffer;
}

export interface PatchApplyOutputOk {
  readonly variant: 'ok';
  readonly result: Buffer;
}

export interface PatchApplyOutputIncompatibleContext {
  readonly variant: 'incompatibleContext';
  readonly message: string;
}

export interface PatchApplyOutputNotFound {
  readonly variant: 'notFound';
  readonly message: string;
}

export type PatchApplyOutput = PatchApplyOutputOk | PatchApplyOutputIncompatibleContext | PatchApplyOutputNotFound;

export interface PatchInvertInput {
  readonly patchId: string;
}

export interface PatchInvertOutputOk {
  readonly variant: 'ok';
  readonly inversePatchId: string;
}

export interface PatchInvertOutputNotFound {
  readonly variant: 'notFound';
  readonly message: string;
}

export type PatchInvertOutput = PatchInvertOutputOk | PatchInvertOutputNotFound;

export interface PatchComposeInput {
  readonly first: string;
  readonly second: string;
}

export interface PatchComposeOutputOk {
  readonly variant: 'ok';
  readonly composedId: string;
}

export interface PatchComposeOutputNonSequential {
  readonly variant: 'nonSequential';
  readonly message: string;
}

export interface PatchComposeOutputNotFound {
  readonly variant: 'notFound';
  readonly message: string;
}

export type PatchComposeOutput = PatchComposeOutputOk | PatchComposeOutputNonSequential | PatchComposeOutputNotFound;

export interface PatchCommuteInput {
  readonly p1: string;
  readonly p2: string;
}

export interface PatchCommuteOutputOk {
  readonly variant: 'ok';
  readonly p1Prime: string;
  readonly p2Prime: string;
}

export interface PatchCommuteOutputCannotCommute {
  readonly variant: 'cannotCommute';
  readonly message: string;
}

export interface PatchCommuteOutputNotFound {
  readonly variant: 'notFound';
  readonly message: string;
}

export type PatchCommuteOutput = PatchCommuteOutputOk | PatchCommuteOutputCannotCommute | PatchCommuteOutputNotFound;

// --- Variant constructors ---

export const createOk = (patchId: string): PatchCreateOutput => ({ variant: 'ok', patchId } as PatchCreateOutput);
export const createInvalidEffect = (message: string): PatchCreateOutput => ({ variant: 'invalidEffect', message } as PatchCreateOutput);

export const applyOk = (result: Buffer): PatchApplyOutput => ({ variant: 'ok', result } as PatchApplyOutput);
export const applyIncompatibleContext = (message: string): PatchApplyOutput => ({ variant: 'incompatibleContext', message } as PatchApplyOutput);
export const applyNotFound = (message: string): PatchApplyOutput => ({ variant: 'notFound', message } as PatchApplyOutput);

export const invertOk = (inversePatchId: string): PatchInvertOutput => ({ variant: 'ok', inversePatchId } as PatchInvertOutput);
export const invertNotFound = (message: string): PatchInvertOutput => ({ variant: 'notFound', message } as PatchInvertOutput);

export const composeOk = (composedId: string): PatchComposeOutput => ({ variant: 'ok', composedId } as PatchComposeOutput);
export const composeNonSequential = (message: string): PatchComposeOutput => ({ variant: 'nonSequential', message } as PatchComposeOutput);
export const composeNotFound = (message: string): PatchComposeOutput => ({ variant: 'notFound', message } as PatchComposeOutput);

export const commuteOk = (p1Prime: string, p2Prime: string): PatchCommuteOutput => ({ variant: 'ok', p1Prime, p2Prime } as PatchCommuteOutput);
export const commuteCannotCommute = (message: string): PatchCommuteOutput => ({ variant: 'cannotCommute', message } as PatchCommuteOutput);
export const commuteNotFound = (message: string): PatchCommuteOutput => ({ variant: 'notFound', message } as PatchCommuteOutput);

