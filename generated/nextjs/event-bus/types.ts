// EventBus â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

// Storage interface for EventBus
export interface EventBusStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface EventBusRegisterEventTypeInput {
  readonly name: string;
  readonly schema: string;
}

export interface EventBusRegisterEventTypeOutputOk {
  readonly variant: 'ok';
}

export interface EventBusRegisterEventTypeOutputExists {
  readonly variant: 'exists';
}

export type EventBusRegisterEventTypeOutput = EventBusRegisterEventTypeOutputOk | EventBusRegisterEventTypeOutputExists;

export interface EventBusSubscribeInput {
  readonly event: string;
  readonly handler: string;
  readonly priority: number;
}

export interface EventBusSubscribeOutput {
  readonly variant: 'ok';
  readonly subscriptionId: string;
}

export interface EventBusUnsubscribeInput {
  readonly subscriptionId: string;
}

export interface EventBusUnsubscribeOutputOk {
  readonly variant: 'ok';
}

export interface EventBusUnsubscribeOutputNotfound {
  readonly variant: 'notfound';
}

export type EventBusUnsubscribeOutput = EventBusUnsubscribeOutputOk | EventBusUnsubscribeOutputNotfound;

export interface EventBusDispatchInput {
  readonly event: string;
  readonly data: string;
}

export interface EventBusDispatchOutputOk {
  readonly variant: 'ok';
  readonly results: string;
}

export interface EventBusDispatchOutputError {
  readonly variant: 'error';
  readonly message: string;
}

export type EventBusDispatchOutput = EventBusDispatchOutputOk | EventBusDispatchOutputError;

export interface EventBusDispatchAsyncInput {
  readonly event: string;
  readonly data: string;
}

export interface EventBusDispatchAsyncOutputOk {
  readonly variant: 'ok';
  readonly jobId: string;
}

export interface EventBusDispatchAsyncOutputError {
  readonly variant: 'error';
  readonly message: string;
}

export type EventBusDispatchAsyncOutput = EventBusDispatchAsyncOutputOk | EventBusDispatchAsyncOutputError;

export interface EventBusGetHistoryInput {
  readonly event: string;
  readonly limit: number;
}

export interface EventBusGetHistoryOutput {
  readonly variant: 'ok';
  readonly entries: string;
}

// --- Variant constructors ---

export const registerEventTypeOk = (): EventBusRegisterEventTypeOutput => ({ variant: 'ok' } as EventBusRegisterEventTypeOutput);
export const registerEventTypeExists = (): EventBusRegisterEventTypeOutput => ({ variant: 'exists' } as EventBusRegisterEventTypeOutput);

export const subscribeOk = (subscriptionId: string): EventBusSubscribeOutput => ({ variant: 'ok', subscriptionId } as EventBusSubscribeOutput);

export const unsubscribeOk = (): EventBusUnsubscribeOutput => ({ variant: 'ok' } as EventBusUnsubscribeOutput);
export const unsubscribeNotfound = (): EventBusUnsubscribeOutput => ({ variant: 'notfound' } as EventBusUnsubscribeOutput);

export const dispatchOk = (results: string): EventBusDispatchOutput => ({ variant: 'ok', results } as EventBusDispatchOutput);
export const dispatchError = (message: string): EventBusDispatchOutput => ({ variant: 'error', message } as EventBusDispatchOutput);

export const dispatchAsyncOk = (jobId: string): EventBusDispatchAsyncOutput => ({ variant: 'ok', jobId } as EventBusDispatchAsyncOutput);
export const dispatchAsyncError = (message: string): EventBusDispatchAsyncOutput => ({ variant: 'error', message } as EventBusDispatchAsyncOutput);

export const getHistoryOk = (entries: string): EventBusGetHistoryOutput => ({ variant: 'ok', entries } as EventBusGetHistoryOutput);

