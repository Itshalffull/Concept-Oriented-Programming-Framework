// Symbol â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

// Storage interface for Symbol
export interface SymbolStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface SymbolRegisterInput {
  readonly symbolString: string;
  readonly kind: string;
  readonly displayName: string;
  readonly definingFile: string;
}

export interface SymbolRegisterOutputOk {
  readonly variant: 'ok';
  readonly symbol: string;
}

export interface SymbolRegisterOutputAlreadyExists {
  readonly variant: 'alreadyExists';
  readonly existing: string;
}

export type SymbolRegisterOutput = SymbolRegisterOutputOk | SymbolRegisterOutputAlreadyExists;

export interface SymbolResolveInput {
  readonly symbolString: string;
}

export interface SymbolResolveOutputOk {
  readonly variant: 'ok';
  readonly symbol: string;
}

export interface SymbolResolveOutputNotfound {
  readonly variant: 'notfound';
}

export interface SymbolResolveOutputAmbiguous {
  readonly variant: 'ambiguous';
  readonly candidates: string;
}

export type SymbolResolveOutput = SymbolResolveOutputOk | SymbolResolveOutputNotfound | SymbolResolveOutputAmbiguous;

export interface SymbolFindByKindInput {
  readonly kind: string;
  readonly namespace: string;
}

export interface SymbolFindByKindOutput {
  readonly variant: 'ok';
  readonly symbols: string;
}

export interface SymbolFindByFileInput {
  readonly file: string;
}

export interface SymbolFindByFileOutput {
  readonly variant: 'ok';
  readonly symbols: string;
}

export interface SymbolRenameInput {
  readonly symbol: string;
  readonly newName: string;
}

export interface SymbolRenameOutputOk {
  readonly variant: 'ok';
  readonly oldName: string;
  readonly occurrencesUpdated: number;
}

export interface SymbolRenameOutputConflict {
  readonly variant: 'conflict';
  readonly conflicting: string;
}

export interface SymbolRenameOutputNotfound {
  readonly variant: 'notfound';
}

export type SymbolRenameOutput = SymbolRenameOutputOk | SymbolRenameOutputConflict | SymbolRenameOutputNotfound;

export interface SymbolGetInput {
  readonly symbol: string;
}

export interface SymbolGetOutputOk {
  readonly variant: 'ok';
  readonly symbol: string;
  readonly symbolString: string;
  readonly kind: string;
  readonly displayName: string;
  readonly visibility: string;
  readonly definingFile: string;
  readonly namespace: string;
}

export interface SymbolGetOutputNotfound {
  readonly variant: 'notfound';
}

export type SymbolGetOutput = SymbolGetOutputOk | SymbolGetOutputNotfound;

// --- Variant constructors ---

export const registerOk = (symbol: string): SymbolRegisterOutput => ({ variant: 'ok', symbol } as SymbolRegisterOutput);
export const registerAlreadyExists = (existing: string): SymbolRegisterOutput => ({ variant: 'alreadyExists', existing } as SymbolRegisterOutput);

export const resolveOk = (symbol: string): SymbolResolveOutput => ({ variant: 'ok', symbol } as SymbolResolveOutput);
export const resolveNotfound = (): SymbolResolveOutput => ({ variant: 'notfound' } as SymbolResolveOutput);
export const resolveAmbiguous = (candidates: string): SymbolResolveOutput => ({ variant: 'ambiguous', candidates } as SymbolResolveOutput);

export const findByKindOk = (symbols: string): SymbolFindByKindOutput => ({ variant: 'ok', symbols } as SymbolFindByKindOutput);

export const findByFileOk = (symbols: string): SymbolFindByFileOutput => ({ variant: 'ok', symbols } as SymbolFindByFileOutput);

export const renameOk = (oldName: string, occurrencesUpdated: number): SymbolRenameOutput => ({ variant: 'ok', oldName, occurrencesUpdated } as SymbolRenameOutput);
export const renameConflict = (conflicting: string): SymbolRenameOutput => ({ variant: 'conflict', conflicting } as SymbolRenameOutput);
export const renameNotfound = (): SymbolRenameOutput => ({ variant: 'notfound' } as SymbolRenameOutput);

export const getOk = (symbol: string, symbolString: string, kind: string, displayName: string, visibility: string, definingFile: string, namespace: string): SymbolGetOutput => ({ variant: 'ok', symbol, symbolString, kind, displayName, visibility, definingFile, namespace } as SymbolGetOutput);
export const getNotfound = (): SymbolGetOutput => ({ variant: 'notfound' } as SymbolGetOutput);

