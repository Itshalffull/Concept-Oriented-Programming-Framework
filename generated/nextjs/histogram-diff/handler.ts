// HistogramDiff â€” handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.
//
// Implements the Histogram Diff algorithm, a variant of Patience Diff
// used by JGit and git (diff.algorithm=histogram). Instead of requiring
// unique lines, it builds frequency histograms and anchors on the
// lowest-occurrence common lines, making it superior for source code
// with common boilerplate (e.g., closing braces, blank lines).

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  HistogramDiffStorage,
  HistogramDiffRegisterInput,
  HistogramDiffRegisterOutput,
  HistogramDiffComputeInput,
  HistogramDiffComputeOutput,
} from './types.js';

import {
  registerOk,
  computeOk,
  computeUnsupportedContent,
} from './types.js';

export interface HistogramDiffError {
  readonly code: string;
  readonly message: string;
}

export interface HistogramDiffHandler {
  readonly register: (
    input: HistogramDiffRegisterInput,
    storage: HistogramDiffStorage,
  ) => TE.TaskEither<HistogramDiffError, HistogramDiffRegisterOutput>;
  readonly compute: (
    input: HistogramDiffComputeInput,
    storage: HistogramDiffStorage,
  ) => TE.TaskEither<HistogramDiffError, HistogramDiffComputeOutput>;
}

// --- Edit operation types ---

type EditOp =
  | { readonly type: 'keep'; readonly line: string }
  | { readonly type: 'insert'; readonly line: string }
  | { readonly type: 'delete'; readonly line: string };

// --- Pure helper functions ---

const splitLines = (buf: Buffer): readonly string[] =>
  buf.toString('utf-8').split('\n');

const serializeEditScript = (ops: readonly EditOp[]): Buffer =>
  Buffer.from(
    JSON.stringify(ops.map(op => ({ t: op.type[0], l: op.line }))),
    'utf-8',
  );

const countDistance = (ops: readonly EditOp[]): number =>
  ops.reduce((acc, op) => acc + (op.type === 'keep' ? 0 : 1), 0);

/**
 * Build a histogram (frequency count) for lines in a slice.
 */
const buildHistogram = (
  lines: readonly string[],
  lo: number,
  hi: number,
): ReadonlyMap<string, number> => {
  const hist = new Map<string, number>();
  for (let i = lo; i < hi; i++) {
    const line = lines[i];
    hist.set(line, (hist.get(line) ?? 0) + 1);
  }
  return hist;
};

/**
 * For each line in A[aLo..aHi), record its first occurrence index,
 * keyed by line content.
 */
const buildFirstOccurrenceMap = (
  lines: readonly string[],
  lo: number,
  hi: number,
): ReadonlyMap<string, number> => {
  const map = new Map<string, number>();
  for (let i = lo; i < hi; i++) {
    const line = lines[i];
    if (!map.has(line)) {
      map.set(line, i);
    }
  }
  return map;
};

/**
 * Find the best (lowest-frequency) common line region to use as an anchor.
 * Scans B for the line with the lowest combined frequency in both A and B
 * histograms that also appears in A. Returns the first such match.
 */
const findLowestFrequencyAnchor = (
  a: readonly string[],
  aLo: number,
  aHi: number,
  b: readonly string[],
  bLo: number,
  bHi: number,
): O.Option<{ readonly aIdx: number; readonly bIdx: number }> => {
  const histA = buildHistogram(a, aLo, aHi);
  const histB = buildHistogram(b, bLo, bHi);
  const firstA = buildFirstOccurrenceMap(a, aLo, aHi);

  let bestScore = Infinity;
  let bestAIdx = -1;
  let bestBIdx = -1;

  for (let j = bLo; j < bHi; j++) {
    const line = b[j];
    const freqA = histA.get(line);
    if (freqA === undefined) continue; // not in A

    const freqB = histB.get(line) ?? 0;
    // Combined frequency score: lower is better
    // We prefer lines that are rare in both sequences
    const score = freqA + freqB;

    if (score < bestScore) {
      bestScore = score;
      bestAIdx = firstA.get(line)!;
      bestBIdx = j;
    }
  }

  return bestAIdx >= 0 ? O.some({ aIdx: bestAIdx, bIdx: bestBIdx }) : O.none;
};

/**
 * Extend an anchor point by matching equal lines before and after it.
 * Returns the expanded range of matching lines.
 */
const extendAnchor = (
  a: readonly string[],
  aLo: number,
  aHi: number,
  b: readonly string[],
  bLo: number,
  bHi: number,
  aIdx: number,
  bIdx: number,
): { readonly aStart: number; readonly aEnd: number; readonly bStart: number; readonly bEnd: number } => {
  // Extend backward
  let aStart = aIdx;
  let bStart = bIdx;
  while (aStart > aLo && bStart > bLo && a[aStart - 1] === b[bStart - 1]) {
    aStart--;
    bStart--;
  }

  // Extend forward
  let aEnd = aIdx + 1;
  let bEnd = bIdx + 1;
  while (aEnd < aHi && bEnd < bHi && a[aEnd] === b[bEnd]) {
    aEnd++;
    bEnd++;
  }

  return { aStart, aEnd, bStart, bEnd };
};

/**
 * Core histogram diff: recursively diff using low-frequency anchors.
 */
const histogramDiffRec = (
  a: readonly string[],
  aLo: number,
  aHi: number,
  b: readonly string[],
  bLo: number,
  bHi: number,
  depth: number,
): readonly EditOp[] => {
  // Base cases
  if (aLo === aHi && bLo === bHi) return [];
  if (aLo === aHi) {
    const ops: EditOp[] = [];
    for (let j = bLo; j < bHi; j++) {
      ops.push({ type: 'insert', line: b[j] });
    }
    return ops;
  }
  if (bLo === bHi) {
    const ops: EditOp[] = [];
    for (let i = aLo; i < aHi; i++) {
      ops.push({ type: 'delete', line: a[i] });
    }
    return ops;
  }

  // Recursion depth guard: fall back to LCS for deeply nested regions
  if (depth > 64) {
    return lcsFallback(a, aLo, aHi, b, bLo, bHi);
  }

  return pipe(
    findLowestFrequencyAnchor(a, aLo, aHi, b, bLo, bHi),
    O.fold(
      // No common lines: all A is deleted, all B is inserted
      () => lcsFallback(a, aLo, aHi, b, bLo, bHi),
      ({ aIdx, bIdx }) => {
        // Extend the anchor to a matching region
        const region = extendAnchor(a, aLo, aHi, b, bLo, bHi, aIdx, bIdx);

        const ops: EditOp[] = [];

        // Recurse on the region before the anchor
        ops.push(...histogramDiffRec(a, aLo, region.aStart, b, bLo, region.bStart, depth + 1));

        // Emit keeps for the anchor region
        for (let i = region.aStart; i < region.aEnd; i++) {
          ops.push({ type: 'keep', line: a[i] });
        }

        // Recurse on the region after the anchor
        ops.push(...histogramDiffRec(a, region.aEnd, aHi, b, region.bEnd, bHi, depth + 1));

        return ops;
      },
    ),
  );
};

/**
 * LCS-based fallback diff for regions with no good anchors.
 */
const lcsFallback = (
  a: readonly string[],
  aLo: number,
  aHi: number,
  b: readonly string[],
  bLo: number,
  bHi: number,
): readonly EditOp[] => {
  const n = aHi - aLo;
  const m = bHi - bLo;

  const dp: number[][] = Array.from({ length: n + 1 }, () =>
    new Array<number>(m + 1).fill(0),
  );

  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= m; j++) {
      if (a[aLo + i - 1] === b[bLo + j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  const ops: EditOp[] = [];
  let i = n;
  let j = m;

  while (i > 0 || j > 0) {
    if (i > 0 && j > 0 && a[aLo + i - 1] === b[bLo + j - 1]) {
      ops.push({ type: 'keep', line: a[aLo + i - 1] });
      i--;
      j--;
    } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
      ops.push({ type: 'insert', line: b[bLo + j - 1] });
      j--;
    } else {
      ops.push({ type: 'delete', line: a[aLo + i - 1] });
      i--;
    }
  }

  ops.reverse();
  return ops;
};

// --- Implementation ---

export const histogramDiffHandler: HistogramDiffHandler = {
  register: (_input, _storage) =>
    TE.right(
      registerOk('histogram', 'diff', ['text/plain', 'text/*']),
    ),

  compute: (input, _storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const linesA = splitLines(input.contentA);
          const linesB = splitLines(input.contentB);
          return { linesA, linesB };
        },
        (error): HistogramDiffError => ({
          code: 'DECODE_ERROR',
          message: `Failed to decode input buffers: ${error instanceof Error ? error.message : String(error)}`,
        }),
      ),
      TE.map(({ linesA, linesB }) => {
        const ops = histogramDiffRec(linesA, 0, linesA.length, linesB, 0, linesB.length, 0);
        const distance = countDistance(ops);
        return computeOk(serializeEditScript(ops), distance);
      }),
    ),
};
