// RetentionPolicy â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as O from 'fp-ts/Option';

// Storage interface for RetentionPolicy
export interface RetentionPolicyStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface RetentionPolicySetRetentionInput {
  readonly recordType: string;
  readonly period: number;
  readonly unit: string;
  readonly dispositionAction: string;
}

export interface RetentionPolicySetRetentionOutputOk {
  readonly variant: 'ok';
  readonly policyId: string;
}

export interface RetentionPolicySetRetentionOutputAlreadyExists {
  readonly variant: 'alreadyExists';
  readonly message: string;
}

export type RetentionPolicySetRetentionOutput = RetentionPolicySetRetentionOutputOk | RetentionPolicySetRetentionOutputAlreadyExists;

export interface RetentionPolicyApplyHoldInput {
  readonly name: string;
  readonly scope: string;
  readonly reason: string;
  readonly issuer: string;
}

export interface RetentionPolicyApplyHoldOutput {
  readonly variant: 'ok';
  readonly holdId: unknown;
}

export interface RetentionPolicyReleaseHoldInput {
  readonly holdId: unknown;
  readonly releasedBy: string;
  readonly reason: string;
}

export interface RetentionPolicyReleaseHoldOutputOk {
  readonly variant: 'ok';
}

export interface RetentionPolicyReleaseHoldOutputNotFound {
  readonly variant: 'notFound';
  readonly message: string;
}

export interface RetentionPolicyReleaseHoldOutputAlreadyReleased {
  readonly variant: 'alreadyReleased';
  readonly message: string;
}

export type RetentionPolicyReleaseHoldOutput = RetentionPolicyReleaseHoldOutputOk | RetentionPolicyReleaseHoldOutputNotFound | RetentionPolicyReleaseHoldOutputAlreadyReleased;

export interface RetentionPolicyCheckDispositionInput {
  readonly record: string;
}

export interface RetentionPolicyCheckDispositionOutputDisposable {
  readonly variant: 'disposable';
  readonly policyId: string;
}

export interface RetentionPolicyCheckDispositionOutputRetained {
  readonly variant: 'retained';
  readonly reason: string;
  readonly until: string;
}

export interface RetentionPolicyCheckDispositionOutputHeld {
  readonly variant: 'held';
  readonly holdNames: readonly string[];
}

export type RetentionPolicyCheckDispositionOutput = RetentionPolicyCheckDispositionOutputDisposable | RetentionPolicyCheckDispositionOutputRetained | RetentionPolicyCheckDispositionOutputHeld;

export interface RetentionPolicyDisposeInput {
  readonly record: string;
  readonly disposedBy: string;
}

export interface RetentionPolicyDisposeOutputOk {
  readonly variant: 'ok';
}

export interface RetentionPolicyDisposeOutputRetained {
  readonly variant: 'retained';
  readonly reason: string;
}

export interface RetentionPolicyDisposeOutputHeld {
  readonly variant: 'held';
  readonly holdNames: readonly string[];
}

export type RetentionPolicyDisposeOutput = RetentionPolicyDisposeOutputOk | RetentionPolicyDisposeOutputRetained | RetentionPolicyDisposeOutputHeld;

export interface RetentionPolicyAuditLogInput {
  readonly record: O.Option<string>;
}

export interface RetentionPolicyAuditLogOutput {
  readonly variant: 'ok';
  readonly entries: readonly { readonly record: string; readonly policy: string; readonly disposedAt: string; readonly disposedBy: string }[];
}

// --- Variant constructors ---

export const setRetentionOk = (policyId: string): RetentionPolicySetRetentionOutput => ({ variant: 'ok', policyId } as RetentionPolicySetRetentionOutput);
export const setRetentionAlreadyExists = (message: string): RetentionPolicySetRetentionOutput => ({ variant: 'alreadyExists', message } as RetentionPolicySetRetentionOutput);

export const applyHoldOk = (holdId: unknown): RetentionPolicyApplyHoldOutput => ({ variant: 'ok', holdId } as RetentionPolicyApplyHoldOutput);

export const releaseHoldOk = (): RetentionPolicyReleaseHoldOutput => ({ variant: 'ok' } as RetentionPolicyReleaseHoldOutput);
export const releaseHoldNotFound = (message: string): RetentionPolicyReleaseHoldOutput => ({ variant: 'notFound', message } as RetentionPolicyReleaseHoldOutput);
export const releaseHoldAlreadyReleased = (message: string): RetentionPolicyReleaseHoldOutput => ({ variant: 'alreadyReleased', message } as RetentionPolicyReleaseHoldOutput);

export const checkDispositionDisposable = (policyId: string): RetentionPolicyCheckDispositionOutput => ({ variant: 'disposable', policyId } as RetentionPolicyCheckDispositionOutput);
export const checkDispositionRetained = (reason: string, until: string): RetentionPolicyCheckDispositionOutput => ({ variant: 'retained', reason, until } as RetentionPolicyCheckDispositionOutput);
export const checkDispositionHeld = (holdNames: readonly string[]): RetentionPolicyCheckDispositionOutput => ({ variant: 'held', holdNames } as RetentionPolicyCheckDispositionOutput);

export const disposeOk = (): RetentionPolicyDisposeOutput => ({ variant: 'ok' } as RetentionPolicyDisposeOutput);
export const disposeRetained = (reason: string): RetentionPolicyDisposeOutput => ({ variant: 'retained', reason } as RetentionPolicyDisposeOutput);
export const disposeHeld = (holdNames: readonly string[]): RetentionPolicyDisposeOutput => ({ variant: 'held', holdNames } as RetentionPolicyDisposeOutput);

export const auditLogOk = (entries: readonly { readonly record: string; readonly policy: string; readonly disposedAt: string; readonly disposedBy: string }[]): RetentionPolicyAuditLogOutput => ({ variant: 'ok', entries } as RetentionPolicyAuditLogOutput);

