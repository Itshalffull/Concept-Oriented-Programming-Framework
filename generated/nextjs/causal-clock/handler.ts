// CausalClock â€” handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  CausalClockStorage,
  CausalClockTickInput,
  CausalClockTickOutput,
  CausalClockMergeInput,
  CausalClockMergeOutput,
  CausalClockCompareInput,
  CausalClockCompareOutput,
  CausalClockDominatesInput,
  CausalClockDominatesOutput,
} from './types.js';

import {
  tickOk,
  mergeOk,
  mergeIncompatible,
  compareBefore,
  compareAfter,
  compareConcurrent,
  dominatesOk,
} from './types.js';

export interface CausalClockError {
  readonly code: string;
  readonly message: string;
}

export interface CausalClockHandler {
  readonly tick: (
    input: CausalClockTickInput,
    storage: CausalClockStorage,
  ) => TE.TaskEither<CausalClockError, CausalClockTickOutput>;
  readonly merge: (
    input: CausalClockMergeInput,
    storage: CausalClockStorage,
  ) => TE.TaskEither<CausalClockError, CausalClockMergeOutput>;
  readonly compare: (
    input: CausalClockCompareInput,
    storage: CausalClockStorage,
  ) => TE.TaskEither<CausalClockError, CausalClockCompareOutput>;
  readonly dominates: (
    input: CausalClockDominatesInput,
    storage: CausalClockStorage,
  ) => TE.TaskEither<CausalClockError, CausalClockDominatesOutput>;
}

// --- Pure vector clock helpers ---

const storageError = (error: unknown): CausalClockError => ({
  code: 'STORAGE_ERROR',
  message: error instanceof Error ? error.message : String(error),
});

/** Parse a stored clock record into a readonly number[]. Defaults to empty. */
const parseClock = (record: Record<string, unknown> | null): readonly number[] =>
  pipe(
    O.fromNullable(record),
    O.chain((r) => O.fromNullable(r['clock'] as readonly number[] | undefined)),
    O.getOrElse((): readonly number[] => []),
  );

/** Component-wise maximum of two clocks, extending shorter with zeros. */
const componentMax = (
  a: readonly number[],
  b: readonly number[],
): readonly number[] => {
  const len = Math.max(a.length, b.length);
  const result: number[] = new Array(len);
  for (let i = 0; i < len; i++) {
    result[i] = Math.max(a[i] ?? 0, b[i] ?? 0);
  }
  return result;
};

/** Resolve the index for a given replicaId within the known replicas list. */
const resolveReplicaIndex = async (
  storage: CausalClockStorage,
  replicaId: string,
): Promise<number> => {
  const meta = await storage.get('clock_meta', replicaId);
  if (meta !== null && typeof meta['index'] === 'number') {
    return meta['index'] as number;
  }
  // Assign the next available index by counting existing replicas
  const allReplicas = await storage.find('clock_meta');
  const nextIndex = allReplicas.length;
  await storage.put('clock_meta', replicaId, { replicaId, index: nextIndex });
  return nextIndex;
};

/** Ensure the clock has at least `size` entries, padding with zeros. */
const padClock = (clock: readonly number[], size: number): readonly number[] => {
  if (clock.length >= size) return clock;
  const padded: number[] = [...clock];
  for (let i = clock.length; i < size; i++) {
    padded.push(0);
  }
  return padded;
};

/** Generate a unique timestamp ID based on replicaId and its counter. */
const makeTimestamp = (replicaId: string, counter: number): string =>
  `${replicaId}:${counter}`;

// --- Implementation ---

export const causalClockHandler: CausalClockHandler = {
  tick: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const replicaIndex = await resolveReplicaIndex(storage, input.replicaId);
          const clockRecord = await storage.get('clocks', input.replicaId);
          const currentClock = parseClock(clockRecord);
          // Ensure clock is long enough to include this replica's position
          const extended = padClock(currentClock, replicaIndex + 1);
          // Increment this replica's component
          const newClock: readonly number[] = extended.map((val, idx) =>
            idx === replicaIndex ? val + 1 : val,
          );
          const newCounter = newClock[replicaIndex] as number;
          const timestampId = makeTimestamp(input.replicaId, newCounter);
          // Persist the updated clock for this replica
          await storage.put('clocks', input.replicaId, {
            replicaId: input.replicaId,
            clock: newClock,
          });
          // Store the event -> clock mapping so compare can look it up
          await storage.put('events', timestampId, {
            timestampId,
            replicaId: input.replicaId,
            clock: [...newClock],
          });
          return tickOk(timestampId, newClock);
        },
        storageError,
      ),
    ),

  merge: (input, _storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const { localClock, remoteClock } = input;
          if (localClock.length !== remoteClock.length) {
            return mergeIncompatible(
              `Clock dimensions differ: local=${localClock.length}, remote=${remoteClock.length}`,
            );
          }
          return mergeOk(componentMax(localClock, remoteClock));
        },
        storageError,
      ),
    ),

  compare: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const eventA = await storage.get('events', input.a);
          const eventB = await storage.get('events', input.b);
          const clockA = parseClock(eventA);
          const clockB = parseClock(eventB);
          const len = Math.max(clockA.length, clockB.length);

          let aLessOrEqual = true;
          let bLessOrEqual = true;

          for (let i = 0; i < len; i++) {
            const va = clockA[i] ?? 0;
            const vb = clockB[i] ?? 0;
            if (va > vb) bLessOrEqual = false;
            if (vb > va) aLessOrEqual = false;
          }

          // a <= b component-wise and a != b => a happened before b
          if (aLessOrEqual && !bLessOrEqual) return compareBefore();
          // b <= a component-wise and b != a => b happened before a (a is after)
          if (bLessOrEqual && !aLessOrEqual) return compareAfter();
          // Neither dominates the other (including the case where they are equal
          // but that would mean same event, which is also "concurrent" by convention
          // since equal clocks from different events implies concurrent origin)
          return compareConcurrent();
        },
        storageError,
      ),
    ),

  dominates: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const eventA = await storage.get('events', input.a);
          const eventB = await storage.get('events', input.b);
          const clockA = parseClock(eventA);
          const clockB = parseClock(eventB);
          const len = Math.max(clockA.length, clockB.length);

          let allGreaterOrEqual = true;
          let strictlyGreater = false;

          for (let i = 0; i < len; i++) {
            const va = clockA[i] ?? 0;
            const vb = clockB[i] ?? 0;
            if (va < vb) {
              allGreaterOrEqual = false;
              break;
            }
            if (va > vb) {
              strictlyGreater = true;
            }
          }

          return dominatesOk(allGreaterOrEqual && strictlyGreater);
        },
        storageError,
      ),
    ),
};
