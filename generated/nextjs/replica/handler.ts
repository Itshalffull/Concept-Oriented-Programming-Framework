// Replica — handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  ReplicaStorage,
  ReplicaLocalUpdateInput,
  ReplicaLocalUpdateOutput,
  ReplicaReceiveRemoteInput,
  ReplicaReceiveRemoteOutput,
  ReplicaSyncInput,
  ReplicaSyncOutput,
  ReplicaGetStateInput,
  ReplicaGetStateOutput,
  ReplicaForkInput,
  ReplicaForkOutput,
  ReplicaAddPeerInput,
  ReplicaAddPeerOutput,
} from './types.js';

import {
  localUpdateOk,
  localUpdateInvalidOp,
  receiveRemoteOk,
  receiveRemoteConflict,
  receiveRemoteUnknownReplica,
  syncOk,
  syncUnreachable,
  getStateOk,
  forkOk,
  addPeerOk,
  addPeerAlreadyKnown,
} from './types.js';

export interface ReplicaError {
  readonly code: string;
  readonly message: string;
}

export interface ReplicaHandler {
  readonly localUpdate: (
    input: ReplicaLocalUpdateInput,
    storage: ReplicaStorage,
  ) => TE.TaskEither<ReplicaError, ReplicaLocalUpdateOutput>;
  readonly receiveRemote: (
    input: ReplicaReceiveRemoteInput,
    storage: ReplicaStorage,
  ) => TE.TaskEither<ReplicaError, ReplicaReceiveRemoteOutput>;
  readonly sync: (
    input: ReplicaSyncInput,
    storage: ReplicaStorage,
  ) => TE.TaskEither<ReplicaError, ReplicaSyncOutput>;
  readonly getState: (
    input: ReplicaGetStateInput,
    storage: ReplicaStorage,
  ) => TE.TaskEither<ReplicaError, ReplicaGetStateOutput>;
  readonly fork: (
    input: ReplicaForkInput,
    storage: ReplicaStorage,
  ) => TE.TaskEither<ReplicaError, ReplicaForkOutput>;
  readonly addPeer: (
    input: ReplicaAddPeerInput,
    storage: ReplicaStorage,
  ) => TE.TaskEither<ReplicaError, ReplicaAddPeerOutput>;
}

// --- Helpers ---

const storageError = (error: unknown): ReplicaError => ({
  code: 'STORAGE_ERROR',
  message: error instanceof Error ? error.message : String(error),
});

const generateReplicaId = (): string =>
  `replica_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;

/** Parse the local state buffer from a stored record. */
const parseLocalState = (record: Record<string, unknown> | null): Buffer =>
  pipe(
    O.fromNullable(record),
    O.chain((r) => O.fromNullable(r['localState'] as Buffer | undefined)),
    O.getOrElse(() => Buffer.alloc(0)),
  );

/** Parse the vector clock array from a stored record. */
const parseClock = (record: Record<string, unknown> | null): readonly number[] =>
  pipe(
    O.fromNullable(record),
    O.chain((r) => O.fromNullable(r['clock'] as readonly number[] | undefined)),
    O.getOrElse((): readonly number[] => []),
  );

/** Component-wise maximum of two clock vectors. */
const mergeClock = (a: readonly number[], b: readonly number[]): readonly number[] => {
  const len = Math.max(a.length, b.length);
  const result: number[] = new Array(len);
  for (let i = 0; i < len; i++) {
    result[i] = Math.max(a[i] ?? 0, b[i] ?? 0);
  }
  return result;
};

/** Retrieve (or create) the replica metadata record. */
const getOrCreateReplica = async (
  storage: ReplicaStorage,
): Promise<Record<string, unknown>> => {
  const existing = await storage.get('replica_state', '__self__');
  if (existing !== null) return existing;
  const initial: Record<string, unknown> = {
    replicaId: generateReplicaId(),
    localState: Buffer.alloc(0).toJSON(),
    clock: [],
    pendingOps: [],
  };
  await storage.put('replica_state', '__self__', initial);
  return initial;
};

/** Apply an operation buffer to local state by concatenation (append-log model). */
const applyOp = (currentState: Buffer, op: Buffer): Buffer =>
  Buffer.concat([currentState, op]);

// --- Implementation ---

export const replicaHandler: ReplicaHandler = {
  localUpdate: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          if (input.op.length === 0) {
            return localUpdateInvalidOp('Operation buffer is empty');
          }
          const replica = await getOrCreateReplica(storage);
          const currentState = parseLocalState(replica);
          const clock = parseClock(replica);
          const pendingOps = (replica['pendingOps'] as readonly string[]) ?? [];

          // Apply the operation to produce new local state
          const newState = applyOp(currentState, input.op);

          // Tick the local clock component (index 0 is always self)
          const newClock: readonly number[] = clock.length > 0
            ? clock.map((v, i) => (i === 0 ? v + 1 : v))
            : [1];

          // Add to pending ops queue for future sync
          const newPending = [...pendingOps, input.op.toString('base64')];

          await storage.put('replica_state', '__self__', {
            ...replica,
            localState: newState.toJSON(),
            clock: newClock,
            pendingOps: newPending,
          });

          return localUpdateOk(newState);
        },
        storageError,
      ),
    ),

  receiveRemote: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          // Verify the sender is a known peer
          const peer = await storage.get('peers', input.fromReplica);
          if (peer === null) {
            return receiveRemoteUnknownReplica(
              `Replica "${input.fromReplica}" is not in the known peers set`,
            );
          }

          const replica = await getOrCreateReplica(storage);
          const currentState = parseLocalState(replica);
          const localClock = parseClock(replica);

          // Retrieve the remote replica's clock for conflict detection
          const remoteSyncState = await storage.get('sync_state', input.fromReplica);
          const remoteClock = parseClock(remoteSyncState);

          // Check for concurrent modifications (neither clock dominates)
          const len = Math.max(localClock.length, remoteClock.length);
          let localDominates = false;
          let remoteDominates = false;
          for (let i = 0; i < len; i++) {
            const lv = localClock[i] ?? 0;
            const rv = remoteClock[i] ?? 0;
            if (lv > rv) localDominates = true;
            if (rv > lv) remoteDominates = true;
          }

          if (localDominates && remoteDominates) {
            // Truly concurrent — report conflict
            const details = Buffer.from(
              JSON.stringify({
                localClock,
                remoteClock,
                fromReplica: input.fromReplica,
              }),
            );
            return receiveRemoteConflict(details);
          }

          // Integrate the remote operation
          const newState = applyOp(currentState, input.op);
          const mergedClock = mergeClock(localClock, remoteClock);

          await storage.put('replica_state', '__self__', {
            ...replica,
            localState: newState.toJSON(),
            clock: mergedClock,
          });

          // Update sync state for this peer
          await storage.put('sync_state', input.fromReplica, {
            peerId: input.fromReplica,
            clock: mergedClock,
          });

          return receiveRemoteOk(newState);
        },
        storageError,
      ),
    ),

  sync: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          // Check that the peer is known
          const peer = await storage.get('peers', input.peer);
          if (peer === null) {
            return syncUnreachable(
              `Peer "${input.peer}" is not known or reachable`,
            );
          }

          const replica = await getOrCreateReplica(storage);
          const localClock = parseClock(replica);
          const pendingOps = (replica['pendingOps'] as readonly string[]) ?? [];

          // Store outgoing ops as the sync payload for the peer
          await storage.put('sync_outbox', input.peer, {
            peerId: input.peer,
            ops: pendingOps,
            clock: localClock,
          });

          // Read any queued incoming ops from this peer
          const inbox = await storage.get('sync_inbox', input.peer);
          if (inbox !== null) {
            const incomingOps = (inbox['ops'] as readonly string[]) ?? [];
            const remoteClock = parseClock(inbox);
            let currentState = parseLocalState(replica);

            // Apply each incoming op
            for (const opBase64 of incomingOps) {
              const opBuf = Buffer.from(opBase64, 'base64');
              currentState = applyOp(currentState, opBuf);
            }

            const mergedClock = mergeClock(localClock, remoteClock);

            await storage.put('replica_state', '__self__', {
              ...replica,
              localState: currentState.toJSON(),
              clock: mergedClock,
              pendingOps: [], // Clear pending after successful sync
            });

            // Clear the inbox
            await storage.delete('sync_inbox', input.peer);
          } else {
            // Even without incoming, clear pending ops since we sent ours
            await storage.put('replica_state', '__self__', {
              ...replica,
              pendingOps: [],
            });
          }

          return syncOk();
        },
        storageError,
      ),
    ),

  getState: (_input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const replica = await getOrCreateReplica(storage);
          const state = parseLocalState(replica);
          const clock = parseClock(replica);
          const clockBuffer = Buffer.from(JSON.stringify(clock));
          return getStateOk(state, clockBuffer);
        },
        storageError,
      ),
    ),

  fork: (_input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const replica = await getOrCreateReplica(storage);
          const newId = generateReplicaId();

          // Create a new replica record with the same state snapshot
          await storage.put('replica_state', newId, {
            replicaId: newId,
            localState: replica['localState'],
            clock: replica['clock'],
            pendingOps: [],
          });

          // Register the new fork as a known peer of the parent
          await storage.put('peers', newId, {
            peerId: newId,
            addedAt: new Date().toISOString(),
          });

          return forkOk(newId);
        },
        storageError,
      ),
    ),

  addPeer: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const existing = await storage.get('peers', input.peerId);
          return pipe(
            O.fromNullable(existing),
            O.fold(
              async () => {
                await storage.put('peers', input.peerId, {
                  peerId: input.peerId,
                  addedAt: new Date().toISOString(),
                });
                return addPeerOk();
              },
              async () =>
                addPeerAlreadyKnown(
                  `Peer "${input.peerId}" is already in the known peers set`,
                ),
            ),
          );
        },
        storageError,
      ),
      TE.flatten,
    ),
};
