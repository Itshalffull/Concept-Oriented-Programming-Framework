// MultiValueResolution — handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  MultiValueResolutionStorage,
  MultiValueResolutionRegisterInput,
  MultiValueResolutionRegisterOutput,
  MultiValueResolutionAttemptResolveInput,
  MultiValueResolutionAttemptResolveOutput,
} from './types.js';

import {
  registerOk,
  attemptResolveResolved,
  attemptResolveCannotResolve,
} from './types.js';

export interface MultiValueResolutionError {
  readonly code: string;
  readonly message: string;
}

export interface MultiValueResolutionHandler {
  readonly register: (
    input: MultiValueResolutionRegisterInput,
    storage: MultiValueResolutionStorage,
  ) => TE.TaskEither<MultiValueResolutionError, MultiValueResolutionRegisterOutput>;
  readonly attemptResolve: (
    input: MultiValueResolutionAttemptResolveInput,
    storage: MultiValueResolutionStorage,
  ) => TE.TaskEither<MultiValueResolutionError, MultiValueResolutionAttemptResolveOutput>;
}

// --- Helpers ---

const storageError = (error: unknown): MultiValueResolutionError => ({
  code: 'STORAGE_ERROR',
  message: error instanceof Error ? error.message : String(error),
});

/**
 * Multi-value sibling representation:
 * A JSON-encoded array of base64-encoded values, sorted for commutativity.
 * This ensures resolve(v1, v2) === resolve(v2, v1) per the spec invariant.
 */
const encodeSiblings = (values: readonly Buffer[]): Buffer => {
  const encoded = values
    .map((v) => v.toString('base64'))
    .sort() // Sort for commutative guarantee
    .filter((v, i, arr) => arr.indexOf(v) === i); // Deduplicate
  return Buffer.from(JSON.stringify(encoded));
};

/**
 * If a buffer is already a multi-value sibling collection (JSON array of
 * base64 strings), expand it into its constituent values. Otherwise,
 * treat the whole buffer as a single value.
 */
const expandSiblings = (buf: Buffer): readonly string[] => {
  try {
    const parsed = JSON.parse(buf.toString('utf-8'));
    if (Array.isArray(parsed) && parsed.every((x: unknown) => typeof x === 'string')) {
      return parsed as readonly string[];
    }
    return [buf.toString('base64')];
  } catch {
    return [buf.toString('base64')];
  }
};

// --- Implementation ---

export const multiValueResolutionHandler: MultiValueResolutionHandler = {
  register: (_input, _storage) =>
    pipe(
      TE.right(registerOk('multi-value', 'conflict-resolution', 30)),
    ),

  attemptResolve: (input, _storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          // Expand both versions — if either is already a sibling collection,
          // flatten it so we accumulate correctly across multiple resolutions.
          const siblings1 = expandSiblings(input.v1);
          const siblings2 = expandSiblings(input.v2);

          // Merge all siblings, deduplicate, sort for commutativity
          const allSiblings = [...new Set([...siblings1, ...siblings2])].sort();

          if (allSiblings.length === 0) {
            return attemptResolveCannotResolve(
              'Content type does not support multi-value representation',
            );
          }

          // Encode the combined sibling set
          const siblingBuffers = allSiblings.map((s) => Buffer.from(s, 'base64'));
          return attemptResolveResolved(encodeSiblings(siblingBuffers));
        },
        storageError,
      ),
    ),
};
