// ContractTest â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as O from 'fp-ts/Option';

// Storage interface for ContractTest
export interface ContractTestStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface ContractTestGenerateInput {
  readonly concept: string;
  readonly specPath: string;
}

export interface ContractTestGenerateOutputOk {
  readonly variant: 'ok';
  readonly contract: string;
  readonly definition: { readonly actions: readonly { readonly actionName: string; readonly inputSchema: string; readonly outputVariants: readonly string[] }[] };
}

export interface ContractTestGenerateOutputSpecError {
  readonly variant: 'specError';
  readonly concept: string;
  readonly message: string;
}

export type ContractTestGenerateOutput = ContractTestGenerateOutputOk | ContractTestGenerateOutputSpecError;

export interface ContractTestVerifyInput {
  readonly contract: string;
  readonly producerArtifact: string;
  readonly producerLanguage: string;
  readonly consumerArtifact: string;
  readonly consumerLanguage: string;
}

export interface ContractTestVerifyOutputOk {
  readonly variant: 'ok';
  readonly contract: string;
  readonly passed: number;
  readonly total: number;
}

export interface ContractTestVerifyOutputIncompatible {
  readonly variant: 'incompatible';
  readonly contract: string;
  readonly failures: readonly { readonly action: string; readonly issue: string; readonly producerBehavior: string; readonly consumerExpectation: string }[];
}

export interface ContractTestVerifyOutputProducerUnavailable {
  readonly variant: 'producerUnavailable';
  readonly language: string;
  readonly reason: string;
}

export interface ContractTestVerifyOutputConsumerUnavailable {
  readonly variant: 'consumerUnavailable';
  readonly language: string;
  readonly reason: string;
}

export type ContractTestVerifyOutput = ContractTestVerifyOutputOk | ContractTestVerifyOutputIncompatible | ContractTestVerifyOutputProducerUnavailable | ContractTestVerifyOutputConsumerUnavailable;

export interface ContractTestMatrixInput {
  readonly concepts: O.Option<readonly string[]>;
}

export interface ContractTestMatrixOutput {
  readonly variant: 'ok';
  readonly matrix: readonly { readonly concept: string; readonly pairs: readonly { readonly producer: string; readonly consumer: string; readonly status: string; readonly lastVerified: O.Option<Date> }[] }[];
}

export interface ContractTestCanDeployInput {
  readonly concept: string;
  readonly language: string;
}

export interface ContractTestCanDeployOutputOk {
  readonly variant: 'ok';
  readonly safe: boolean;
  readonly verifiedAgainst: readonly string[];
}

export interface ContractTestCanDeployOutputUnverified {
  readonly variant: 'unverified';
  readonly missingPairs: readonly { readonly counterpart: string; readonly lastVerified: O.Option<Date> }[];
}

export type ContractTestCanDeployOutput = ContractTestCanDeployOutputOk | ContractTestCanDeployOutputUnverified;

// --- Variant constructors ---

export const generateOk = (contract: string, definition: { readonly actions: readonly { readonly actionName: string; readonly inputSchema: string; readonly outputVariants: readonly string[] }[] }): ContractTestGenerateOutput => ({ variant: 'ok', contract, definition } as ContractTestGenerateOutput);
export const generateSpecError = (concept: string, message: string): ContractTestGenerateOutput => ({ variant: 'specError', concept, message } as ContractTestGenerateOutput);

export const verifyOk = (contract: string, passed: number, total: number): ContractTestVerifyOutput => ({ variant: 'ok', contract, passed, total } as ContractTestVerifyOutput);
export const verifyIncompatible = (contract: string, failures: readonly { readonly action: string; readonly issue: string; readonly producerBehavior: string; readonly consumerExpectation: string }[]): ContractTestVerifyOutput => ({ variant: 'incompatible', contract, failures } as ContractTestVerifyOutput);
export const verifyProducerUnavailable = (language: string, reason: string): ContractTestVerifyOutput => ({ variant: 'producerUnavailable', language, reason } as ContractTestVerifyOutput);
export const verifyConsumerUnavailable = (language: string, reason: string): ContractTestVerifyOutput => ({ variant: 'consumerUnavailable', language, reason } as ContractTestVerifyOutput);

export const matrixOk = (matrix: readonly { readonly concept: string; readonly pairs: readonly { readonly producer: string; readonly consumer: string; readonly status: string; readonly lastVerified: O.Option<Date> }[] }[]): ContractTestMatrixOutput => ({ variant: 'ok', matrix } as ContractTestMatrixOutput);

export const canDeployOk = (safe: boolean, verifiedAgainst: readonly string[]): ContractTestCanDeployOutput => ({ variant: 'ok', safe, verifiedAgainst } as ContractTestCanDeployOutput);
export const canDeployUnverified = (missingPairs: readonly { readonly counterpart: string; readonly lastVerified: O.Option<Date> }[]): ContractTestCanDeployOutput => ({ variant: 'unverified', missingPairs } as ContractTestCanDeployOutput);

