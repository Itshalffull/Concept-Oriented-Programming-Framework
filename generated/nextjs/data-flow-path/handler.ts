// DataFlowPath â€” handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  DataFlowPathStorage,
  DataFlowPathTraceInput,
  DataFlowPathTraceOutput,
  DataFlowPathTraceFromConfigInput,
  DataFlowPathTraceFromConfigOutput,
  DataFlowPathTraceToOutputInput,
  DataFlowPathTraceToOutputOutput,
  DataFlowPathGetInput,
  DataFlowPathGetOutput,
} from './types.js';

import {
  traceOk,
  traceNoPath,
  traceFromConfigOk,
  traceToOutputOk,
  getOk,
  getNotfound,
} from './types.js';

export interface DataFlowPathError {
  readonly code: string;
  readonly message: string;
}

export interface DataFlowPathHandler {
  readonly trace: (
    input: DataFlowPathTraceInput,
    storage: DataFlowPathStorage,
  ) => TE.TaskEither<DataFlowPathError, DataFlowPathTraceOutput>;
  readonly traceFromConfig: (
    input: DataFlowPathTraceFromConfigInput,
    storage: DataFlowPathStorage,
  ) => TE.TaskEither<DataFlowPathError, DataFlowPathTraceFromConfigOutput>;
  readonly traceToOutput: (
    input: DataFlowPathTraceToOutputInput,
    storage: DataFlowPathStorage,
  ) => TE.TaskEither<DataFlowPathError, DataFlowPathTraceToOutputOutput>;
  readonly get: (
    input: DataFlowPathGetInput,
    storage: DataFlowPathStorage,
  ) => TE.TaskEither<DataFlowPathError, DataFlowPathGetOutput>;
}

// --- Internal types ---

interface FlowEdge {
  readonly from: string;
  readonly to: string;
  readonly kind: string;
}

interface FlowPath {
  readonly id: string;
  readonly sourceSymbol: string;
  readonly sinkSymbol: string;
  readonly steps: readonly string[];
  readonly pathKind: string;
}

const makeStorageError = (error: unknown): DataFlowPathError => ({
  code: 'STORAGE_ERROR',
  message: error instanceof Error ? error.message : String(error),
});

const generateId = (): string =>
  `dfpath-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;

const loadFlowEdges = (
  storage: DataFlowPathStorage,
): TE.TaskEither<DataFlowPathError, readonly FlowEdge[]> =>
  TE.tryCatch(
    async () => {
      const records = await storage.find('flow_edges');
      return records.map((r) => ({
        from: String(r['from'] ?? ''),
        to: String(r['to'] ?? ''),
        kind: String(r['kind'] ?? 'data-flow'),
      }));
    },
    makeStorageError,
  );

// Build forward adjacency for data flow
const buildFlowAdj = (
  edges: readonly FlowEdge[],
): ReadonlyMap<string, readonly { readonly to: string; readonly kind: string }[]> => {
  const adj = new Map<string, Array<{ readonly to: string; readonly kind: string }>>();
  for (const edge of edges) {
    const existing = adj.get(edge.from) ?? [];
    adj.set(edge.from, [...existing, { to: edge.to, kind: edge.kind }]);
  }
  return adj;
};

// Build reverse adjacency for tracing backwards
const buildReverseFlowAdj = (
  edges: readonly FlowEdge[],
): ReadonlyMap<string, readonly { readonly from: string; readonly kind: string }[]> => {
  const adj = new Map<string, Array<{ readonly from: string; readonly kind: string }>>();
  for (const edge of edges) {
    const existing = adj.get(edge.to) ?? [];
    adj.set(edge.to, [...existing, { from: edge.from, kind: edge.kind }]);
  }
  return adj;
};

// DFS to find all paths from source to sink (with cycle detection and depth limit)
const findAllPaths = (
  source: string,
  sink: string,
  adj: ReadonlyMap<string, readonly { readonly to: string; readonly kind: string }[]>,
  maxDepth: number = 50,
): readonly (readonly string[])[] => {
  const results: Array<readonly string[]> = [];

  const dfs = (current: string, path: readonly string[], visited: ReadonlySet<string>): void => {
    if (path.length > maxDepth) return;

    if (current === sink && path.length > 1) {
      results.push(path);
      return;
    }

    for (const neighbor of adj.get(current) ?? []) {
      if (!visited.has(neighbor.to)) {
        const newVisited = new Set(visited);
        newVisited.add(neighbor.to);
        dfs(neighbor.to, [...path, neighbor.to], newVisited);
      }
    }
  };

  const initialVisited = new Set<string>([source]);
  dfs(source, [source], initialVisited);

  return results;
};

// Classify path kind based on source/sink naming
const classifyPathKind = (source: string, sink: string): string => {
  if (source.startsWith('config/') || source.startsWith('env/')) return 'config-propagation';
  if (sink.includes('output') || sink.includes('gen')) return 'generation-flow';
  if (source.includes('input') || source.includes('request')) return 'request-flow';
  return 'data-flow';
};

// Store a traced path and return its metadata
const storePath = (
  storage: DataFlowPathStorage,
  source: string,
  sink: string,
  steps: readonly string[],
): TE.TaskEither<DataFlowPathError, FlowPath> =>
  TE.tryCatch(
    async () => {
      const pathId = generateId();
      const pathKind = classifyPathKind(source, sink);
      const flowPath: FlowPath = {
        id: pathId,
        sourceSymbol: source,
        sinkSymbol: sink,
        steps,
        pathKind,
      };

      await storage.put('flow_paths', pathId, {
        id: pathId,
        sourceSymbol: source,
        sinkSymbol: sink,
        steps: JSON.stringify(steps),
        pathKind,
      });

      return flowPath;
    },
    makeStorageError,
  );

// --- Implementation ---

export const dataFlowPathHandler: DataFlowPathHandler = {
  trace: (input, storage) =>
    pipe(
      loadFlowEdges(storage),
      TE.chain((edges) => {
        const adj = buildFlowAdj(edges);
        const allPaths = findAllPaths(input.source, input.sink, adj);

        if (allPaths.length === 0) {
          return TE.right<DataFlowPathError, DataFlowPathTraceOutput>(traceNoPath());
        }

        // Store each found path and collect their IDs
        const storeOps = allPaths.map((steps) =>
          storePath(storage, input.source, input.sink, steps),
        );

        return pipe(
          TE.tryCatch(
            async () => {
              const storedPaths: FlowPath[] = [];
              for (const op of storeOps) {
                const result = await op();
                if (E.isRight(result)) {
                  storedPaths.push(result.right);
                }
              }

              const serialized = storedPaths.map((p) => ({
                id: p.id,
                steps: p.steps,
                pathKind: p.pathKind,
              }));

              return traceOk(JSON.stringify(serialized));
            },
            makeStorageError,
          ),
        );
      }),
    ),

  traceFromConfig: (input, storage) =>
    pipe(
      loadFlowEdges(storage),
      TE.chain((edges) => {
        const adj = buildFlowAdj(edges);

        // BFS from the config key to find all reachable sinks
        const visited = new Set<string>();
        const queue: Array<{ readonly node: string; readonly path: readonly string[] }> = [
          { node: input.configKey, path: [input.configKey] },
        ];
        const allPaths: Array<{ readonly sink: string; readonly steps: readonly string[] }> = [];

        while (queue.length > 0) {
          const { node, path } = queue.shift()!;
          if (visited.has(node) && node !== input.configKey) continue;
          visited.add(node);

          const neighbors = adj.get(node) ?? [];
          if (neighbors.length === 0 && node !== input.configKey) {
            // Leaf node = sink
            allPaths.push({ sink: node, steps: path });
          }

          for (const neighbor of neighbors) {
            if (!visited.has(neighbor.to)) {
              queue.push({ node: neighbor.to, path: [...path, neighbor.to] });
            }
          }
        }

        return pipe(
          TE.tryCatch(
            async () => {
              const results: Array<{ readonly id: string; readonly sink: string; readonly steps: readonly string[]; readonly pathKind: string }> = [];
              for (const p of allPaths) {
                const pathId = generateId();
                await storage.put('flow_paths', pathId, {
                  id: pathId,
                  sourceSymbol: input.configKey,
                  sinkSymbol: p.sink,
                  steps: JSON.stringify(p.steps),
                  pathKind: 'config-propagation',
                });
                results.push({ id: pathId, sink: p.sink, steps: p.steps, pathKind: 'config-propagation' });
              }
              return traceFromConfigOk(JSON.stringify(results));
            },
            makeStorageError,
          ),
        );
      }),
    ),

  traceToOutput: (input, storage) =>
    pipe(
      loadFlowEdges(storage),
      TE.chain((edges) => {
        const reverseAdj = buildReverseFlowAdj(edges);

        // BFS backwards from output to find all contributing sources
        const visited = new Set<string>();
        const queue: Array<{ readonly node: string; readonly path: readonly string[] }> = [
          { node: input.output, path: [input.output] },
        ];
        const allPaths: Array<{ readonly source: string; readonly steps: readonly string[] }> = [];

        while (queue.length > 0) {
          const { node, path } = queue.shift()!;
          if (visited.has(node) && node !== input.output) continue;
          visited.add(node);

          const predecessors = reverseAdj.get(node) ?? [];
          if (predecessors.length === 0 && node !== input.output) {
            // Root source node
            allPaths.push({ source: node, steps: [...path].reverse() });
          }

          for (const pred of predecessors) {
            if (!visited.has(pred.from)) {
              queue.push({ node: pred.from, path: [...path, pred.from] });
            }
          }
        }

        return pipe(
          TE.tryCatch(
            async () => {
              const results: Array<{ readonly id: string; readonly source: string; readonly steps: readonly string[]; readonly pathKind: string }> = [];
              for (const p of allPaths) {
                const pathId = generateId();
                await storage.put('flow_paths', pathId, {
                  id: pathId,
                  sourceSymbol: p.source,
                  sinkSymbol: input.output,
                  steps: JSON.stringify(p.steps),
                  pathKind: 'generation-flow',
                });
                results.push({ id: pathId, source: p.source, steps: p.steps, pathKind: 'generation-flow' });
              }
              return traceToOutputOk(JSON.stringify(results));
            },
            makeStorageError,
          ),
        );
      }),
    ),

  get: (input, storage) =>
    pipe(
      TE.tryCatch(
        () => storage.get('flow_paths', input.path),
        makeStorageError,
      ),
      TE.map((record) =>
        pipe(
          O.fromNullable(record),
          O.fold(
            () => getNotfound() as DataFlowPathGetOutput,
            (found) => {
              const steps: readonly unknown[] = JSON.parse(String(found['steps'] ?? '[]'));
              return getOk(
                input.path,
                String(found['sourceSymbol'] ?? ''),
                String(found['sinkSymbol'] ?? ''),
                String(found['pathKind'] ?? 'data-flow'),
                steps.length,
              );
            },
          ),
        ),
      ),
    ),
};
