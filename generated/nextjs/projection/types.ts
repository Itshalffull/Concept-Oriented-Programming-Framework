// Projection â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

// Storage interface for Projection
export interface ProjectionStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface ProjectionProjectInput {
  readonly manifest: string;
  readonly annotations: string;
}

export interface ProjectionProjectOutputOk {
  readonly variant: 'ok';
  readonly projection: string;
  readonly shapes: number;
  readonly actions: number;
  readonly traits: number;
}

export interface ProjectionProjectOutputAnnotationError {
  readonly variant: 'annotationError';
  readonly concept: string;
  readonly errors: readonly string[];
}

export interface ProjectionProjectOutputUnresolvedReference {
  readonly variant: 'unresolvedReference';
  readonly concept: string;
  readonly missing: readonly string[];
}

export interface ProjectionProjectOutputTraitConflict {
  readonly variant: 'traitConflict';
  readonly concept: string;
  readonly trait1: string;
  readonly trait2: string;
  readonly reason: string;
}

export type ProjectionProjectOutput = ProjectionProjectOutputOk | ProjectionProjectOutputAnnotationError | ProjectionProjectOutputUnresolvedReference | ProjectionProjectOutputTraitConflict;

export interface ProjectionValidateInput {
  readonly projection: string;
}

export interface ProjectionValidateOutputOk {
  readonly variant: 'ok';
  readonly projection: string;
  readonly warnings: readonly string[];
}

export interface ProjectionValidateOutputBreakingChange {
  readonly variant: 'breakingChange';
  readonly projection: string;
  readonly changes: readonly string[];
}

export interface ProjectionValidateOutputIncompleteAnnotation {
  readonly variant: 'incompleteAnnotation';
  readonly projection: string;
  readonly missing: readonly string[];
}

export type ProjectionValidateOutput = ProjectionValidateOutputOk | ProjectionValidateOutputBreakingChange | ProjectionValidateOutputIncompleteAnnotation;

export interface ProjectionDiffInput {
  readonly projection: string;
  readonly previous: string;
}

export interface ProjectionDiffOutputOk {
  readonly variant: 'ok';
  readonly added: readonly string[];
  readonly removed: readonly string[];
  readonly changed: readonly string[];
}

export interface ProjectionDiffOutputIncompatible {
  readonly variant: 'incompatible';
  readonly reason: string;
}

export type ProjectionDiffOutput = ProjectionDiffOutputOk | ProjectionDiffOutputIncompatible;

export interface ProjectionInferResourcesInput {
  readonly projection: string;
}

export interface ProjectionInferResourcesOutput {
  readonly variant: 'ok';
  readonly projection: string;
  readonly resources: readonly string[];
}

// --- Variant constructors ---

export const projectOk = (projection: string, shapes: number, actions: number, traits: number): ProjectionProjectOutput => ({ variant: 'ok', projection, shapes, actions, traits } as ProjectionProjectOutput);
export const projectAnnotationError = (concept: string, errors: readonly string[]): ProjectionProjectOutput => ({ variant: 'annotationError', concept, errors } as ProjectionProjectOutput);
export const projectUnresolvedReference = (concept: string, missing: readonly string[]): ProjectionProjectOutput => ({ variant: 'unresolvedReference', concept, missing } as ProjectionProjectOutput);
export const projectTraitConflict = (concept: string, trait1: string, trait2: string, reason: string): ProjectionProjectOutput => ({ variant: 'traitConflict', concept, trait1, trait2, reason } as ProjectionProjectOutput);

export const validateOk = (projection: string, warnings: readonly string[]): ProjectionValidateOutput => ({ variant: 'ok', projection, warnings } as ProjectionValidateOutput);
export const validateBreakingChange = (projection: string, changes: readonly string[]): ProjectionValidateOutput => ({ variant: 'breakingChange', projection, changes } as ProjectionValidateOutput);
export const validateIncompleteAnnotation = (projection: string, missing: readonly string[]): ProjectionValidateOutput => ({ variant: 'incompleteAnnotation', projection, missing } as ProjectionValidateOutput);

export const diffOk = (added: readonly string[], removed: readonly string[], changed: readonly string[]): ProjectionDiffOutput => ({ variant: 'ok', added, removed, changed } as ProjectionDiffOutput);
export const diffIncompatible = (reason: string): ProjectionDiffOutput => ({ variant: 'incompatible', reason } as ProjectionDiffOutput);

export const inferResourcesOk = (projection: string, resources: readonly string[]): ProjectionInferResourcesOutput => ({ variant: 'ok', projection, resources } as ProjectionInferResourcesOutput);

