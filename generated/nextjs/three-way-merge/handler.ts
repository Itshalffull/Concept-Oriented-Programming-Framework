// ThreeWayMerge â€” handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.
//
// Implements classic three-way merge as used in Git, POSIX merge, and
// most version control systems. Diffs base->ours and base->theirs,
// then combines non-conflicting hunks. Overlapping changes to the
// same region produce conflict markers.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  ThreeWayMergeStorage,
  ThreeWayMergeRegisterInput,
  ThreeWayMergeRegisterOutput,
  ThreeWayMergeExecuteInput,
  ThreeWayMergeExecuteOutput,
} from './types.js';

import {
  registerOk,
  executeClean,
  executeConflicts,
  executeUnsupportedContent,
} from './types.js';

export interface ThreeWayMergeError {
  readonly code: string;
  readonly message: string;
}

export interface ThreeWayMergeHandler {
  readonly register: (
    input: ThreeWayMergeRegisterInput,
    storage: ThreeWayMergeStorage,
  ) => TE.TaskEither<ThreeWayMergeError, ThreeWayMergeRegisterOutput>;
  readonly execute: (
    input: ThreeWayMergeExecuteInput,
    storage: ThreeWayMergeStorage,
  ) => TE.TaskEither<ThreeWayMergeError, ThreeWayMergeExecuteOutput>;
}

// --- Internal types ---

interface DiffHunk {
  readonly baseStart: number;
  readonly baseEnd: number;
  readonly lines: readonly string[];
}

type MergeRegion =
  | { readonly type: 'clean'; readonly lines: readonly string[] }
  | { readonly type: 'conflict'; readonly ours: readonly string[]; readonly theirs: readonly string[] };

// --- Pure helper functions ---

const splitLines = (buf: Buffer): readonly string[] =>
  buf.toString('utf-8').split('\n');

const joinLines = (lines: readonly string[]): Buffer =>
  Buffer.from(lines.join('\n'), 'utf-8');

/**
 * Compute LCS table between two line arrays.
 */
const lcsTable = (
  a: readonly string[],
  b: readonly string[],
): readonly (readonly number[])[] => {
  const n = a.length;
  const m = b.length;
  const dp: number[][] = Array.from({ length: n + 1 }, () =>
    new Array<number>(m + 1).fill(0),
  );
  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= m; j++) {
      dp[i][j] = a[i - 1] === b[j - 1]
        ? dp[i - 1][j - 1] + 1
        : Math.max(dp[i - 1][j], dp[i][j - 1]);
    }
  }
  return dp;
};

/**
 * Extract diff hunks between base and modified sequences.
 * Each hunk describes a contiguous region in base that was changed,
 * along with the replacement lines from the modified version.
 */
const extractHunks = (
  base: readonly string[],
  modified: readonly string[],
): readonly DiffHunk[] => {
  const dp = lcsTable(base, modified);
  const n = base.length;
  const m = modified.length;

  // Backtrack to find matching positions
  const matches: { readonly baseIdx: number; readonly modIdx: number }[] = [];
  let i = n;
  let j = m;
  while (i > 0 && j > 0) {
    if (base[i - 1] === modified[j - 1]) {
      matches.push({ baseIdx: i - 1, modIdx: j - 1 });
      i--;
      j--;
    } else if (dp[i - 1][j] >= dp[i][j - 1]) {
      i--;
    } else {
      j--;
    }
  }
  matches.reverse();

  // Convert matches into hunks (regions between matches)
  const hunks: DiffHunk[] = [];
  let basePos = 0;
  let modPos = 0;

  for (const match of matches) {
    if (basePos < match.baseIdx || modPos < match.modIdx) {
      // There is a changed region before this match
      hunks.push({
        baseStart: basePos,
        baseEnd: match.baseIdx,
        lines: modified.slice(modPos, match.modIdx),
      });
    }
    // Skip past the matching line
    basePos = match.baseIdx + 1;
    modPos = match.modIdx + 1;
  }

  // Trailing hunk after last match
  if (basePos < n || modPos < m) {
    hunks.push({
      baseStart: basePos,
      baseEnd: n,
      lines: modified.slice(modPos, m),
    });
  }

  return hunks;
};

/**
 * Check if two hunk ranges overlap.
 */
const hunksOverlap = (a: DiffHunk, b: DiffHunk): boolean =>
  a.baseStart < b.baseEnd && b.baseStart < a.baseEnd;

/**
 * Check if two hunks represent identical changes.
 */
const hunksIdentical = (a: DiffHunk, b: DiffHunk): boolean =>
  a.baseStart === b.baseStart &&
  a.baseEnd === b.baseEnd &&
  a.lines.length === b.lines.length &&
  a.lines.every((line, idx) => line === b.lines[idx]);

/**
 * Merge two sets of hunks relative to a common base.
 * Non-overlapping hunks are applied cleanly.
 * Overlapping hunks that differ produce conflicts.
 * Overlapping hunks with identical changes are deduplicated.
 */
const mergeHunks = (
  base: readonly string[],
  oursHunks: readonly DiffHunk[],
  theirsHunks: readonly DiffHunk[],
): readonly MergeRegion[] => {
  const regions: MergeRegion[] = [];

  // Create an event list of all hunks sorted by baseStart
  type TaggedHunk = { readonly hunk: DiffHunk; readonly side: 'ours' | 'theirs' };
  const allHunks: TaggedHunk[] = [
    ...oursHunks.map(h => ({ hunk: h, side: 'ours' as const })),
    ...theirsHunks.map(h => ({ hunk: h, side: 'theirs' as const })),
  ].sort((a, b) => a.hunk.baseStart - b.hunk.baseStart || a.hunk.baseEnd - b.hunk.baseEnd);

  let basePos = 0;
  let idx = 0;

  while (idx < allHunks.length) {
    const current = allHunks[idx];

    // Emit unchanged base lines before this hunk
    if (basePos < current.hunk.baseStart) {
      regions.push({
        type: 'clean',
        lines: base.slice(basePos, current.hunk.baseStart),
      });
      basePos = current.hunk.baseStart;
    }

    // Find all hunks that overlap with the current one
    let groupEnd = current.hunk.baseEnd;
    const groupHunks: TaggedHunk[] = [current];
    let next = idx + 1;
    while (next < allHunks.length && allHunks[next].hunk.baseStart < groupEnd) {
      groupHunks.push(allHunks[next]);
      groupEnd = Math.max(groupEnd, allHunks[next].hunk.baseEnd);
      next++;
    }

    const oursInGroup = groupHunks.filter(h => h.side === 'ours');
    const theirsInGroup = groupHunks.filter(h => h.side === 'theirs');

    if (oursInGroup.length === 0) {
      // Only theirs changes: apply cleanly
      for (const th of theirsInGroup) {
        regions.push({ type: 'clean', lines: th.hunk.lines });
      }
    } else if (theirsInGroup.length === 0) {
      // Only ours changes: apply cleanly
      for (const oh of oursInGroup) {
        regions.push({ type: 'clean', lines: oh.hunk.lines });
      }
    } else {
      // Both sides changed the same region
      // Check if all changes are identical
      const allIdentical = oursInGroup.length === theirsInGroup.length &&
        oursInGroup.every((oh, i) => hunksIdentical(oh.hunk, theirsInGroup[i].hunk));

      if (allIdentical) {
        // Identical changes: apply once
        for (const oh of oursInGroup) {
          regions.push({ type: 'clean', lines: oh.hunk.lines });
        }
      } else {
        // True conflict
        const oursLines = oursInGroup.flatMap(h => [...h.hunk.lines]);
        const theirsLines = theirsInGroup.flatMap(h => [...h.hunk.lines]);
        regions.push({ type: 'conflict', ours: oursLines, theirs: theirsLines });
      }
    }

    basePos = groupEnd;
    idx = next;
  }

  // Emit any remaining base lines
  if (basePos < base.length) {
    regions.push({ type: 'clean', lines: base.slice(basePos) });
  }

  return regions;
};

/**
 * Format conflict markers in the standard diff3 style.
 */
const formatConflictRegion = (
  ours: readonly string[],
  theirs: readonly string[],
): string =>
  [
    '<<<<<<< ours',
    ...ours,
    '=======',
    ...theirs,
    '>>>>>>> theirs',
  ].join('\n');

// --- Implementation ---

export const threeWayMergeHandler: ThreeWayMergeHandler = {
  register: (_input, _storage) =>
    TE.right(
      registerOk('three-way', 'merge', ['text/plain', 'text/*']),
    ),

  execute: (input, _storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const baseLines = splitLines(input.base);
          const oursLines = splitLines(input.ours);
          const theirsLines = splitLines(input.theirs);
          return { baseLines, oursLines, theirsLines };
        },
        (error): ThreeWayMergeError => ({
          code: 'DECODE_ERROR',
          message: `Failed to decode input buffers: ${error instanceof Error ? error.message : String(error)}`,
        }),
      ),
      TE.map(({ baseLines, oursLines, theirsLines }) => {
        const oursHunks = extractHunks(baseLines, oursLines);
        const theirsHunks = extractHunks(baseLines, theirsLines);
        const regions = mergeHunks(baseLines, oursHunks, theirsHunks);

        const hasConflicts = regions.some(r => r.type === 'conflict');

        if (!hasConflicts) {
          // All regions are clean: combine into final result
          const mergedLines = regions.flatMap(r => {
            if (r.type === 'clean') return [...r.lines];
            return []; // unreachable given the check above
          });
          return executeClean(joinLines(mergedLines));
        }

        // Build conflict region buffers
        const conflictRegions: Buffer[] = regions
          .filter((r): r is Extract<MergeRegion, { readonly type: 'conflict' }> =>
            r.type === 'conflict',
          )
          .map(r => Buffer.from(formatConflictRegion(r.ours, r.theirs), 'utf-8'));

        return executeConflicts(conflictRegions);
      }),
    ),
};
