// AddWinsResolution — handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  AddWinsResolutionStorage,
  AddWinsResolutionRegisterInput,
  AddWinsResolutionRegisterOutput,
  AddWinsResolutionAttemptResolveInput,
  AddWinsResolutionAttemptResolveOutput,
} from './types.js';

import {
  registerOk,
  attemptResolveResolved,
  attemptResolveCannotResolve,
} from './types.js';

export interface AddWinsResolutionError {
  readonly code: string;
  readonly message: string;
}

export interface AddWinsResolutionHandler {
  readonly register: (
    input: AddWinsResolutionRegisterInput,
    storage: AddWinsResolutionStorage,
  ) => TE.TaskEither<AddWinsResolutionError, AddWinsResolutionRegisterOutput>;
  readonly attemptResolve: (
    input: AddWinsResolutionAttemptResolveInput,
    storage: AddWinsResolutionStorage,
  ) => TE.TaskEither<AddWinsResolutionError, AddWinsResolutionAttemptResolveOutput>;
}

// --- Helpers ---

const storageError = (error: unknown): AddWinsResolutionError => ({
  code: 'STORAGE_ERROR',
  message: error instanceof Error ? error.message : String(error),
});

/**
 * Parse a buffer as a JSON set (array of strings). Returns null if the buffer
 * does not represent a valid JSON array — indicating the content is not
 * set-like and cannot be resolved by add-wins semantics.
 */
const parseAsSet = (buf: Buffer): ReadonlySet<string> | null => {
  try {
    const parsed = JSON.parse(buf.toString('utf-8'));
    if (!Array.isArray(parsed)) return null;
    return new Set(parsed.map(String));
  } catch {
    return null;
  }
};

/** Serialize a set back into a sorted JSON array buffer. Sorting guarantees
 *  commutativity: resolve(v1, v2) === resolve(v2, v1). */
const serializeSet = (set: ReadonlySet<string>): Buffer =>
  Buffer.from(JSON.stringify([...set].sort()));

// --- Implementation ---

export const addWinsResolutionHandler: AddWinsResolutionHandler = {
  register: (_input, _storage) =>
    pipe(
      TE.right(registerOk('add-wins', 'conflict-resolution', 20)),
    ),

  attemptResolve: (input, _storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const set1 = parseAsSet(input.v1);
          const set2 = parseAsSet(input.v2);

          // If either version is not a valid set structure, we cannot resolve
          if (set1 === null || set2 === null) {
            return attemptResolveCannotResolve(
              'Content is not a set-like structure (expected JSON array)',
            );
          }

          // Add-Wins (OR-Set) semantics: the result is the union of both sets.
          // Any element that appears in either version is kept — additions
          // always win over concurrent removals.
          const baseSet = pipe(
            input.base,
            O.fold(
              () => new Set<string>(),
              (baseBuf) => {
                const parsed = parseAsSet(baseBuf);
                return parsed !== null ? new Set(parsed) : new Set<string>();
              },
            ),
          );

          // Compute the elements each side added relative to base
          const added1 = new Set([...set1].filter((x) => !baseSet.has(x)));
          const added2 = new Set([...set2].filter((x) => !baseSet.has(x)));

          // Compute the elements each side removed relative to base
          const removed1 = new Set([...baseSet].filter((x) => !set1.has(x)));
          const removed2 = new Set([...baseSet].filter((x) => !set2.has(x)));

          // Start from base, add everything both sides added, only remove
          // if BOTH sides removed (add-wins means if one side added or kept,
          // the element stays).
          const result = new Set(baseSet);

          // Add all additions from both sides
          for (const elem of added1) result.add(elem);
          for (const elem of added2) result.add(elem);

          // Remove only elements that both sides removed and neither re-added
          for (const elem of removed1) {
            if (removed2.has(elem) && !added1.has(elem) && !added2.has(elem)) {
              result.delete(elem);
            }
          }

          // Also include anything in v1 or v2 not in base (handles no-base case)
          for (const elem of set1) result.add(elem);
          for (const elem of set2) result.add(elem);

          return attemptResolveResolved(serializeSet(result));
        },
        storageError,
      ),
    ),
};
