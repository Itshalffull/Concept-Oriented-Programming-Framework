// ExpressionLanguage — route.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

// Next.js App Router Route Handler — maps HTTP to concept actions
// Place at: app/api/expression-language/route.ts

import { NextRequest, NextResponse } from 'next/server';
import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import { pipe } from 'fp-ts/function';

import type { ExpressionLanguageHandler, ExpressionLanguageError } from './handler.js';
import type { ExpressionLanguageStorage } from './types.js';

const errorResponse = (error: ExpressionLanguageError, status = 422): NextResponse =>
  NextResponse.json({ errors: [{ code: error.code, message: error.message }] }, { status });

const successResponse = <T>(data: T, status = 200): NextResponse =>
  NextResponse.json(data, { status });

export const createExpressionLanguageRoutes = (
  handler: ExpressionLanguageHandler,
  storage: ExpressionLanguageStorage,
) => {

  const dispatch = async (action: string, input: Record<string, unknown>): Promise<NextResponse> => {
    switch (action) {
      case 'registerLanguage': {
        const result = await handler.registerLanguage(input as any, storage)();
        return pipe(
          result,
          E.fold(
            (error) => errorResponse(error),
            (output) => successResponse(output),
          ),
        );
      }
      case 'registerFunction': {
        const result = await handler.registerFunction(input as any, storage)();
        return pipe(
          result,
          E.fold(
            (error) => errorResponse(error),
            (output) => successResponse(output),
          ),
        );
      }
      case 'registerOperator': {
        const result = await handler.registerOperator(input as any, storage)();
        return pipe(
          result,
          E.fold(
            (error) => errorResponse(error),
            (output) => successResponse(output),
          ),
        );
      }
      case 'parse': {
        const result = await handler.parse(input as any, storage)();
        return pipe(
          result,
          E.fold(
            (error) => errorResponse(error),
            (output) => successResponse(output),
          ),
        );
      }
      case 'evaluate': {
        const result = await handler.evaluate(input as any, storage)();
        return pipe(
          result,
          E.fold(
            (error) => errorResponse(error),
            (output) => successResponse(output),
          ),
        );
      }
      case 'typeCheck': {
        const result = await handler.typeCheck(input as any, storage)();
        return pipe(
          result,
          E.fold(
            (error) => errorResponse(error),
            (output) => successResponse(output),
          ),
        );
      }
      case 'getCompletions': {
        const result = await handler.getCompletions(input as any, storage)();
        return pipe(
          result,
          E.fold(
            (error) => errorResponse(error),
            (output) => successResponse(output),
          ),
        );
      }
      default:
        return NextResponse.json(
          { errors: [{ code: 'UNKNOWN_ACTION', message: `Unknown action: ${action}` }] },
          { status: 404 },
        );
    }
  };

  const POST = async (request: NextRequest): Promise<NextResponse> => {
    const body = await request.json() as { action: string; input: Record<string, unknown> };
    return dispatch(body.action, body.input);
  };

  const GET = async (request: NextRequest): Promise<NextResponse> => {
    const { searchParams } = new URL(request.url);
    const action = searchParams.get('action') ?? 'getCompletions';
    const input: Record<string, unknown> = {};
    searchParams.forEach((value, key) => {
      if (key !== 'action') input[key] = value;
    });
    return dispatch(action, input);
  };

  return { POST, GET };
};
