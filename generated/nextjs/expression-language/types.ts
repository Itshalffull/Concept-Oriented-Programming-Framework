// ExpressionLanguage â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

// Storage interface for ExpressionLanguage
export interface ExpressionLanguageStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface ExpressionLanguageRegisterLanguageInput {
  readonly name: string;
  readonly grammar: string;
}

export interface ExpressionLanguageRegisterLanguageOutputOk {
  readonly variant: 'ok';
}

export interface ExpressionLanguageRegisterLanguageOutputExists {
  readonly variant: 'exists';
}

export type ExpressionLanguageRegisterLanguageOutput = ExpressionLanguageRegisterLanguageOutputOk | ExpressionLanguageRegisterLanguageOutputExists;

export interface ExpressionLanguageRegisterFunctionInput {
  readonly name: string;
  readonly implementation: string;
}

export interface ExpressionLanguageRegisterFunctionOutputOk {
  readonly variant: 'ok';
}

export interface ExpressionLanguageRegisterFunctionOutputExists {
  readonly variant: 'exists';
}

export type ExpressionLanguageRegisterFunctionOutput = ExpressionLanguageRegisterFunctionOutputOk | ExpressionLanguageRegisterFunctionOutputExists;

export interface ExpressionLanguageRegisterOperatorInput {
  readonly name: string;
  readonly implementation: string;
}

export interface ExpressionLanguageRegisterOperatorOutputOk {
  readonly variant: 'ok';
}

export interface ExpressionLanguageRegisterOperatorOutputExists {
  readonly variant: 'exists';
}

export type ExpressionLanguageRegisterOperatorOutput = ExpressionLanguageRegisterOperatorOutputOk | ExpressionLanguageRegisterOperatorOutputExists;

export interface ExpressionLanguageParseInput {
  readonly expression: string;
  readonly text: string;
  readonly language: string;
}

export interface ExpressionLanguageParseOutputOk {
  readonly variant: 'ok';
  readonly ast: string;
}

export interface ExpressionLanguageParseOutputError {
  readonly variant: 'error';
}

export type ExpressionLanguageParseOutput = ExpressionLanguageParseOutputOk | ExpressionLanguageParseOutputError;

export interface ExpressionLanguageEvaluateInput {
  readonly expression: string;
}

export interface ExpressionLanguageEvaluateOutputOk {
  readonly variant: 'ok';
  readonly result: string;
}

export interface ExpressionLanguageEvaluateOutputNotfound {
  readonly variant: 'notfound';
}

export type ExpressionLanguageEvaluateOutput = ExpressionLanguageEvaluateOutputOk | ExpressionLanguageEvaluateOutputNotfound;

export interface ExpressionLanguageTypeCheckInput {
  readonly expression: string;
}

export interface ExpressionLanguageTypeCheckOutputOk {
  readonly variant: 'ok';
  readonly valid: boolean;
  readonly errors: string;
}

export interface ExpressionLanguageTypeCheckOutputNotfound {
  readonly variant: 'notfound';
}

export type ExpressionLanguageTypeCheckOutput = ExpressionLanguageTypeCheckOutputOk | ExpressionLanguageTypeCheckOutputNotfound;

export interface ExpressionLanguageGetCompletionsInput {
  readonly expression: string;
  readonly cursor: number;
}

export interface ExpressionLanguageGetCompletionsOutputOk {
  readonly variant: 'ok';
  readonly completions: string;
}

export interface ExpressionLanguageGetCompletionsOutputNotfound {
  readonly variant: 'notfound';
}

export type ExpressionLanguageGetCompletionsOutput = ExpressionLanguageGetCompletionsOutputOk | ExpressionLanguageGetCompletionsOutputNotfound;

// --- Variant constructors ---

export const registerLanguageOk = (): ExpressionLanguageRegisterLanguageOutput => ({ variant: 'ok' } as ExpressionLanguageRegisterLanguageOutput);
export const registerLanguageExists = (): ExpressionLanguageRegisterLanguageOutput => ({ variant: 'exists' } as ExpressionLanguageRegisterLanguageOutput);

export const registerFunctionOk = (): ExpressionLanguageRegisterFunctionOutput => ({ variant: 'ok' } as ExpressionLanguageRegisterFunctionOutput);
export const registerFunctionExists = (): ExpressionLanguageRegisterFunctionOutput => ({ variant: 'exists' } as ExpressionLanguageRegisterFunctionOutput);

export const registerOperatorOk = (): ExpressionLanguageRegisterOperatorOutput => ({ variant: 'ok' } as ExpressionLanguageRegisterOperatorOutput);
export const registerOperatorExists = (): ExpressionLanguageRegisterOperatorOutput => ({ variant: 'exists' } as ExpressionLanguageRegisterOperatorOutput);

export const parseOk = (ast: string): ExpressionLanguageParseOutput => ({ variant: 'ok', ast } as ExpressionLanguageParseOutput);
export const parseError = (): ExpressionLanguageParseOutput => ({ variant: 'error' } as ExpressionLanguageParseOutput);

export const evaluateOk = (result: string): ExpressionLanguageEvaluateOutput => ({ variant: 'ok', result } as ExpressionLanguageEvaluateOutput);
export const evaluateNotfound = (): ExpressionLanguageEvaluateOutput => ({ variant: 'notfound' } as ExpressionLanguageEvaluateOutput);

export const typeCheckOk = (valid: boolean, errors: string): ExpressionLanguageTypeCheckOutput => ({ variant: 'ok', valid, errors } as ExpressionLanguageTypeCheckOutput);
export const typeCheckNotfound = (): ExpressionLanguageTypeCheckOutput => ({ variant: 'notfound' } as ExpressionLanguageTypeCheckOutput);

export const getCompletionsOk = (completions: string): ExpressionLanguageGetCompletionsOutput => ({ variant: 'ok', completions } as ExpressionLanguageGetCompletionsOutput);
export const getCompletionsNotfound = (): ExpressionLanguageGetCompletionsOutput => ({ variant: 'notfound' } as ExpressionLanguageGetCompletionsOutput);

