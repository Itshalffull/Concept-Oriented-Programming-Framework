// ExpressionLanguage â€” handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  ExpressionLanguageStorage,
  ExpressionLanguageRegisterLanguageInput,
  ExpressionLanguageRegisterLanguageOutput,
  ExpressionLanguageRegisterFunctionInput,
  ExpressionLanguageRegisterFunctionOutput,
  ExpressionLanguageRegisterOperatorInput,
  ExpressionLanguageRegisterOperatorOutput,
  ExpressionLanguageParseInput,
  ExpressionLanguageParseOutput,
  ExpressionLanguageEvaluateInput,
  ExpressionLanguageEvaluateOutput,
  ExpressionLanguageTypeCheckInput,
  ExpressionLanguageTypeCheckOutput,
  ExpressionLanguageGetCompletionsInput,
  ExpressionLanguageGetCompletionsOutput,
} from './types.js';

import {
  registerLanguageOk,
  registerLanguageExists,
  registerFunctionOk,
  registerFunctionExists,
  registerOperatorOk,
  registerOperatorExists,
  parseOk,
  parseError,
  evaluateOk,
  evaluateNotfound,
  typeCheckOk,
  typeCheckNotfound,
  getCompletionsOk,
  getCompletionsNotfound,
} from './types.js';

export interface ExpressionLanguageError {
  readonly code: string;
  readonly message: string;
}

export interface ExpressionLanguageHandler {
  readonly registerLanguage: (
    input: ExpressionLanguageRegisterLanguageInput,
    storage: ExpressionLanguageStorage,
  ) => TE.TaskEither<ExpressionLanguageError, ExpressionLanguageRegisterLanguageOutput>;
  readonly registerFunction: (
    input: ExpressionLanguageRegisterFunctionInput,
    storage: ExpressionLanguageStorage,
  ) => TE.TaskEither<ExpressionLanguageError, ExpressionLanguageRegisterFunctionOutput>;
  readonly registerOperator: (
    input: ExpressionLanguageRegisterOperatorInput,
    storage: ExpressionLanguageStorage,
  ) => TE.TaskEither<ExpressionLanguageError, ExpressionLanguageRegisterOperatorOutput>;
  readonly parse: (
    input: ExpressionLanguageParseInput,
    storage: ExpressionLanguageStorage,
  ) => TE.TaskEither<ExpressionLanguageError, ExpressionLanguageParseOutput>;
  readonly evaluate: (
    input: ExpressionLanguageEvaluateInput,
    storage: ExpressionLanguageStorage,
  ) => TE.TaskEither<ExpressionLanguageError, ExpressionLanguageEvaluateOutput>;
  readonly typeCheck: (
    input: ExpressionLanguageTypeCheckInput,
    storage: ExpressionLanguageStorage,
  ) => TE.TaskEither<ExpressionLanguageError, ExpressionLanguageTypeCheckOutput>;
  readonly getCompletions: (
    input: ExpressionLanguageGetCompletionsInput,
    storage: ExpressionLanguageStorage,
  ) => TE.TaskEither<ExpressionLanguageError, ExpressionLanguageGetCompletionsOutput>;
}

// --- AST node types for expression language ---

type ASTNode =
  | { readonly type: 'number'; readonly value: number }
  | { readonly type: 'string'; readonly value: string }
  | { readonly type: 'boolean'; readonly value: boolean }
  | { readonly type: 'identifier'; readonly name: string }
  | { readonly type: 'binary'; readonly op: string; readonly left: ASTNode; readonly right: ASTNode }
  | { readonly type: 'unary'; readonly op: string; readonly operand: ASTNode }
  | { readonly type: 'call'; readonly name: string; readonly args: readonly ASTNode[] };

// --- Tokenizer ---

interface Token {
  readonly type: 'number' | 'string' | 'boolean' | 'identifier' | 'operator' | 'lparen' | 'rparen' | 'comma';
  readonly value: string;
}

const OPERATORS = new Set(['+', '-', '*', '/', '%', '==', '!=', '<', '>', '<=', '>=', '&&', '||', '!']);
const TWO_CHAR_OPS = new Set(['==', '!=', '<=', '>=', '&&', '||']);

const tokenize = (text: string): E.Either<string, readonly Token[]> => {
  const tokens: Token[] = [];
  let i = 0;

  while (i < text.length) {
    const ch = text[i];

    // Skip whitespace
    if (ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r') {
      i++;
      continue;
    }

    // Number literal
    if (ch >= '0' && ch <= '9') {
      let num = '';
      let hasDot = false;
      while (i < text.length && ((text[i] >= '0' && text[i] <= '9') || (text[i] === '.' && !hasDot))) {
        if (text[i] === '.') hasDot = true;
        num += text[i];
        i++;
      }
      tokens.push({ type: 'number', value: num });
      continue;
    }

    // String literal
    if (ch === '"' || ch === "'") {
      const quote = ch;
      i++;
      let str = '';
      while (i < text.length && text[i] !== quote) {
        if (text[i] === '\\' && i + 1 < text.length) {
          str += text[i + 1];
          i += 2;
        } else {
          str += text[i];
          i++;
        }
      }
      if (i >= text.length) return E.left('Unterminated string literal');
      i++; // skip closing quote
      tokens.push({ type: 'string', value: str });
      continue;
    }

    // Two-character operators
    if (i + 1 < text.length) {
      const twoChar = text[i] + text[i + 1];
      if (TWO_CHAR_OPS.has(twoChar)) {
        tokens.push({ type: 'operator', value: twoChar });
        i += 2;
        continue;
      }
    }

    // Single-character operators
    if (OPERATORS.has(ch)) {
      tokens.push({ type: 'operator', value: ch });
      i++;
      continue;
    }

    // Parentheses and comma
    if (ch === '(') { tokens.push({ type: 'lparen', value: '(' }); i++; continue; }
    if (ch === ')') { tokens.push({ type: 'rparen', value: ')' }); i++; continue; }
    if (ch === ',') { tokens.push({ type: 'comma', value: ',' }); i++; continue; }

    // Identifier or boolean keyword
    if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '_') {
      let ident = '';
      while (i < text.length && ((text[i] >= 'a' && text[i] <= 'z') || (text[i] >= 'A' && text[i] <= 'Z') || (text[i] >= '0' && text[i] <= '9') || text[i] === '_')) {
        ident += text[i];
        i++;
      }
      if (ident === 'true' || ident === 'false') {
        tokens.push({ type: 'boolean', value: ident });
      } else {
        tokens.push({ type: 'identifier', value: ident });
      }
      continue;
    }

    return E.left(`Unexpected character '${ch}' at position ${i}`);
  }

  return E.right(tokens);
};

// --- Recursive descent parser ---
// Precedence (low to high): ||, &&, ==|!=, <|>|<=|>=, +|-, *|/|%, unary !|-

interface ParseState {
  readonly tokens: readonly Token[];
  pos: number;
}

const peek = (state: ParseState): Token | undefined =>
  state.pos < state.tokens.length ? state.tokens[state.pos] : undefined;

const advance = (state: ParseState): Token | undefined => {
  const tok = state.tokens[state.pos];
  state.pos++;
  return tok;
};

const expect = (state: ParseState, type: string, value?: string): E.Either<string, Token> => {
  const tok = peek(state);
  if (!tok) return E.left(`Expected ${type} but reached end of input`);
  if (tok.type !== type) return E.left(`Expected ${type} but got ${tok.type} '${tok.value}'`);
  if (value !== undefined && tok.value !== value) return E.left(`Expected '${value}' but got '${tok.value}'`);
  advance(state);
  return E.right(tok);
};

const parseExpression = (state: ParseState): E.Either<string, ASTNode> => parseOr(state);

const parseOr = (state: ParseState): E.Either<string, ASTNode> => {
  let result = parseAnd(state);
  if (E.isLeft(result)) return result;
  let node = result.right;

  while (peek(state)?.type === 'operator' && peek(state)?.value === '||') {
    advance(state);
    const right = parseAnd(state);
    if (E.isLeft(right)) return right;
    node = { type: 'binary', op: '||', left: node, right: right.right };
  }

  return E.right(node);
};

const parseAnd = (state: ParseState): E.Either<string, ASTNode> => {
  let result = parseEquality(state);
  if (E.isLeft(result)) return result;
  let node = result.right;

  while (peek(state)?.type === 'operator' && peek(state)?.value === '&&') {
    advance(state);
    const right = parseEquality(state);
    if (E.isLeft(right)) return right;
    node = { type: 'binary', op: '&&', left: node, right: right.right };
  }

  return E.right(node);
};

const parseEquality = (state: ParseState): E.Either<string, ASTNode> => {
  let result = parseComparison(state);
  if (E.isLeft(result)) return result;
  let node = result.right;

  while (peek(state)?.type === 'operator' && (peek(state)?.value === '==' || peek(state)?.value === '!=')) {
    const op = advance(state)!.value;
    const right = parseComparison(state);
    if (E.isLeft(right)) return right;
    node = { type: 'binary', op, left: node, right: right.right };
  }

  return E.right(node);
};

const parseComparison = (state: ParseState): E.Either<string, ASTNode> => {
  let result = parseAdditive(state);
  if (E.isLeft(result)) return result;
  let node = result.right;

  while (peek(state)?.type === 'operator' && (peek(state)?.value === '<' || peek(state)?.value === '>' || peek(state)?.value === '<=' || peek(state)?.value === '>=')) {
    const op = advance(state)!.value;
    const right = parseAdditive(state);
    if (E.isLeft(right)) return right;
    node = { type: 'binary', op, left: node, right: right.right };
  }

  return E.right(node);
};

const parseAdditive = (state: ParseState): E.Either<string, ASTNode> => {
  let result = parseMultiplicative(state);
  if (E.isLeft(result)) return result;
  let node = result.right;

  while (peek(state)?.type === 'operator' && (peek(state)?.value === '+' || peek(state)?.value === '-')) {
    const op = advance(state)!.value;
    const right = parseMultiplicative(state);
    if (E.isLeft(right)) return right;
    node = { type: 'binary', op, left: node, right: right.right };
  }

  return E.right(node);
};

const parseMultiplicative = (state: ParseState): E.Either<string, ASTNode> => {
  let result = parseUnary(state);
  if (E.isLeft(result)) return result;
  let node = result.right;

  while (peek(state)?.type === 'operator' && (peek(state)?.value === '*' || peek(state)?.value === '/' || peek(state)?.value === '%')) {
    const op = advance(state)!.value;
    const right = parseUnary(state);
    if (E.isLeft(right)) return right;
    node = { type: 'binary', op, left: node, right: right.right };
  }

  return E.right(node);
};

const parseUnary = (state: ParseState): E.Either<string, ASTNode> => {
  if (peek(state)?.type === 'operator' && (peek(state)?.value === '!' || peek(state)?.value === '-')) {
    const op = advance(state)!.value;
    const operand = parseUnary(state);
    if (E.isLeft(operand)) return operand;
    return E.right({ type: 'unary', op, operand: operand.right });
  }
  return parsePrimary(state);
};

const parsePrimary = (state: ParseState): E.Either<string, ASTNode> => {
  const tok = peek(state);
  if (!tok) return E.left('Unexpected end of input');

  // Number
  if (tok.type === 'number') {
    advance(state);
    return E.right({ type: 'number', value: parseFloat(tok.value) });
  }

  // String
  if (tok.type === 'string') {
    advance(state);
    return E.right({ type: 'string', value: tok.value });
  }

  // Boolean
  if (tok.type === 'boolean') {
    advance(state);
    return E.right({ type: 'boolean', value: tok.value === 'true' });
  }

  // Identifier or function call
  if (tok.type === 'identifier') {
    advance(state);
    // Check for function call
    if (peek(state)?.type === 'lparen') {
      advance(state); // consume '('
      const args: ASTNode[] = [];
      if (peek(state)?.type !== 'rparen') {
        const firstArg = parseExpression(state);
        if (E.isLeft(firstArg)) return firstArg;
        args.push(firstArg.right);
        while (peek(state)?.type === 'comma') {
          advance(state);
          const nextArg = parseExpression(state);
          if (E.isLeft(nextArg)) return nextArg;
          args.push(nextArg.right);
        }
      }
      const close = expect(state, 'rparen');
      if (E.isLeft(close)) return close;
      return E.right({ type: 'call', name: tok.value, args });
    }
    return E.right({ type: 'identifier', name: tok.value });
  }

  // Parenthesized expression
  if (tok.type === 'lparen') {
    advance(state);
    const inner = parseExpression(state);
    if (E.isLeft(inner)) return inner;
    const close = expect(state, 'rparen');
    if (E.isLeft(close)) return close;
    return inner;
  }

  return E.left(`Unexpected token '${tok.value}' of type ${tok.type}`);
};

// --- AST serialization ---

const serializeAST = (node: ASTNode): string => {
  switch (node.type) {
    case 'number': return String(node.value);
    case 'string': return `"${node.value}"`;
    case 'boolean': return String(node.value);
    case 'identifier': return node.name;
    case 'binary': return `${node.op}(${serializeAST(node.left)}, ${serializeAST(node.right)})`;
    case 'unary': return `${node.op}(${serializeAST(node.operand)})`;
    case 'call': return `${node.name}(${node.args.map(serializeAST).join(', ')})`;
  }
};

// --- Evaluator ---

type Value = number | string | boolean;

const evaluateAST = (
  node: ASTNode,
  variables: ReadonlyMap<string, Value>,
  functions: ReadonlyMap<string, (...args: readonly Value[]) => Value>,
): E.Either<string, Value> => {
  switch (node.type) {
    case 'number': return E.right(node.value);
    case 'string': return E.right(node.value);
    case 'boolean': return E.right(node.value);

    case 'identifier': {
      const val = variables.get(node.name);
      if (val === undefined) return E.left(`Undefined variable '${node.name}'`);
      return E.right(val);
    }

    case 'unary': {
      const operand = evaluateAST(node.operand, variables, functions);
      if (E.isLeft(operand)) return operand;
      const v = operand.right;
      switch (node.op) {
        case '!': return E.right(!v);
        case '-': return typeof v === 'number' ? E.right(-v) : E.left(`Cannot negate ${typeof v}`);
        default: return E.left(`Unknown unary operator '${node.op}'`);
      }
    }

    case 'binary': {
      const left = evaluateAST(node.left, variables, functions);
      if (E.isLeft(left)) return left;
      const right = evaluateAST(node.right, variables, functions);
      if (E.isLeft(right)) return right;
      const lv = left.right;
      const rv = right.right;

      switch (node.op) {
        case '+':
          if (typeof lv === 'number' && typeof rv === 'number') return E.right(lv + rv);
          if (typeof lv === 'string' || typeof rv === 'string') return E.right(String(lv) + String(rv));
          return E.left(`Cannot add ${typeof lv} and ${typeof rv}`);
        case '-':
          if (typeof lv === 'number' && typeof rv === 'number') return E.right(lv - rv);
          return E.left(`Cannot subtract ${typeof rv} from ${typeof lv}`);
        case '*':
          if (typeof lv === 'number' && typeof rv === 'number') return E.right(lv * rv);
          return E.left(`Cannot multiply ${typeof lv} and ${typeof rv}`);
        case '/':
          if (typeof lv === 'number' && typeof rv === 'number') {
            if (rv === 0) return E.left('Division by zero');
            return E.right(lv / rv);
          }
          return E.left(`Cannot divide ${typeof lv} by ${typeof rv}`);
        case '%':
          if (typeof lv === 'number' && typeof rv === 'number') {
            if (rv === 0) return E.left('Modulo by zero');
            return E.right(lv % rv);
          }
          return E.left(`Cannot modulo ${typeof lv} by ${typeof rv}`);
        case '==': return E.right(lv === rv);
        case '!=': return E.right(lv !== rv);
        case '<':
          if (typeof lv === 'number' && typeof rv === 'number') return E.right(lv < rv);
          if (typeof lv === 'string' && typeof rv === 'string') return E.right(lv < rv);
          return E.left(`Cannot compare ${typeof lv} and ${typeof rv}`);
        case '>':
          if (typeof lv === 'number' && typeof rv === 'number') return E.right(lv > rv);
          if (typeof lv === 'string' && typeof rv === 'string') return E.right(lv > rv);
          return E.left(`Cannot compare ${typeof lv} and ${typeof rv}`);
        case '<=':
          if (typeof lv === 'number' && typeof rv === 'number') return E.right(lv <= rv);
          return E.left(`Cannot compare ${typeof lv} and ${typeof rv}`);
        case '>=':
          if (typeof lv === 'number' && typeof rv === 'number') return E.right(lv >= rv);
          return E.left(`Cannot compare ${typeof lv} and ${typeof rv}`);
        case '&&': return E.right(Boolean(lv) && Boolean(rv));
        case '||': return E.right(Boolean(lv) || Boolean(rv));
        default: return E.left(`Unknown binary operator '${node.op}'`);
      }
    }

    case 'call': {
      const fn = functions.get(node.name);
      if (fn === undefined) return E.left(`Undefined function '${node.name}'`);
      const evaluatedArgs: Value[] = [];
      for (const arg of node.args) {
        const result = evaluateAST(arg, variables, functions);
        if (E.isLeft(result)) return result;
        evaluatedArgs.push(result.right);
      }
      return E.right(fn(...evaluatedArgs));
    }
  }
};

// --- Type inference ---

type ExprType = 'number' | 'string' | 'boolean' | 'unknown';

const inferType = (node: ASTNode): ExprType => {
  switch (node.type) {
    case 'number': return 'number';
    case 'string': return 'string';
    case 'boolean': return 'boolean';
    case 'identifier': return 'unknown';
    case 'unary':
      return node.op === '!' ? 'boolean' : node.op === '-' ? 'number' : 'unknown';
    case 'binary': {
      if (['==', '!=', '<', '>', '<=', '>=', '&&', '||'].includes(node.op)) return 'boolean';
      if (['+', '-', '*', '/', '%'].includes(node.op)) {
        const lt = inferType(node.left);
        const rt = inferType(node.right);
        if (node.op === '+' && (lt === 'string' || rt === 'string')) return 'string';
        return 'number';
      }
      return 'unknown';
    }
    case 'call': return 'unknown';
  }
};

// Collect identifiers from AST
const collectIdentifiers = (node: ASTNode): readonly string[] => {
  switch (node.type) {
    case 'number':
    case 'string':
    case 'boolean':
      return [];
    case 'identifier':
      return [node.name];
    case 'unary':
      return collectIdentifiers(node.operand);
    case 'binary':
      return [...collectIdentifiers(node.left), ...collectIdentifiers(node.right)];
    case 'call':
      return node.args.flatMap(collectIdentifiers);
  }
};

const makeStorageError = (error: unknown): ExpressionLanguageError => ({
  code: 'STORAGE_ERROR',
  message: error instanceof Error ? error.message : String(error),
});

// --- Built-in functions ---

const builtinFunctions = new Map<string, (...args: readonly Value[]) => Value>([
  ['abs', (x: Value) => Math.abs(Number(x))],
  ['floor', (x: Value) => Math.floor(Number(x))],
  ['ceil', (x: Value) => Math.ceil(Number(x))],
  ['round', (x: Value) => Math.round(Number(x))],
  ['min', (...args: readonly Value[]) => Math.min(...args.map(Number))],
  ['max', (...args: readonly Value[]) => Math.max(...args.map(Number))],
  ['sqrt', (x: Value) => Math.sqrt(Number(x))],
  ['pow', (base: Value, exp: Value) => Math.pow(Number(base), Number(exp))],
  ['len', (x: Value) => String(x).length],
  ['upper', (x: Value) => String(x).toUpperCase()],
  ['lower', (x: Value) => String(x).toLowerCase()],
  ['str', (x: Value) => String(x)],
  ['num', (x: Value) => Number(x)],
  ['if', (cond: Value, then: Value, els: Value) => (cond ? then : els)],
]);

// --- Implementation ---

export const expressionLanguageHandler: ExpressionLanguageHandler = {
  registerLanguage: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const existing = await storage.get('el_languages', input.name);
          if (existing !== null) return registerLanguageExists();
          await storage.put('el_languages', input.name, {
            name: input.name,
            grammar: input.grammar,
          });
          return registerLanguageOk();
        },
        makeStorageError,
      ),
    ),

  registerFunction: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const existing = await storage.get('el_functions', input.name);
          if (existing !== null) return registerFunctionExists();
          await storage.put('el_functions', input.name, {
            name: input.name,
            implementation: input.implementation,
          });
          return registerFunctionOk();
        },
        makeStorageError,
      ),
    ),

  registerOperator: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const existing = await storage.get('el_operators', input.name);
          if (existing !== null) return registerOperatorExists();
          await storage.put('el_operators', input.name, {
            name: input.name,
            implementation: input.implementation,
          });
          return registerOperatorOk();
        },
        makeStorageError,
      ),
    ),

  parse: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          // Verify the language is registered
          const lang = await storage.get('el_languages', input.language);
          if (lang === null) return parseError();

          // Tokenize and parse
          const tokensResult = tokenize(input.text);
          if (E.isLeft(tokensResult)) return parseError();

          const tokens = tokensResult.right;
          const state: ParseState = { tokens, pos: 0 };
          const astResult = parseExpression(state);
          if (E.isLeft(astResult)) return parseError();

          // Verify all tokens consumed
          if (state.pos < tokens.length) return parseError();

          const ast = astResult.right;
          const serialized = serializeAST(ast);

          // Cache the AST for later evaluation
          await storage.put('el_ast_cache', input.expression, {
            expression: input.expression,
            text: input.text,
            language: input.language,
            ast: JSON.stringify(ast),
            serialized,
          });

          return parseOk(serialized);
        },
        makeStorageError,
      ),
    ),

  evaluate: (input, storage) =>
    pipe(
      TE.tryCatch(
        () => storage.get('el_ast_cache', input.expression),
        makeStorageError,
      ),
      TE.chain((record) =>
        pipe(
          O.fromNullable(record),
          O.fold(
            () => TE.right<ExpressionLanguageError, ExpressionLanguageEvaluateOutput>(
              evaluateNotfound(),
            ),
            (found) =>
              TE.tryCatch(
                async () => {
                  const ast: ASTNode = JSON.parse(String(found['ast'] ?? '{}'));

                  // Load registered functions from storage
                  const storedFunctions = await storage.find('el_functions');
                  const runtimeFunctions = new Map(builtinFunctions);
                  for (const sf of storedFunctions) {
                    const name = String(sf['name'] ?? '');
                    const impl = String(sf['implementation'] ?? '');
                    // Simple function implementations: just store as-is, built-ins take precedence
                    if (name && !runtimeFunctions.has(name)) {
                      // Custom functions stored as expressions to be evaluated
                      runtimeFunctions.set(name, (...args: readonly Value[]) => {
                        // Placeholder: custom function evaluation would parse the implementation
                        return args[0] ?? 0;
                      });
                    }
                  }

                  // Collect identifiers and try to resolve from storage as variables
                  const identifiers = collectIdentifiers(ast);
                  const variables = new Map<string, Value>();
                  for (const ident of identifiers) {
                    const varRecord = await storage.get('el_variables', ident);
                    if (varRecord !== null) {
                      const raw = varRecord['value'];
                      if (typeof raw === 'number') variables.set(ident, raw);
                      else if (typeof raw === 'boolean') variables.set(ident, raw);
                      else if (typeof raw === 'string') {
                        const num = Number(raw);
                        variables.set(ident, isNaN(num) ? raw : num);
                      }
                    }
                  }

                  const result = evaluateAST(ast, variables, runtimeFunctions);
                  if (E.isLeft(result)) return evaluateOk(`Error: ${result.left}`);
                  return evaluateOk(String(result.right));
                },
                makeStorageError,
              ),
          ),
        ),
      ),
    ),

  typeCheck: (input, storage) =>
    pipe(
      TE.tryCatch(
        () => storage.get('el_ast_cache', input.expression),
        makeStorageError,
      ),
      TE.chain((record) =>
        pipe(
          O.fromNullable(record),
          O.fold(
            () => TE.right<ExpressionLanguageError, ExpressionLanguageTypeCheckOutput>(
              typeCheckNotfound(),
            ),
            (found) =>
              TE.tryCatch(
                async () => {
                  const ast: ASTNode = JSON.parse(String(found['ast'] ?? '{}'));
                  const errors: string[] = [];

                  // Walk the AST checking for type mismatches
                  const check = (node: ASTNode): void => {
                    switch (node.type) {
                      case 'binary': {
                        check(node.left);
                        check(node.right);
                        const lt = inferType(node.left);
                        const rt = inferType(node.right);
                        if (['-', '*', '/', '%'].includes(node.op)) {
                          if (lt !== 'unknown' && lt !== 'number')
                            errors.push(`Left operand of '${node.op}' must be number, got ${lt}`);
                          if (rt !== 'unknown' && rt !== 'number')
                            errors.push(`Right operand of '${node.op}' must be number, got ${rt}`);
                        }
                        if (['&&', '||'].includes(node.op)) {
                          if (lt !== 'unknown' && lt !== 'boolean')
                            errors.push(`Left operand of '${node.op}' should be boolean, got ${lt}`);
                          if (rt !== 'unknown' && rt !== 'boolean')
                            errors.push(`Right operand of '${node.op}' should be boolean, got ${rt}`);
                        }
                        break;
                      }
                      case 'unary':
                        check(node.operand);
                        if (node.op === '!' && inferType(node.operand) !== 'unknown' && inferType(node.operand) !== 'boolean')
                          errors.push(`Operand of '!' should be boolean, got ${inferType(node.operand)}`);
                        if (node.op === '-' && inferType(node.operand) !== 'unknown' && inferType(node.operand) !== 'number')
                          errors.push(`Operand of unary '-' must be number, got ${inferType(node.operand)}`);
                        break;
                      case 'call':
                        for (const arg of node.args) check(arg);
                        break;
                      default:
                        break;
                    }
                  };

                  check(ast);
                  return typeCheckOk(errors.length === 0, JSON.stringify(errors));
                },
                makeStorageError,
              ),
          ),
        ),
      ),
    ),

  getCompletions: (input, storage) =>
    pipe(
      TE.tryCatch(
        () => storage.get('el_ast_cache', input.expression),
        makeStorageError,
      ),
      TE.chain((record) =>
        pipe(
          O.fromNullable(record),
          O.fold(
            () => TE.right<ExpressionLanguageError, ExpressionLanguageGetCompletionsOutput>(
              getCompletionsNotfound(),
            ),
            () =>
              TE.tryCatch(
                async () => {
                  // Gather available completions: built-in functions + registered functions + operators
                  const builtinNames = Array.from(builtinFunctions.keys());
                  const registeredFns = await storage.find('el_functions');
                  const registeredOps = await storage.find('el_operators');
                  const registeredVars = await storage.find('el_variables');

                  const completions = [
                    ...builtinNames.map((name) => ({ type: 'function', name })),
                    ...registeredFns.map((r) => ({ type: 'function', name: String(r['name'] ?? '') })),
                    ...registeredOps.map((r) => ({ type: 'operator', name: String(r['name'] ?? '') })),
                    ...registeredVars.map((r) => ({ type: 'variable', name: String(r['name'] ?? '') })),
                  ];

                  return getCompletionsOk(JSON.stringify(completions));
                },
                makeStorageError,
              ),
          ),
        ),
      ),
    ),
};
