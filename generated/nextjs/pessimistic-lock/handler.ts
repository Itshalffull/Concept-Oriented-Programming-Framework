// PessimisticLock â€” handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  PessimisticLockStorage,
  PessimisticLockCheckOutInput,
  PessimisticLockCheckOutOutput,
  PessimisticLockCheckInInput,
  PessimisticLockCheckInOutput,
  PessimisticLockBreakLockInput,
  PessimisticLockBreakLockOutput,
  PessimisticLockRenewInput,
  PessimisticLockRenewOutput,
  PessimisticLockQueryLocksInput,
  PessimisticLockQueryLocksOutput,
  PessimisticLockQueryQueueInput,
  PessimisticLockQueryQueueOutput,
} from './types.js';

import {
  checkOutOk,
  checkOutAlreadyLocked,
  checkOutQueued,
  checkInOk,
  checkInNotFound,
  checkInNotHolder,
  breakLockOk,
  breakLockNotFound,
  breakLockUnauthorized,
  renewOk,
  renewNotFound,
  renewNotHolder,
  queryLocksOk,
  queryQueueOk,
} from './types.js';

export interface PessimisticLockError {
  readonly code: string;
  readonly message: string;
}

export interface PessimisticLockHandler {
  readonly checkOut: (
    input: PessimisticLockCheckOutInput,
    storage: PessimisticLockStorage,
  ) => TE.TaskEither<PessimisticLockError, PessimisticLockCheckOutOutput>;
  readonly checkIn: (
    input: PessimisticLockCheckInInput,
    storage: PessimisticLockStorage,
  ) => TE.TaskEither<PessimisticLockError, PessimisticLockCheckInOutput>;
  readonly breakLock: (
    input: PessimisticLockBreakLockInput,
    storage: PessimisticLockStorage,
  ) => TE.TaskEither<PessimisticLockError, PessimisticLockBreakLockOutput>;
  readonly renew: (
    input: PessimisticLockRenewInput,
    storage: PessimisticLockStorage,
  ) => TE.TaskEither<PessimisticLockError, PessimisticLockRenewOutput>;
  readonly queryLocks: (
    input: PessimisticLockQueryLocksInput,
    storage: PessimisticLockStorage,
  ) => TE.TaskEither<PessimisticLockError, PessimisticLockQueryLocksOutput>;
  readonly queryQueue: (
    input: PessimisticLockQueryQueueInput,
    storage: PessimisticLockStorage,
  ) => TE.TaskEither<PessimisticLockError, PessimisticLockQueryQueueOutput>;
}

// --- Helpers ---

const storageError = (error: unknown): PessimisticLockError => ({
  code: 'STORAGE_ERROR',
  message: error instanceof Error ? error.message : String(error),
});

const generateLockId = (): string =>
  `lock_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;

/** Check whether a lock has expired based on its stored expiry timestamp. */
const isExpired = (record: Record<string, unknown>): boolean =>
  pipe(
    O.fromNullable(record['expires'] as string | null | undefined),
    O.fold(
      () => false, // No expiry means the lock lives until explicitly released
      (expiresStr) => new Date(expiresStr).getTime() <= Date.now(),
    ),
  );

/** Compute the expiry ISO string from now + duration in milliseconds. */
const computeExpiry = (durationMs: number): string =>
  new Date(Date.now() + durationMs).toISOString();

// --- Implementation ---

export const pessimisticLockHandler: PessimisticLockHandler = {
  checkOut: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          // Look for an existing active lock on this resource
          const existingLocks = await storage.find('locks', { resource: input.resource });
          const activeLock = existingLocks.find((lock) => !isExpired(lock));

          if (activeLock !== undefined) {
            const currentHolder = activeLock['holder'] as string;
            // Same holder re-acquiring is idempotent
            if (currentHolder === input.holder) {
              return checkOutOk(activeLock['lockId'] as string);
            }
            // Resource is held by someone else
            const expiresVal = activeLock['expires'] as string | null | undefined;
            const expiresOption = pipe(
              O.fromNullable(expiresVal),
            );

            // Add requester to wait queue
            const queueRecord = await storage.get('queue', input.resource);
            const currentQueue = pipe(
              O.fromNullable(queueRecord),
              O.chain((r) =>
                O.fromNullable(
                  r['waiters'] as readonly { requester: string; requested: string }[] | undefined,
                ),
              ),
              O.getOrElse((): readonly { readonly requester: string; readonly requested: string }[] => []),
            );
            const newWaiter = {
              requester: input.holder,
              requested: new Date().toISOString(),
            };
            const updatedQueue = [...currentQueue, newWaiter];
            await storage.put('queue', input.resource, {
              resource: input.resource,
              waiters: updatedQueue,
            });

            return checkOutAlreadyLocked(currentHolder, expiresOption);
          }

          // Clean up expired locks for this resource
          for (const lock of existingLocks) {
            if (isExpired(lock)) {
              await storage.delete('locks', lock['lockId'] as string);
            }
          }

          // Grant the lock
          const lockId = generateLockId();
          const now = new Date().toISOString();
          const expiresStr = pipe(
            input.duration,
            O.fold(
              () => null,
              (durationMs) => computeExpiry(durationMs),
            ),
          );
          const reasonStr = pipe(
            input.reason,
            O.toNullable,
          );

          await storage.put('locks', lockId, {
            lockId,
            resource: input.resource,
            holder: input.holder,
            acquired: now,
            expires: expiresStr,
            reason: reasonStr,
          });

          return checkOutOk(lockId);
        },
        storageError,
      ),
    ),

  checkIn: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const lockRecord = await storage.get('locks', input.lockId);
          return pipe(
            O.fromNullable(lockRecord),
            O.fold(
              async () => checkInNotFound(`Lock "${input.lockId}" not found`),
              async (record) => {
                // Release the lock
                await storage.delete('locks', input.lockId);

                // Promote the next waiter in queue for this resource
                const resource = record['resource'] as string;
                const queueRecord = await storage.get('queue', resource);
                if (queueRecord !== null) {
                  const waiters = (queueRecord['waiters'] as readonly { requester: string; requested: string }[]) ?? [];
                  if (waiters.length > 0) {
                    const [nextWaiter, ...remaining] = waiters;
                    // Auto-grant lock to next waiter
                    const newLockId = generateLockId();
                    await storage.put('locks', newLockId, {
                      lockId: newLockId,
                      resource,
                      holder: nextWaiter.requester,
                      acquired: new Date().toISOString(),
                      expires: null,
                      reason: null,
                    });
                    await storage.put('queue', resource, {
                      resource,
                      waiters: remaining,
                    });
                  }
                }

                return checkInOk();
              },
            ),
          );
        },
        storageError,
      ),
      TE.flatten,
    ),

  breakLock: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const lockRecord = await storage.get('locks', input.lockId);
          return pipe(
            O.fromNullable(lockRecord),
            O.fold(
              async () => breakLockNotFound(`Lock "${input.lockId}" not found`),
              async (record) => {
                const previousHolder = record['holder'] as string;
                // Record the forced break with reason
                await storage.put('break_log', `${input.lockId}_${Date.now()}`, {
                  lockId: input.lockId,
                  breaker: input.breaker,
                  reason: input.reason,
                  previousHolder,
                  brokenAt: new Date().toISOString(),
                });
                // Remove the lock
                await storage.delete('locks', input.lockId);
                return breakLockOk(previousHolder);
              },
            ),
          );
        },
        storageError,
      ),
      TE.flatten,
    ),

  renew: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const lockRecord = await storage.get('locks', input.lockId);
          return pipe(
            O.fromNullable(lockRecord),
            O.fold(
              async () => renewNotFound(`Lock "${input.lockId}" not found`),
              async (record) => {
                // Extend from the current expiry (or from now if no expiry set)
                const currentExpires = record['expires'] as string | null;
                const baseTime = currentExpires !== null
                  ? new Date(currentExpires).getTime()
                  : Date.now();
                const newExpires = new Date(
                  baseTime + input.additionalDuration,
                ).toISOString();

                await storage.put('locks', input.lockId, {
                  ...record,
                  expires: newExpires,
                });

                return renewOk(newExpires);
              },
            ),
          );
        },
        storageError,
      ),
      TE.flatten,
    ),

  queryLocks: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const resourceFilter = pipe(input.resource, O.toNullable);
          const filter = resourceFilter !== null
            ? { resource: resourceFilter }
            : undefined;
          const allLocks = await storage.find('locks', filter);
          // Filter out expired locks and return active lock IDs
          const activeLockIds = allLocks
            .filter((lock) => !isExpired(lock))
            .map((lock) => lock['lockId'] as string);
          return queryLocksOk(activeLockIds);
        },
        storageError,
      ),
    ),

  queryQueue: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const queueRecord = await storage.get('queue', input.resource);
          const waiters = pipe(
            O.fromNullable(queueRecord),
            O.chain((r) =>
              O.fromNullable(
                r['waiters'] as readonly { readonly requester: string; readonly requested: string }[] | undefined,
              ),
            ),
            O.getOrElse((): readonly { readonly requester: string; readonly requested: string }[] => []),
          );
          return queryQueueOk(waiters);
        },
        storageError,
      ),
    ),
};
