// RuntimeCoverage â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

// Storage interface for RuntimeCoverage
export interface RuntimeCoverageStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface RuntimeCoverageRecordInput {
  readonly symbol: string;
  readonly kind: string;
  readonly flowId: string;
}

export interface RuntimeCoverageRecordOutputOk {
  readonly variant: 'ok';
  readonly entry: string;
}

export interface RuntimeCoverageRecordOutputCreated {
  readonly variant: 'created';
  readonly entry: string;
}

export type RuntimeCoverageRecordOutput = RuntimeCoverageRecordOutputOk | RuntimeCoverageRecordOutputCreated;

export interface RuntimeCoverageCoverageReportInput {
  readonly kind: string;
  readonly since: string;
}

export interface RuntimeCoverageCoverageReportOutput {
  readonly variant: 'ok';
  readonly report: string;
}

export interface RuntimeCoverageVariantCoverageInput {
  readonly concept: string;
}

export interface RuntimeCoverageVariantCoverageOutput {
  readonly variant: 'ok';
  readonly report: string;
}

export interface RuntimeCoverageSyncCoverageInput {
  readonly since: string;
}

export interface RuntimeCoverageSyncCoverageOutput {
  readonly variant: 'ok';
  readonly report: string;
}

export interface RuntimeCoverageWidgetStateCoverageInput {
  readonly widget: string;
}

export interface RuntimeCoverageWidgetStateCoverageOutput {
  readonly variant: 'ok';
  readonly report: string;
}

export interface RuntimeCoverageWidgetLifecycleReportInput {
  readonly widget: string;
  readonly since: string;
}

export interface RuntimeCoverageWidgetLifecycleReportOutput {
  readonly variant: 'ok';
  readonly report: string;
}

export interface RuntimeCoverageWidgetRenderTraceInput {
  readonly widgetInstance: string;
}

export interface RuntimeCoverageWidgetRenderTraceOutputOk {
  readonly variant: 'ok';
  readonly renders: string;
}

export interface RuntimeCoverageWidgetRenderTraceOutputNotfound {
  readonly variant: 'notfound';
}

export type RuntimeCoverageWidgetRenderTraceOutput = RuntimeCoverageWidgetRenderTraceOutputOk | RuntimeCoverageWidgetRenderTraceOutputNotfound;

export interface RuntimeCoverageWidgetComparisonInput {
  readonly since: string;
  readonly topN: number;
}

export interface RuntimeCoverageWidgetComparisonOutput {
  readonly variant: 'ok';
  readonly ranking: string;
}

export interface RuntimeCoverageDeadAtRuntimeInput {
  readonly kind: string;
}

export interface RuntimeCoverageDeadAtRuntimeOutput {
  readonly variant: 'ok';
  readonly neverExercised: string;
}

// --- Variant constructors ---

export const recordOk = (entry: string): RuntimeCoverageRecordOutput => ({ variant: 'ok', entry } as RuntimeCoverageRecordOutput);
export const recordCreated = (entry: string): RuntimeCoverageRecordOutput => ({ variant: 'created', entry } as RuntimeCoverageRecordOutput);

export const coverageReportOk = (report: string): RuntimeCoverageCoverageReportOutput => ({ variant: 'ok', report } as RuntimeCoverageCoverageReportOutput);

export const variantCoverageOk = (report: string): RuntimeCoverageVariantCoverageOutput => ({ variant: 'ok', report } as RuntimeCoverageVariantCoverageOutput);

export const syncCoverageOk = (report: string): RuntimeCoverageSyncCoverageOutput => ({ variant: 'ok', report } as RuntimeCoverageSyncCoverageOutput);

export const widgetStateCoverageOk = (report: string): RuntimeCoverageWidgetStateCoverageOutput => ({ variant: 'ok', report } as RuntimeCoverageWidgetStateCoverageOutput);

export const widgetLifecycleReportOk = (report: string): RuntimeCoverageWidgetLifecycleReportOutput => ({ variant: 'ok', report } as RuntimeCoverageWidgetLifecycleReportOutput);

export const widgetRenderTraceOk = (renders: string): RuntimeCoverageWidgetRenderTraceOutput => ({ variant: 'ok', renders } as RuntimeCoverageWidgetRenderTraceOutput);
export const widgetRenderTraceNotfound = (): RuntimeCoverageWidgetRenderTraceOutput => ({ variant: 'notfound' } as RuntimeCoverageWidgetRenderTraceOutput);

export const widgetComparisonOk = (ranking: string): RuntimeCoverageWidgetComparisonOutput => ({ variant: 'ok', ranking } as RuntimeCoverageWidgetComparisonOutput);

export const deadAtRuntimeOk = (neverExercised: string): RuntimeCoverageDeadAtRuntimeOutput => ({ variant: 'ok', neverExercised } as RuntimeCoverageDeadAtRuntimeOutput);

