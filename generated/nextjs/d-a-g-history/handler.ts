// DAGHistory â€” handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  DAGHistoryStorage,
  DAGHistoryAppendInput,
  DAGHistoryAppendOutput,
  DAGHistoryAncestorsInput,
  DAGHistoryAncestorsOutput,
  DAGHistoryCommonAncestorInput,
  DAGHistoryCommonAncestorOutput,
  DAGHistoryDescendantsInput,
  DAGHistoryDescendantsOutput,
  DAGHistoryBetweenInput,
  DAGHistoryBetweenOutput,
  DAGHistoryGetNodeInput,
  DAGHistoryGetNodeOutput,
} from './types.js';

import {
  appendOk,
  appendUnknownParent,
  ancestorsOk,
  ancestorsNotFound,
  commonAncestorFound,
  commonAncestorNone,
  commonAncestorNotFound,
  descendantsOk,
  descendantsNotFound,
  betweenOk,
  betweenNoPath,
  betweenNotFound,
  getNodeOk,
  getNodeNotFound,
} from './types.js';

export interface DAGHistoryError {
  readonly code: string;
  readonly message: string;
}

export interface DAGHistoryHandler {
  readonly append: (
    input: DAGHistoryAppendInput,
    storage: DAGHistoryStorage,
  ) => TE.TaskEither<DAGHistoryError, DAGHistoryAppendOutput>;
  readonly ancestors: (
    input: DAGHistoryAncestorsInput,
    storage: DAGHistoryStorage,
  ) => TE.TaskEither<DAGHistoryError, DAGHistoryAncestorsOutput>;
  readonly commonAncestor: (
    input: DAGHistoryCommonAncestorInput,
    storage: DAGHistoryStorage,
  ) => TE.TaskEither<DAGHistoryError, DAGHistoryCommonAncestorOutput>;
  readonly descendants: (
    input: DAGHistoryDescendantsInput,
    storage: DAGHistoryStorage,
  ) => TE.TaskEither<DAGHistoryError, DAGHistoryDescendantsOutput>;
  readonly between: (
    input: DAGHistoryBetweenInput,
    storage: DAGHistoryStorage,
  ) => TE.TaskEither<DAGHistoryError, DAGHistoryBetweenOutput>;
  readonly getNode: (
    input: DAGHistoryGetNodeInput,
    storage: DAGHistoryStorage,
  ) => TE.TaskEither<DAGHistoryError, DAGHistoryGetNodeOutput>;
}

// --- Internal DAG representation ---

interface DagNode {
  readonly id: string;
  readonly parents: readonly string[];
  readonly contentRef: string;
  readonly metadata: string;
  readonly created: string;
}

const makeStorageError = (error: unknown): DAGHistoryError => ({
  code: 'STORAGE_ERROR',
  message: error instanceof Error ? error.message : String(error),
});

const generateId = (): string =>
  `dag-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;

const loadAllNodes = (
  storage: DAGHistoryStorage,
): TE.TaskEither<DAGHistoryError, readonly DagNode[]> =>
  TE.tryCatch(
    async () => {
      const records = await storage.find('dag_nodes');
      return records.map((r) => ({
        id: String(r['id'] ?? ''),
        parents: Array.isArray(r['parents']) ? (r['parents'] as readonly string[]) : [],
        contentRef: String(r['contentRef'] ?? ''),
        metadata: String(r['metadata'] ?? ''),
        created: String(r['created'] ?? ''),
      }));
    },
    makeStorageError,
  );

const loadNode = (
  storage: DAGHistoryStorage,
  nodeId: string,
): TE.TaskEither<DAGHistoryError, O.Option<DagNode>> =>
  TE.tryCatch(
    async () => {
      const record = await storage.get('dag_nodes', nodeId);
      return pipe(
        O.fromNullable(record),
        O.map((r) => ({
          id: String(r['id'] ?? ''),
          parents: Array.isArray(r['parents']) ? (r['parents'] as readonly string[]) : [],
          contentRef: String(r['contentRef'] ?? ''),
          metadata: String(r['metadata'] ?? ''),
          created: String(r['created'] ?? ''),
        })),
      );
    },
    makeStorageError,
  );

// Build adjacency maps for traversal from a flat list of nodes
const buildAdjacency = (
  nodes: readonly DagNode[],
): {
  readonly parentMap: ReadonlyMap<string, readonly string[]>;
  readonly childMap: ReadonlyMap<string, readonly string[]>;
  readonly nodeSet: ReadonlySet<string>;
} => {
  const parentMap = new Map<string, readonly string[]>();
  const childMap = new Map<string, string[]>();
  const nodeSet = new Set<string>();

  for (const node of nodes) {
    nodeSet.add(node.id);
    parentMap.set(node.id, node.parents);
    for (const p of node.parents) {
      const existing = childMap.get(p) ?? [];
      childMap.set(p, [...existing, node.id]);
    }
  }

  return { parentMap, childMap, nodeSet };
};

// BFS traversal up parent edges, returning topologically ordered ancestors
const bfsAncestors = (
  startId: string,
  parentMap: ReadonlyMap<string, readonly string[]>,
): readonly string[] => {
  const visited = new Set<string>();
  const queue: string[] = [...(parentMap.get(startId) ?? [])];
  const result: string[] = [];

  while (queue.length > 0) {
    const current = queue.shift()!;
    if (visited.has(current)) continue;
    visited.add(current);
    result.push(current);
    for (const parent of parentMap.get(current) ?? []) {
      if (!visited.has(parent)) {
        queue.push(parent);
      }
    }
  }

  return result;
};

// BFS traversal down child edges
const bfsDescendants = (
  startId: string,
  childMap: ReadonlyMap<string, readonly string[]>,
): readonly string[] => {
  const visited = new Set<string>();
  const queue: string[] = [...(childMap.get(startId) ?? [])];
  const result: string[] = [];

  while (queue.length > 0) {
    const current = queue.shift()!;
    if (visited.has(current)) continue;
    visited.add(current);
    result.push(current);
    for (const child of childMap.get(current) ?? []) {
      if (!visited.has(child)) {
        queue.push(child);
      }
    }
  }

  return result;
};

// Find lowest common ancestor using BFS ancestor-set intersection
const findLCA = (
  a: string,
  b: string,
  parentMap: ReadonlyMap<string, readonly string[]>,
): O.Option<string> => {
  const ancestorsA = new Set<string>([a, ...bfsAncestors(a, parentMap)]);
  const ancestorsB = new Set<string>([b, ...bfsAncestors(b, parentMap)]);

  // BFS from b looking for first node also in ancestorsA (nearest common ancestor)
  if (ancestorsA.has(b)) return O.some(b);
  if (ancestorsB.has(a)) return O.some(a);

  const queue: string[] = [...(parentMap.get(b) ?? [])];
  const visited = new Set<string>();

  while (queue.length > 0) {
    const current = queue.shift()!;
    if (visited.has(current)) continue;
    visited.add(current);
    if (ancestorsA.has(current)) return O.some(current);
    for (const parent of parentMap.get(current) ?? []) {
      if (!visited.has(parent)) {
        queue.push(parent);
      }
    }
  }

  return O.none;
};

// Find all nodes on any path between ancestor (from) and descendant (to)
// using DFS from 'from' towards 'to' through child edges
const findBetween = (
  from: string,
  to: string,
  childMap: ReadonlyMap<string, readonly string[]>,
): O.Option<readonly string[]> => {
  // DFS collecting all nodes on any path from -> to
  const onPath = new Set<string>();

  const dfs = (current: string, path: readonly string[]): boolean => {
    if (current === to) {
      for (const node of path) onPath.add(node);
      onPath.add(to);
      return true;
    }

    let found = false;
    for (const child of childMap.get(current) ?? []) {
      if (!path.includes(child)) {
        if (dfs(child, [...path, child])) {
          found = true;
        }
      }
    }
    return found;
  };

  const found = dfs(from, [from]);
  if (!found) return O.none;

  // Topological order among the between-set
  const result: string[] = [];
  const visited = new Set<string>();
  const topoVisit = (node: string): void => {
    if (visited.has(node) || !onPath.has(node)) return;
    visited.add(node);
    for (const child of childMap.get(node) ?? []) {
      if (onPath.has(child)) topoVisit(child);
    }
    result.unshift(node);
  };

  // Start topological sort from the 'from' node
  topoVisit(from);
  for (const n of onPath) {
    if (!visited.has(n)) topoVisit(n);
  }

  return O.some(result);
};

// --- Implementation ---

export const dAGHistoryHandler: DAGHistoryHandler = {
  append: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const parentIds = Array.from(input.parents);

          // Verify all parents exist
          for (const parentId of parentIds) {
            const parentRecord = await storage.get('dag_nodes', parentId);
            if (parentRecord === null) {
              return appendUnknownParent(`Parent node '${parentId}' not found in DAG`);
            }
          }

          const nodeId = generateId();
          const now = new Date().toISOString();

          await storage.put('dag_nodes', nodeId, {
            id: nodeId,
            parents: parentIds,
            contentRef: input.contentRef,
            metadata: input.metadata.toString('base64'),
            created: now,
          });

          return appendOk(nodeId);
        },
        makeStorageError,
      ),
    ),

  ancestors: (input, storage) =>
    pipe(
      loadNode(storage, input.nodeId),
      TE.chain((optNode) =>
        pipe(
          optNode,
          O.fold(
            () => TE.right<DAGHistoryError, DAGHistoryAncestorsOutput>(
              ancestorsNotFound(`Node '${input.nodeId}' not found in DAG`),
            ),
            () =>
              pipe(
                loadAllNodes(storage),
                TE.map((allNodes) => {
                  const { parentMap } = buildAdjacency(allNodes);
                  const result = bfsAncestors(input.nodeId, parentMap);
                  return ancestorsOk(result);
                }),
              ),
          ),
        ),
      ),
    ),

  commonAncestor: (input, storage) =>
    pipe(
      loadAllNodes(storage),
      TE.chain((allNodes) => {
        const { parentMap, nodeSet } = buildAdjacency(allNodes);

        if (!nodeSet.has(input.a) || !nodeSet.has(input.b)) {
          const missing = !nodeSet.has(input.a) ? input.a : input.b;
          return TE.right<DAGHistoryError, DAGHistoryCommonAncestorOutput>(
            commonAncestorNotFound(`Node '${missing}' not found in DAG`),
          );
        }

        return pipe(
          findLCA(input.a, input.b, parentMap),
          O.fold(
            () => TE.right<DAGHistoryError, DAGHistoryCommonAncestorOutput>(
              commonAncestorNone('No common ancestor exists between the given nodes'),
            ),
            (lcaId) => TE.right<DAGHistoryError, DAGHistoryCommonAncestorOutput>(
              commonAncestorFound(lcaId),
            ),
          ),
        );
      }),
    ),

  descendants: (input, storage) =>
    pipe(
      loadNode(storage, input.nodeId),
      TE.chain((optNode) =>
        pipe(
          optNode,
          O.fold(
            () => TE.right<DAGHistoryError, DAGHistoryDescendantsOutput>(
              descendantsNotFound(`Node '${input.nodeId}' not found in DAG`),
            ),
            () =>
              pipe(
                loadAllNodes(storage),
                TE.map((allNodes) => {
                  const { childMap } = buildAdjacency(allNodes);
                  const result = bfsDescendants(input.nodeId, childMap);
                  return descendantsOk(result);
                }),
              ),
          ),
        ),
      ),
    ),

  between: (input, storage) =>
    pipe(
      loadAllNodes(storage),
      TE.chain((allNodes) => {
        const { childMap, nodeSet } = buildAdjacency(allNodes);

        if (!nodeSet.has(input.from) || !nodeSet.has(input.to)) {
          const missing = !nodeSet.has(input.from) ? input.from : input.to;
          return TE.right<DAGHistoryError, DAGHistoryBetweenOutput>(
            betweenNotFound(`Node '${missing}' not found in DAG`),
          );
        }

        return pipe(
          findBetween(input.from, input.to, childMap),
          O.fold(
            () => TE.right<DAGHistoryError, DAGHistoryBetweenOutput>(
              betweenNoPath(`No directed path from '${input.from}' to '${input.to}'`),
            ),
            (path) => TE.right<DAGHistoryError, DAGHistoryBetweenOutput>(
              betweenOk(path),
            ),
          ),
        );
      }),
    ),

  getNode: (input, storage) =>
    pipe(
      loadNode(storage, input.nodeId),
      TE.chain((optNode) =>
        pipe(
          optNode,
          O.fold(
            () => TE.right<DAGHistoryError, DAGHistoryGetNodeOutput>(
              getNodeNotFound(`Node '${input.nodeId}' not found in DAG`),
            ),
            (node) =>
              TE.right<DAGHistoryError, DAGHistoryGetNodeOutput>(
                getNodeOk(
                  new Set(node.parents),
                  node.contentRef,
                  Buffer.from(node.metadata, 'base64'),
                ),
              ),
          ),
        ),
      ),
    ),
};
