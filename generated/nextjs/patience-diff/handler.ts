// PatienceDiff â€” handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.
//
// Implements the Patience Diff algorithm:
// 1. Find unique lines common to both sequences
// 2. Compute the Longest Increasing Subsequence (LIS) of their positions
// 3. Use the LIS as anchors, then recursively diff the gaps between anchors
// Produces more human-readable diffs than Myers for refactored/moved code.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  PatienceDiffStorage,
  PatienceDiffRegisterInput,
  PatienceDiffRegisterOutput,
  PatienceDiffComputeInput,
  PatienceDiffComputeOutput,
} from './types.js';

import {
  registerOk,
  computeOk,
  computeUnsupportedContent,
} from './types.js';

export interface PatienceDiffError {
  readonly code: string;
  readonly message: string;
}

export interface PatienceDiffHandler {
  readonly register: (
    input: PatienceDiffRegisterInput,
    storage: PatienceDiffStorage,
  ) => TE.TaskEither<PatienceDiffError, PatienceDiffRegisterOutput>;
  readonly compute: (
    input: PatienceDiffComputeInput,
    storage: PatienceDiffStorage,
  ) => TE.TaskEither<PatienceDiffError, PatienceDiffComputeOutput>;
}

// --- Edit operation types ---

type EditOp =
  | { readonly type: 'keep'; readonly line: string }
  | { readonly type: 'insert'; readonly line: string }
  | { readonly type: 'delete'; readonly line: string };

// --- Pure helper functions ---

const splitLines = (buf: Buffer): readonly string[] =>
  buf.toString('utf-8').split('\n');

const serializeEditScript = (ops: readonly EditOp[]): Buffer =>
  Buffer.from(
    JSON.stringify(ops.map(op => ({ t: op.type[0], l: op.line }))),
    'utf-8',
  );

const countDistance = (ops: readonly EditOp[]): number =>
  ops.reduce((acc, op) => acc + (op.type === 'keep' ? 0 : 1), 0);

/**
 * Build a frequency map: line -> count for a slice of lines.
 */
const buildFrequencyMap = (
  lines: readonly string[],
  lo: number,
  hi: number,
): ReadonlyMap<string, number> => {
  const map = new Map<string, number>();
  for (let i = lo; i < hi; i++) {
    const line = lines[i];
    map.set(line, (map.get(line) ?? 0) + 1);
  }
  return map;
};

/**
 * Find unique lines in a slice and return their indices.
 * A line is "unique" if it appears exactly once in the slice.
 */
const uniqueLineIndices = (
  lines: readonly string[],
  lo: number,
  hi: number,
): ReadonlyMap<string, number> => {
  const freq = buildFrequencyMap(lines, lo, hi);
  const result = new Map<string, number>();
  for (let i = lo; i < hi; i++) {
    const line = lines[i];
    if (freq.get(line) === 1) {
      result.set(line, i);
    }
  }
  return result;
};

/**
 * Compute Longest Increasing Subsequence using patience sorting.
 * Input: array of numbers (positions in B for each matched unique line).
 * Returns the indices (into the input array) that form the LIS.
 */
const longestIncreasingSubsequence = (
  values: readonly number[],
): readonly number[] => {
  if (values.length === 0) return [];

  // Piles for patience sorting: each pile stores the index into values
  const piles: number[] = [];
  // For each element, record which pile-top it replaced and the predecessor
  const predecessors: number[] = new Array(values.length).fill(-1);
  const pileIndices: number[] = []; // index into values for each pile top

  for (let i = 0; i < values.length; i++) {
    const val = values[i];

    // Binary search for the leftmost pile whose top value >= val
    let lo = 0;
    let hi = piles.length;
    while (lo < hi) {
      const mid = (lo + hi) >>> 1;
      if (piles[mid] < val) {
        lo = mid + 1;
      } else {
        hi = mid;
      }
    }

    piles[lo] = val;
    pileIndices[lo] = i;

    if (lo > 0) {
      predecessors[i] = pileIndices[lo - 1];
    }
  }

  // Reconstruct the LIS from predecessors
  const result: number[] = new Array(piles.length);
  let idx = pileIndices[piles.length - 1];
  for (let i = piles.length - 1; i >= 0; i--) {
    result[i] = idx;
    idx = predecessors[idx];
  }

  return result;
};

/**
 * Core patience diff: recursively diff between anchor points.
 * aLo/aHi and bLo/bHi define the slices of a and b to diff.
 */
const patienceDiffRec = (
  a: readonly string[],
  aLo: number,
  aHi: number,
  b: readonly string[],
  bLo: number,
  bHi: number,
): readonly EditOp[] => {
  // Base case: one or both slices are empty
  if (aLo === aHi && bLo === bHi) return [];
  if (aLo === aHi) {
    // All remaining B lines are inserts
    const ops: EditOp[] = [];
    for (let j = bLo; j < bHi; j++) {
      ops.push({ type: 'insert', line: b[j] });
    }
    return ops;
  }
  if (bLo === bHi) {
    // All remaining A lines are deletes
    const ops: EditOp[] = [];
    for (let i = aLo; i < aHi; i++) {
      ops.push({ type: 'delete', line: a[i] });
    }
    return ops;
  }

  // Find unique lines in both slices
  const uniqueA = uniqueLineIndices(a, aLo, aHi);
  const uniqueB = uniqueLineIndices(b, bLo, bHi);

  // Find common unique lines (appearing exactly once in both slices)
  // Build matched pairs: { aIdx, bIdx } ordered by aIdx
  const matchedPairs: { readonly aIdx: number; readonly bIdx: number }[] = [];
  for (const [line, aIdx] of uniqueA) {
    const bIdx = uniqueB.get(line);
    if (bIdx !== undefined) {
      matchedPairs.push({ aIdx, bIdx });
    }
  }
  matchedPairs.sort((x, y) => x.aIdx - y.aIdx);

  if (matchedPairs.length === 0) {
    // No unique common lines: fall back to simple LCS-style diff
    return fallbackDiff(a, aLo, aHi, b, bLo, bHi);
  }

  // Compute LIS on the bIdx values (patience sorting)
  const bPositions = matchedPairs.map(p => p.bIdx);
  const lisIndices = longestIncreasingSubsequence(bPositions);
  const anchors = lisIndices.map(i => matchedPairs[i]);

  // Recursively diff between anchor points
  const ops: EditOp[] = [];
  let curA = aLo;
  let curB = bLo;

  for (const anchor of anchors) {
    // Diff the gap before this anchor
    ops.push(...patienceDiffRec(a, curA, anchor.aIdx, b, curB, anchor.bIdx));
    // The anchor itself is a keep
    ops.push({ type: 'keep', line: a[anchor.aIdx] });
    curA = anchor.aIdx + 1;
    curB = anchor.bIdx + 1;
  }

  // Diff the tail after the last anchor
  ops.push(...patienceDiffRec(a, curA, aHi, b, curB, bHi));

  return ops;
};

/**
 * Fallback diff when no unique common lines exist.
 * Uses a simple LCS dynamic programming approach for small slices.
 */
const fallbackDiff = (
  a: readonly string[],
  aLo: number,
  aHi: number,
  b: readonly string[],
  bLo: number,
  bHi: number,
): readonly EditOp[] => {
  const n = aHi - aLo;
  const m = bHi - bLo;

  // Build LCS table
  const dp: number[][] = Array.from({ length: n + 1 }, () =>
    new Array<number>(m + 1).fill(0),
  );

  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= m; j++) {
      if (a[aLo + i - 1] === b[bLo + j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  // Backtrack to produce edit operations
  const ops: EditOp[] = [];
  let i = n;
  let j = m;

  while (i > 0 || j > 0) {
    if (i > 0 && j > 0 && a[aLo + i - 1] === b[bLo + j - 1]) {
      ops.push({ type: 'keep', line: a[aLo + i - 1] });
      i--;
      j--;
    } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
      ops.push({ type: 'insert', line: b[bLo + j - 1] });
      j--;
    } else {
      ops.push({ type: 'delete', line: a[aLo + i - 1] });
      i--;
    }
  }

  ops.reverse();
  return ops;
};

// --- Implementation ---

export const patienceDiffHandler: PatienceDiffHandler = {
  register: (_input, _storage) =>
    TE.right(
      registerOk('patience', 'diff', ['text/plain', 'text/*']),
    ),

  compute: (input, _storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const linesA = splitLines(input.contentA);
          const linesB = splitLines(input.contentB);
          return { linesA, linesB };
        },
        (error): PatienceDiffError => ({
          code: 'DECODE_ERROR',
          message: `Failed to decode input buffers: ${error instanceof Error ? error.message : String(error)}`,
        }),
      ),
      TE.map(({ linesA, linesB }) => {
        const ops = patienceDiffRec(linesA, 0, linesA.length, linesB, 0, linesB.length);
        const distance = countDistance(ops);
        return computeOk(serializeEditScript(ops), distance);
      }),
    ),
};
