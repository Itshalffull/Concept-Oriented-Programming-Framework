// SymbolRelationship â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

// Storage interface for SymbolRelationship
export interface SymbolRelationshipStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface SymbolRelationshipAddInput {
  readonly source: string;
  readonly target: string;
  readonly kind: string;
}

export interface SymbolRelationshipAddOutputOk {
  readonly variant: 'ok';
  readonly relationship: string;
}

export interface SymbolRelationshipAddOutputAlreadyExists {
  readonly variant: 'alreadyExists';
  readonly existing: string;
}

export type SymbolRelationshipAddOutput = SymbolRelationshipAddOutputOk | SymbolRelationshipAddOutputAlreadyExists;

export interface SymbolRelationshipFindFromInput {
  readonly source: string;
  readonly kind: string;
}

export interface SymbolRelationshipFindFromOutput {
  readonly variant: 'ok';
  readonly relationships: string;
}

export interface SymbolRelationshipFindToInput {
  readonly target: string;
  readonly kind: string;
}

export interface SymbolRelationshipFindToOutput {
  readonly variant: 'ok';
  readonly relationships: string;
}

export interface SymbolRelationshipTransitiveClosureInput {
  readonly start: string;
  readonly kind: string;
  readonly direction: string;
}

export interface SymbolRelationshipTransitiveClosureOutput {
  readonly variant: 'ok';
  readonly symbols: string;
  readonly paths: string;
}

export interface SymbolRelationshipGetInput {
  readonly relationship: string;
}

export interface SymbolRelationshipGetOutputOk {
  readonly variant: 'ok';
  readonly relationship: string;
  readonly source: string;
  readonly target: string;
  readonly kind: string;
  readonly metadata: string;
}

export interface SymbolRelationshipGetOutputNotfound {
  readonly variant: 'notfound';
}

export type SymbolRelationshipGetOutput = SymbolRelationshipGetOutputOk | SymbolRelationshipGetOutputNotfound;

// --- Variant constructors ---

export const addOk = (relationship: string): SymbolRelationshipAddOutput => ({ variant: 'ok', relationship } as SymbolRelationshipAddOutput);
export const addAlreadyExists = (existing: string): SymbolRelationshipAddOutput => ({ variant: 'alreadyExists', existing } as SymbolRelationshipAddOutput);

export const findFromOk = (relationships: string): SymbolRelationshipFindFromOutput => ({ variant: 'ok', relationships } as SymbolRelationshipFindFromOutput);

export const findToOk = (relationships: string): SymbolRelationshipFindToOutput => ({ variant: 'ok', relationships } as SymbolRelationshipFindToOutput);

export const transitiveClosureOk = (symbols: string, paths: string): SymbolRelationshipTransitiveClosureOutput => ({ variant: 'ok', symbols, paths } as SymbolRelationshipTransitiveClosureOutput);

export const getOk = (relationship: string, source: string, target: string, kind: string, metadata: string): SymbolRelationshipGetOutput => ({ variant: 'ok', relationship, source, target, kind, metadata } as SymbolRelationshipGetOutput);
export const getNotfound = (): SymbolRelationshipGetOutput => ({ variant: 'notfound' } as SymbolRelationshipGetOutput);

