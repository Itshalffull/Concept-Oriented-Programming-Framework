// SyntaxTree â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

// Storage interface for SyntaxTree
export interface SyntaxTreeStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface SyntaxTreeParseInput {
  readonly file: string;
  readonly grammar: string;
}

export interface SyntaxTreeParseOutputOk {
  readonly variant: 'ok';
  readonly tree: string;
}

export interface SyntaxTreeParseOutputParseError {
  readonly variant: 'parseError';
  readonly tree: string;
  readonly errorCount: number;
}

export interface SyntaxTreeParseOutputNoGrammar {
  readonly variant: 'noGrammar';
  readonly message: string;
}

export type SyntaxTreeParseOutput = SyntaxTreeParseOutputOk | SyntaxTreeParseOutputParseError | SyntaxTreeParseOutputNoGrammar;

export interface SyntaxTreeReparseInput {
  readonly tree: string;
  readonly startByte: number;
  readonly oldEndByte: number;
  readonly newEndByte: number;
  readonly newText: string;
}

export interface SyntaxTreeReparseOutputOk {
  readonly variant: 'ok';
  readonly tree: string;
}

export interface SyntaxTreeReparseOutputNotfound {
  readonly variant: 'notfound';
  readonly message: string;
}

export type SyntaxTreeReparseOutput = SyntaxTreeReparseOutputOk | SyntaxTreeReparseOutputNotfound;

export interface SyntaxTreeQueryInput {
  readonly tree: string;
  readonly pattern: string;
}

export interface SyntaxTreeQueryOutputOk {
  readonly variant: 'ok';
  readonly matches: string;
}

export interface SyntaxTreeQueryOutputInvalidPattern {
  readonly variant: 'invalidPattern';
  readonly message: string;
}

export interface SyntaxTreeQueryOutputNotfound {
  readonly variant: 'notfound';
  readonly message: string;
}

export type SyntaxTreeQueryOutput = SyntaxTreeQueryOutputOk | SyntaxTreeQueryOutputInvalidPattern | SyntaxTreeQueryOutputNotfound;

export interface SyntaxTreeNodeAtInput {
  readonly tree: string;
  readonly byteOffset: number;
}

export interface SyntaxTreeNodeAtOutputOk {
  readonly variant: 'ok';
  readonly nodeType: string;
  readonly startByte: number;
  readonly endByte: number;
  readonly named: string;
  readonly field: string;
}

export interface SyntaxTreeNodeAtOutputOutOfRange {
  readonly variant: 'outOfRange';
}

export interface SyntaxTreeNodeAtOutputNotfound {
  readonly variant: 'notfound';
  readonly message: string;
}

export type SyntaxTreeNodeAtOutput = SyntaxTreeNodeAtOutputOk | SyntaxTreeNodeAtOutputOutOfRange | SyntaxTreeNodeAtOutputNotfound;

export interface SyntaxTreeGetInput {
  readonly tree: string;
}

export interface SyntaxTreeGetOutputOk {
  readonly variant: 'ok';
  readonly tree: string;
  readonly source: string;
  readonly grammar: string;
  readonly byteLength: number;
  readonly editVersion: number;
  readonly errorRanges: string;
}

export interface SyntaxTreeGetOutputNotfound {
  readonly variant: 'notfound';
  readonly message: string;
}

export type SyntaxTreeGetOutput = SyntaxTreeGetOutputOk | SyntaxTreeGetOutputNotfound;

// --- Variant constructors ---

export const parseOk = (tree: string): SyntaxTreeParseOutput => ({ variant: 'ok', tree } as SyntaxTreeParseOutput);
export const parseParseError = (tree: string, errorCount: number): SyntaxTreeParseOutput => ({ variant: 'parseError', tree, errorCount } as SyntaxTreeParseOutput);
export const parseNoGrammar = (message: string): SyntaxTreeParseOutput => ({ variant: 'noGrammar', message } as SyntaxTreeParseOutput);

export const reparseOk = (tree: string): SyntaxTreeReparseOutput => ({ variant: 'ok', tree } as SyntaxTreeReparseOutput);
export const reparseNotfound = (message: string): SyntaxTreeReparseOutput => ({ variant: 'notfound', message } as SyntaxTreeReparseOutput);

export const queryOk = (matches: string): SyntaxTreeQueryOutput => ({ variant: 'ok', matches } as SyntaxTreeQueryOutput);
export const queryInvalidPattern = (message: string): SyntaxTreeQueryOutput => ({ variant: 'invalidPattern', message } as SyntaxTreeQueryOutput);
export const queryNotfound = (message: string): SyntaxTreeQueryOutput => ({ variant: 'notfound', message } as SyntaxTreeQueryOutput);

export const nodeAtOk = (nodeType: string, startByte: number, endByte: number, named: string, field: string): SyntaxTreeNodeAtOutput => ({ variant: 'ok', nodeType, startByte, endByte, named, field } as SyntaxTreeNodeAtOutput);
export const nodeAtOutOfRange = (): SyntaxTreeNodeAtOutput => ({ variant: 'outOfRange' } as SyntaxTreeNodeAtOutput);
export const nodeAtNotfound = (message: string): SyntaxTreeNodeAtOutput => ({ variant: 'notfound', message } as SyntaxTreeNodeAtOutput);

export const getOk = (tree: string, source: string, grammar: string, byteLength: number, editVersion: number, errorRanges: string): SyntaxTreeGetOutput => ({ variant: 'ok', tree, source, grammar, byteLength, editVersion, errorRanges } as SyntaxTreeGetOutput);
export const getNotfound = (message: string): SyntaxTreeGetOutput => ({ variant: 'notfound', message } as SyntaxTreeGetOutput);

