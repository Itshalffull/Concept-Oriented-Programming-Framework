// DesignToken â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as O from 'fp-ts/Option';

// Storage interface for DesignToken
export interface DesignTokenStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface DesignTokenDefineInput {
  readonly token: string;
  readonly name: string;
  readonly value: string;
  readonly type: string;
  readonly tier: string;
}

export interface DesignTokenDefineOutputOk {
  readonly variant: 'ok';
  readonly token: string;
}

export interface DesignTokenDefineOutputDuplicate {
  readonly variant: 'duplicate';
  readonly message: string;
}

export type DesignTokenDefineOutput = DesignTokenDefineOutputOk | DesignTokenDefineOutputDuplicate;

export interface DesignTokenAliasInput {
  readonly token: string;
  readonly name: string;
  readonly reference: string;
  readonly tier: string;
}

export interface DesignTokenAliasOutputOk {
  readonly variant: 'ok';
  readonly token: string;
}

export interface DesignTokenAliasOutputNotfound {
  readonly variant: 'notfound';
  readonly message: string;
}

export interface DesignTokenAliasOutputCycle {
  readonly variant: 'cycle';
  readonly message: string;
}

export type DesignTokenAliasOutput = DesignTokenAliasOutputOk | DesignTokenAliasOutputNotfound | DesignTokenAliasOutputCycle;

export interface DesignTokenResolveInput {
  readonly token: string;
}

export interface DesignTokenResolveOutputOk {
  readonly variant: 'ok';
  readonly token: string;
  readonly resolvedValue: string;
}

export interface DesignTokenResolveOutputNotfound {
  readonly variant: 'notfound';
  readonly message: string;
}

export interface DesignTokenResolveOutputBroken {
  readonly variant: 'broken';
  readonly message: string;
  readonly brokenAt: string;
}

export type DesignTokenResolveOutput = DesignTokenResolveOutputOk | DesignTokenResolveOutputNotfound | DesignTokenResolveOutputBroken;

export interface DesignTokenUpdateInput {
  readonly token: string;
  readonly value: O.Option<string>;
}

export interface DesignTokenUpdateOutputOk {
  readonly variant: 'ok';
  readonly token: string;
}

export interface DesignTokenUpdateOutputNotfound {
  readonly variant: 'notfound';
  readonly message: string;
}

export type DesignTokenUpdateOutput = DesignTokenUpdateOutputOk | DesignTokenUpdateOutputNotfound;

export interface DesignTokenRemoveInput {
  readonly token: string;
}

export interface DesignTokenRemoveOutputOk {
  readonly variant: 'ok';
  readonly token: string;
}

export interface DesignTokenRemoveOutputNotfound {
  readonly variant: 'notfound';
  readonly message: string;
}

export type DesignTokenRemoveOutput = DesignTokenRemoveOutputOk | DesignTokenRemoveOutputNotfound;

export interface DesignTokenExportInput {
  readonly format: string;
}

export interface DesignTokenExportOutputOk {
  readonly variant: 'ok';
  readonly output: string;
}

export interface DesignTokenExportOutputUnsupported {
  readonly variant: 'unsupported';
  readonly message: string;
}

export type DesignTokenExportOutput = DesignTokenExportOutputOk | DesignTokenExportOutputUnsupported;

// --- Variant constructors ---

export const defineOk = (token: string): DesignTokenDefineOutput => ({ variant: 'ok', token } as DesignTokenDefineOutput);
export const defineDuplicate = (message: string): DesignTokenDefineOutput => ({ variant: 'duplicate', message } as DesignTokenDefineOutput);

export const aliasOk = (token: string): DesignTokenAliasOutput => ({ variant: 'ok', token } as DesignTokenAliasOutput);
export const aliasNotfound = (message: string): DesignTokenAliasOutput => ({ variant: 'notfound', message } as DesignTokenAliasOutput);
export const aliasCycle = (message: string): DesignTokenAliasOutput => ({ variant: 'cycle', message } as DesignTokenAliasOutput);

export const resolveOk = (token: string, resolvedValue: string): DesignTokenResolveOutput => ({ variant: 'ok', token, resolvedValue } as DesignTokenResolveOutput);
export const resolveNotfound = (message: string): DesignTokenResolveOutput => ({ variant: 'notfound', message } as DesignTokenResolveOutput);
export const resolveBroken = (message: string, brokenAt: string): DesignTokenResolveOutput => ({ variant: 'broken', message, brokenAt } as DesignTokenResolveOutput);

export const updateOk = (token: string): DesignTokenUpdateOutput => ({ variant: 'ok', token } as DesignTokenUpdateOutput);
export const updateNotfound = (message: string): DesignTokenUpdateOutput => ({ variant: 'notfound', message } as DesignTokenUpdateOutput);

export const removeOk = (token: string): DesignTokenRemoveOutput => ({ variant: 'ok', token } as DesignTokenRemoveOutput);
export const removeNotfound = (message: string): DesignTokenRemoveOutput => ({ variant: 'notfound', message } as DesignTokenRemoveOutput);

export const exportOk = (output: string): DesignTokenExportOutput => ({ variant: 'ok', output } as DesignTokenExportOutput);
export const exportUnsupported = (message: string): DesignTokenExportOutput => ({ variant: 'unsupported', message } as DesignTokenExportOutput);

