// Runtime â€” types.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

// Storage interface for Runtime
export interface RuntimeStorage {
  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;
  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;
  readonly delete: (relation: string, key: string) => Promise<boolean>;
  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;
}

export interface RuntimeProvisionInput {
  readonly concept: string;
  readonly runtimeType: string;
  readonly config: string;
}

export interface RuntimeProvisionOutputOk {
  readonly variant: 'ok';
  readonly instance: string;
  readonly endpoint: string;
}

export interface RuntimeProvisionOutputAlreadyProvisioned {
  readonly variant: 'alreadyProvisioned';
  readonly instance: string;
  readonly endpoint: string;
}

export interface RuntimeProvisionOutputProvisionFailed {
  readonly variant: 'provisionFailed';
  readonly concept: string;
  readonly runtimeType: string;
  readonly reason: string;
}

export type RuntimeProvisionOutput = RuntimeProvisionOutputOk | RuntimeProvisionOutputAlreadyProvisioned | RuntimeProvisionOutputProvisionFailed;

export interface RuntimeDeployInput {
  readonly instance: string;
  readonly artifact: string;
  readonly version: string;
}

export interface RuntimeDeployOutputOk {
  readonly variant: 'ok';
  readonly instance: string;
  readonly endpoint: string;
}

export interface RuntimeDeployOutputDeployFailed {
  readonly variant: 'deployFailed';
  readonly instance: string;
  readonly reason: string;
}

export type RuntimeDeployOutput = RuntimeDeployOutputOk | RuntimeDeployOutputDeployFailed;

export interface RuntimeSetTrafficWeightInput {
  readonly instance: string;
  readonly weight: number;
}

export interface RuntimeSetTrafficWeightOutput {
  readonly variant: 'ok';
  readonly instance: string;
  readonly newWeight: number;
}

export interface RuntimeRollbackInput {
  readonly instance: string;
}

export interface RuntimeRollbackOutputOk {
  readonly variant: 'ok';
  readonly instance: string;
  readonly previousVersion: string;
}

export interface RuntimeRollbackOutputNoHistory {
  readonly variant: 'noHistory';
  readonly instance: string;
}

export interface RuntimeRollbackOutputRollbackFailed {
  readonly variant: 'rollbackFailed';
  readonly instance: string;
  readonly reason: string;
}

export type RuntimeRollbackOutput = RuntimeRollbackOutputOk | RuntimeRollbackOutputNoHistory | RuntimeRollbackOutputRollbackFailed;

export interface RuntimeDestroyInput {
  readonly instance: string;
}

export interface RuntimeDestroyOutputOk {
  readonly variant: 'ok';
  readonly instance: string;
}

export interface RuntimeDestroyOutputDestroyFailed {
  readonly variant: 'destroyFailed';
  readonly instance: string;
  readonly reason: string;
}

export type RuntimeDestroyOutput = RuntimeDestroyOutputOk | RuntimeDestroyOutputDestroyFailed;

export interface RuntimeHealthCheckInput {
  readonly instance: string;
}

export interface RuntimeHealthCheckOutputOk {
  readonly variant: 'ok';
  readonly instance: string;
  readonly latencyMs: number;
}

export interface RuntimeHealthCheckOutputUnreachable {
  readonly variant: 'unreachable';
  readonly instance: string;
}

export interface RuntimeHealthCheckOutputDegraded {
  readonly variant: 'degraded';
  readonly instance: string;
  readonly latencyMs: number;
}

export type RuntimeHealthCheckOutput = RuntimeHealthCheckOutputOk | RuntimeHealthCheckOutputUnreachable | RuntimeHealthCheckOutputDegraded;

// --- Variant constructors ---

export const provisionOk = (instance: string, endpoint: string): RuntimeProvisionOutput => ({ variant: 'ok', instance, endpoint } as RuntimeProvisionOutput);
export const provisionAlreadyProvisioned = (instance: string, endpoint: string): RuntimeProvisionOutput => ({ variant: 'alreadyProvisioned', instance, endpoint } as RuntimeProvisionOutput);
export const provisionProvisionFailed = (concept: string, runtimeType: string, reason: string): RuntimeProvisionOutput => ({ variant: 'provisionFailed', concept, runtimeType, reason } as RuntimeProvisionOutput);

export const deployOk = (instance: string, endpoint: string): RuntimeDeployOutput => ({ variant: 'ok', instance, endpoint } as RuntimeDeployOutput);
export const deployDeployFailed = (instance: string, reason: string): RuntimeDeployOutput => ({ variant: 'deployFailed', instance, reason } as RuntimeDeployOutput);

export const setTrafficWeightOk = (instance: string, newWeight: number): RuntimeSetTrafficWeightOutput => ({ variant: 'ok', instance, newWeight } as RuntimeSetTrafficWeightOutput);

export const rollbackOk = (instance: string, previousVersion: string): RuntimeRollbackOutput => ({ variant: 'ok', instance, previousVersion } as RuntimeRollbackOutput);
export const rollbackNoHistory = (instance: string): RuntimeRollbackOutput => ({ variant: 'noHistory', instance } as RuntimeRollbackOutput);
export const rollbackRollbackFailed = (instance: string, reason: string): RuntimeRollbackOutput => ({ variant: 'rollbackFailed', instance, reason } as RuntimeRollbackOutput);

export const destroyOk = (instance: string): RuntimeDestroyOutput => ({ variant: 'ok', instance } as RuntimeDestroyOutput);
export const destroyDestroyFailed = (instance: string, reason: string): RuntimeDestroyOutput => ({ variant: 'destroyFailed', instance, reason } as RuntimeDestroyOutput);

export const healthCheckOk = (instance: string, latencyMs: number): RuntimeHealthCheckOutput => ({ variant: 'ok', instance, latencyMs } as RuntimeHealthCheckOutput);
export const healthCheckUnreachable = (instance: string): RuntimeHealthCheckOutput => ({ variant: 'unreachable', instance } as RuntimeHealthCheckOutput);
export const healthCheckDegraded = (instance: string, latencyMs: number): RuntimeHealthCheckOutput => ({ variant: 'degraded', instance, latencyMs } as RuntimeHealthCheckOutput);

