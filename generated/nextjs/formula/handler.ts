// Formula â€” handler.ts
// Generated by NextjsGen. Do not edit manually.
// Uses fp-ts for purely functional, composable concept implementations.

import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import * as O from 'fp-ts/Option';
import { pipe } from 'fp-ts/function';

import type {
  FormulaStorage,
  FormulaCreateInput,
  FormulaCreateOutput,
  FormulaEvaluateInput,
  FormulaEvaluateOutput,
  FormulaGetDependenciesInput,
  FormulaGetDependenciesOutput,
  FormulaInvalidateInput,
  FormulaInvalidateOutput,
  FormulaSetExpressionInput,
  FormulaSetExpressionOutput,
} from './types.js';

import {
  createOk,
  createExists,
  evaluateOk,
  evaluateNotfound,
  getDependenciesOk,
  getDependenciesNotfound,
  invalidateOk,
  invalidateNotfound,
  setExpressionOk,
  setExpressionNotfound,
} from './types.js';

export interface FormulaError {
  readonly code: string;
  readonly message: string;
}

export interface FormulaHandler {
  readonly create: (
    input: FormulaCreateInput,
    storage: FormulaStorage,
  ) => TE.TaskEither<FormulaError, FormulaCreateOutput>;
  readonly evaluate: (
    input: FormulaEvaluateInput,
    storage: FormulaStorage,
  ) => TE.TaskEither<FormulaError, FormulaEvaluateOutput>;
  readonly getDependencies: (
    input: FormulaGetDependenciesInput,
    storage: FormulaStorage,
  ) => TE.TaskEither<FormulaError, FormulaGetDependenciesOutput>;
  readonly invalidate: (
    input: FormulaInvalidateInput,
    storage: FormulaStorage,
  ) => TE.TaskEither<FormulaError, FormulaInvalidateOutput>;
  readonly setExpression: (
    input: FormulaSetExpressionInput,
    storage: FormulaStorage,
  ) => TE.TaskEither<FormulaError, FormulaSetExpressionOutput>;
}

// --- Internal types ---

interface FormulaRecord {
  readonly id: string;
  readonly expression: string;
  readonly dependencies: readonly string[];
  readonly cachedResult: string | null;
  readonly stale: boolean;
}

const makeStorageError = (error: unknown): FormulaError => ({
  code: 'STORAGE_ERROR',
  message: error instanceof Error ? error.message : String(error),
});

// Extract variable references from an expression string.
// Identifies identifiers that are not numeric literals or operators.
// Supports dot-notation references like "order.price".
const extractDependencies = (expression: string): readonly string[] => {
  const identifierPattern = /[a-zA-Z_][a-zA-Z0-9_.]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*/g;
  const matches = expression.match(identifierPattern) ?? [];
  // Filter out known keywords/builtins
  const keywords = new Set([
    'true', 'false', 'null', 'undefined', 'if', 'else', 'and', 'or', 'not',
    'abs', 'floor', 'ceil', 'round', 'min', 'max', 'sqrt', 'pow', 'len',
    'upper', 'lower', 'str', 'num', 'NaN', 'Infinity',
  ]);
  const deps = new Set<string>();
  for (const match of matches) {
    if (!keywords.has(match)) {
      deps.add(match);
    }
  }
  return Array.from(deps);
};

// Simple expression evaluator for formulas supporting:
// - Arithmetic: +, -, *, /
// - Parentheses
// - Variable references resolved from storage
// - Other formula references (resolved recursively)
const evaluateExpression = async (
  expression: string,
  storage: FormulaStorage,
  visited: ReadonlySet<string>,
): Promise<string> => {
  // Resolve variable and formula references in the expression
  const deps = extractDependencies(expression);
  let resolvedExpr = expression;

  for (const dep of deps) {
    // Try to resolve as another formula first
    const formulaRecord = await storage.get('formulas', dep);
    if (formulaRecord !== null) {
      const depId = String(formulaRecord['id'] ?? dep);
      if (visited.has(depId)) {
        return `Error: circular dependency on '${dep}'`;
      }

      const depExpr = String(formulaRecord['expression'] ?? '0');
      const cachedResult = formulaRecord['cachedResult'];
      const stale = formulaRecord['stale'];

      let depValue: string;
      if (cachedResult !== null && cachedResult !== undefined && stale !== true) {
        depValue = String(cachedResult);
      } else {
        const newVisited = new Set(visited);
        newVisited.add(depId);
        depValue = await evaluateExpression(depExpr, storage, newVisited);
      }

      // Replace all occurrences of the dependency name with its value
      const escapedDep = dep.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      resolvedExpr = resolvedExpr.replace(new RegExp(`\\b${escapedDep}\\b`, 'g'), depValue);
      continue;
    }

    // Try to resolve as a variable
    const varRecord = await storage.get('formula_variables', dep);
    if (varRecord !== null) {
      const value = String(varRecord['value'] ?? '0');
      const escapedDep = dep.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      resolvedExpr = resolvedExpr.replace(new RegExp(`\\b${escapedDep}\\b`, 'g'), value);
    }
  }

  // Evaluate the resolved expression using a safe arithmetic evaluator
  return safeEvaluate(resolvedExpr);
};

// Safe arithmetic expression evaluator (no eval())
// Supports: numbers, +, -, *, /, parentheses
const safeEvaluate = (expr: string): string => {
  const tokens = tokenize(expr);
  if (tokens.length === 0) return '0';

  let pos = 0;

  const peekToken = (): string | undefined => tokens[pos];

  const nextToken = (): string => {
    const t = tokens[pos];
    pos++;
    return t;
  };

  const parseNumber = (): number => {
    const tok = peekToken();
    if (tok === undefined) return NaN;

    if (tok === '(') {
      nextToken(); // consume '('
      const val = parseAddSub();
      if (peekToken() === ')') nextToken(); // consume ')'
      return val;
    }

    if (tok === '-') {
      nextToken();
      return -parseNumber();
    }

    nextToken();
    return parseFloat(tok);
  };

  const parseMulDiv = (): number => {
    let left = parseNumber();
    while (peekToken() === '*' || peekToken() === '/' || peekToken() === '%') {
      const op = nextToken();
      const right = parseNumber();
      if (op === '*') left = left * right;
      else if (op === '/') left = right === 0 ? NaN : left / right;
      else left = right === 0 ? NaN : left % right;
    }
    return left;
  };

  const parseAddSub = (): number => {
    let left = parseMulDiv();
    while (peekToken() === '+' || peekToken() === '-') {
      const op = nextToken();
      const right = parseMulDiv();
      if (op === '+') left = left + right;
      else left = left - right;
    }
    return left;
  };

  const result = parseAddSub();
  if (isNaN(result)) return expr; // Return original if can't evaluate
  return Number.isInteger(result) ? String(result) : result.toFixed(6).replace(/\.?0+$/, '');
};

// Tokenize a math expression into tokens
const tokenize = (expr: string): readonly string[] => {
  const tokens: string[] = [];
  let i = 0;
  const s = expr.trim();

  while (i < s.length) {
    if (s[i] === ' ' || s[i] === '\t') { i++; continue; }

    if ('+-*/%()'.includes(s[i])) {
      tokens.push(s[i]);
      i++;
      continue;
    }

    if ((s[i] >= '0' && s[i] <= '9') || s[i] === '.') {
      let num = '';
      while (i < s.length && ((s[i] >= '0' && s[i] <= '9') || s[i] === '.')) {
        num += s[i];
        i++;
      }
      tokens.push(num);
      continue;
    }

    // Skip other characters (already-resolved identifiers that couldn't resolve)
    let word = '';
    while (i < s.length && s[i] !== ' ' && !'+-*/%()'.includes(s[i])) {
      word += s[i];
      i++;
    }
    tokens.push(word);
  }

  return tokens;
};

// Find all formulas that transitively depend on a given formula
const findDependents = async (
  formulaId: string,
  storage: FormulaStorage,
): Promise<readonly string[]> => {
  const allFormulas = await storage.find('formulas');
  const dependents: string[] = [];
  const visited = new Set<string>();
  const queue: string[] = [formulaId];

  while (queue.length > 0) {
    const current = queue.shift()!;
    if (visited.has(current)) continue;
    visited.add(current);

    for (const record of allFormulas) {
      const id = String(record['id'] ?? '');
      const deps: readonly string[] = JSON.parse(String(record['dependencies'] ?? '[]'));
      if (deps.includes(current) && !visited.has(id)) {
        dependents.push(id);
        queue.push(id);
      }
    }
  }

  return dependents;
};

// --- Implementation ---

export const formulaHandler: FormulaHandler = {
  create: (input, storage) =>
    pipe(
      TE.tryCatch(
        async () => {
          const existing = await storage.get('formulas', input.formula);
          if (existing !== null) return createExists();

          const dependencies = extractDependencies(input.expression);

          await storage.put('formulas', input.formula, {
            id: input.formula,
            expression: input.expression,
            dependencies: JSON.stringify(dependencies),
            cachedResult: null,
            stale: true,
          });

          return createOk();
        },
        makeStorageError,
      ),
    ),

  evaluate: (input, storage) =>
    pipe(
      TE.tryCatch(
        () => storage.get('formulas', input.formula),
        makeStorageError,
      ),
      TE.chain((record) =>
        pipe(
          O.fromNullable(record),
          O.fold(
            () => TE.right<FormulaError, FormulaEvaluateOutput>(evaluateNotfound()),
            (found) =>
              TE.tryCatch(
                async () => {
                  const stale = found['stale'] as boolean;
                  const cachedResult = found['cachedResult'] as string | null;

                  // Return cached result if not stale
                  if (!stale && cachedResult !== null && cachedResult !== undefined) {
                    return evaluateOk(String(cachedResult));
                  }

                  // Evaluate the expression
                  const expression = String(found['expression'] ?? '0');
                  const result = await evaluateExpression(
                    expression,
                    storage,
                    new Set([input.formula]),
                  );

                  // Cache the result
                  await storage.put('formulas', input.formula, {
                    ...found,
                    cachedResult: result,
                    stale: false,
                  });

                  return evaluateOk(result);
                },
                makeStorageError,
              ),
          ),
        ),
      ),
    ),

  getDependencies: (input, storage) =>
    pipe(
      TE.tryCatch(
        () => storage.get('formulas', input.formula),
        makeStorageError,
      ),
      TE.chain((record) =>
        pipe(
          O.fromNullable(record),
          O.fold(
            () => TE.right<FormulaError, FormulaGetDependenciesOutput>(getDependenciesNotfound()),
            (found) => {
              const deps = String(found['dependencies'] ?? '[]');
              return TE.right<FormulaError, FormulaGetDependenciesOutput>(
                getDependenciesOk(deps),
              );
            },
          ),
        ),
      ),
    ),

  invalidate: (input, storage) =>
    pipe(
      TE.tryCatch(
        () => storage.get('formulas', input.formula),
        makeStorageError,
      ),
      TE.chain((record) =>
        pipe(
          O.fromNullable(record),
          O.fold(
            () => TE.right<FormulaError, FormulaInvalidateOutput>(invalidateNotfound()),
            (found) =>
              TE.tryCatch(
                async () => {
                  // Mark this formula as stale
                  await storage.put('formulas', input.formula, {
                    ...found,
                    cachedResult: null,
                    stale: true,
                  });

                  // Find and invalidate all transitive dependents
                  const dependents = await findDependents(input.formula, storage);
                  for (const depId of dependents) {
                    const depRecord = await storage.get('formulas', depId);
                    if (depRecord !== null) {
                      await storage.put('formulas', depId, {
                        ...depRecord,
                        cachedResult: null,
                        stale: true,
                      });
                    }
                  }

                  return invalidateOk();
                },
                makeStorageError,
              ),
          ),
        ),
      ),
    ),

  setExpression: (input, storage) =>
    pipe(
      TE.tryCatch(
        () => storage.get('formulas', input.formula),
        makeStorageError,
      ),
      TE.chain((record) =>
        pipe(
          O.fromNullable(record),
          O.fold(
            () => TE.right<FormulaError, FormulaSetExpressionOutput>(setExpressionNotfound()),
            (found) =>
              TE.tryCatch(
                async () => {
                  const newDependencies = extractDependencies(input.expression);

                  // Update the formula with new expression, clear cache, mark stale
                  await storage.put('formulas', input.formula, {
                    ...found,
                    expression: input.expression,
                    dependencies: JSON.stringify(newDependencies),
                    cachedResult: null,
                    stale: true,
                  });

                  // Invalidate all transitive dependents
                  const dependents = await findDependents(input.formula, storage);
                  for (const depId of dependents) {
                    const depRecord = await storage.get('formulas', depId);
                    if (depRecord !== null) {
                      await storage.put('formulas', depId, {
                        ...depRecord,
                        cachedResult: null,
                        stale: true,
                      });
                    }
                  }

                  return setExpressionOk();
                },
                makeStorageError,
              ),
          ),
        ),
      ),
    ),
};
