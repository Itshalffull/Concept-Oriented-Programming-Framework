// Auto-generated by Clef Interface Kit â€” rust-sdk target
// Concept: Article
// Do not edit manually; regenerate with: clef interface generate

use serde::{Deserialize, Serialize};
use reqwest::Client;

// --- Error Type ---

#[derive(Debug)]
pub enum Error {
    Request(reqwest::Error),
    Api { status: u16, body: String },
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::Request(e) => write!(f, "request error: {e}"),
            Error::Api { status, body } => write!(f, "API error {status}: {body}"),
        }
    }
}

impl std::error::Error for Error {}

// --- Request/Response Types ---

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateArticleInput {
    pub article: String,
    pub title: String,
    pub description: String,
    pub body: String,
    pub author: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateArticleOutput {
    pub article: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateArticleInput {
    pub article: String,
    pub title: String,
    pub description: String,
    pub body: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateArticleOutput {
    pub article: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteArticleInput {
    pub article: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteArticleOutput {
    pub article: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetArticleInput {
    pub article: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetArticleOutput {
    pub article: String,
    pub slug: String,
    pub title: String,
    pub description: String,
    pub body: String,
    pub author: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ListArticleInput {}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ListArticleOutput {
    pub articles: String,
}

// --- Client ---

pub struct ArticleClient {
    base_url: String,
    headers: Vec<(String, String)>,
    client: Client,
}

impl ArticleClient {
    pub fn new(base_url: impl Into<String>) -> Self {
        Self {
            base_url: base_url.into(),
            headers: Vec::new(),
            client: Client::new(),
        }
    }

    pub fn with_header(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.headers.push((key.into(), value.into()));
        self
    }

    pub async fn create(&self, input: CreateArticleInput) -> Result<CreateArticleOutput, Error> {
        let url = format!("{}/api/articles", self.base_url);
        let mut req = self.client.post(&url)
            .json(&input);
        for (k, v) in &self.headers {
            req = req.header(k.as_str(), v.as_str());
        }
        let resp = req.send().await.map_err(Error::Request)?;
        if !resp.status().is_success() {
            let status = resp.status().as_u16();
            let body = resp.text().await.unwrap_or_default();
            return Err(Error::Api { status, body });
        }
        resp.json::<CreateArticleOutput>().await.map_err(Error::Request)
    }

    pub async fn update(&self, input: UpdateArticleInput) -> Result<UpdateArticleOutput, Error> {
        let url = format!("{}/api/articles/{}",  self.base_url, "");
        let mut req = self.client.put(&url)
            .json(&input);
        for (k, v) in &self.headers {
            req = req.header(k.as_str(), v.as_str());
        }
        let resp = req.send().await.map_err(Error::Request)?;
        if !resp.status().is_success() {
            let status = resp.status().as_u16();
            let body = resp.text().await.unwrap_or_default();
            return Err(Error::Api { status, body });
        }
        resp.json::<UpdateArticleOutput>().await.map_err(Error::Request)
    }

    pub async fn delete(&self, id: &str) -> Result<DeleteArticleOutput, Error> {
        let url = format!("{}/api/articles/{}",  self.base_url, id);
        let mut req = self.client.delete(&url);
        for (k, v) in &self.headers {
            req = req.header(k.as_str(), v.as_str());
        }
        let resp = req.send().await.map_err(Error::Request)?;
        if !resp.status().is_success() {
            let status = resp.status().as_u16();
            let body = resp.text().await.unwrap_or_default();
            return Err(Error::Api { status, body });
        }
        resp.json::<DeleteArticleOutput>().await.map_err(Error::Request)
    }

    pub async fn get(&self, id: &str) -> Result<GetArticleOutput, Error> {
        let url = format!("{}/api/articles/{}",  self.base_url, id);
        let mut req = self.client.get(&url);
        for (k, v) in &self.headers {
            req = req.header(k.as_str(), v.as_str());
        }
        let resp = req.send().await.map_err(Error::Request)?;
        if !resp.status().is_success() {
            let status = resp.status().as_u16();
            let body = resp.text().await.unwrap_or_default();
            return Err(Error::Api { status, body });
        }
        resp.json::<GetArticleOutput>().await.map_err(Error::Request)
    }

    pub async fn list(&self) -> Result<ListArticleOutput, Error> {
        let url = format!("{}/api/articles", self.base_url);
        let mut req = self.client.get(&url);
        for (k, v) in &self.headers {
            req = req.header(k.as_str(), v.as_str());
        }
        let resp = req.send().await.map_err(Error::Request)?;
        if !resp.status().is_success() {
            let status = resp.status().as_u16();
            let body = resp.text().await.unwrap_or_default();
            return Err(Error::Api { status, body });
        }
        resp.json::<ListArticleOutput>().await.map_err(Error::Request)
    }
}
