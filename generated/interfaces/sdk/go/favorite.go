// Auto-generated by Clef Interface Kit â€” go-sdk target
// Concept: Favorite
// Do not edit manually; regenerate with: clef interface generate

package conduit

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
)

// FavoriteClient provides HTTP methods for the Favorite concept.
type FavoriteClient struct {
	BaseURL string
	Headers map[string]string
}

// NewFavoriteClient creates a new client for the Favorite concept.
func NewFavoriteClient(baseURL string) *FavoriteClient {
	return &FavoriteClient{BaseURL: baseURL, Headers: map[string]string{}}
}

// --- Request/Response Types ---

type FavoriteFavoriteInput struct {
	User string `json:"user"`
	Article string `json:"article"`
}

type FavoriteFavoriteOutput struct {
	User string `json:"user"`
	Article string `json:"article"`
}

type UnfavoriteFavoriteInput struct {
	User string `json:"user"`
	Article string `json:"article"`
}

type UnfavoriteFavoriteOutput struct {
	User string `json:"user"`
	Article string `json:"article"`
}

type IsFavoritedFavoriteInput struct {
	User string `json:"user"`
	Article string `json:"article"`
}

type IsFavoritedFavoriteOutput struct {
	Favorited bool `json:"favorited"`
}

type CountFavoriteInput struct {
	Article string `json:"article"`
}

type CountFavoriteOutput struct {
	Count int64 `json:"count"`
}

// --- Client Methods ---

func (c *FavoriteClient) Favorite(ctx context.Context, input FavoriteFavoriteInput) (*FavoriteFavoriteOutput, error) {
	body, err := json.Marshal(input)
	if err != nil {
		return nil, fmt.Errorf("Favorite: marshal input: %w", err)
	}
	url := fmt.Sprintf("%s/api/favorites/%s/favorite", c.BaseURL, "")
	req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("Favorite: build request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	for k, v := range c.Headers {
		req.Header.Set(k, v)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("Favorite: execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		errBody, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("Favorite: status %d: %s", resp.StatusCode, string(errBody))
	}
	var output FavoriteFavoriteOutput
	if err := json.NewDecoder(resp.Body).Decode(&output); err != nil {
		return nil, fmt.Errorf("Favorite: decode response: %w", err)
	}
	return &output, nil
}

func (c *FavoriteClient) Unfavorite(ctx context.Context, input UnfavoriteFavoriteInput) (*UnfavoriteFavoriteOutput, error) {
	body, err := json.Marshal(input)
	if err != nil {
		return nil, fmt.Errorf("Unfavorite: marshal input: %w", err)
	}
	url := fmt.Sprintf("%s/api/favorites/%s/unfavorite", c.BaseURL, "")
	req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("Unfavorite: build request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	for k, v := range c.Headers {
		req.Header.Set(k, v)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("Unfavorite: execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		errBody, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("Unfavorite: status %d: %s", resp.StatusCode, string(errBody))
	}
	var output UnfavoriteFavoriteOutput
	if err := json.NewDecoder(resp.Body).Decode(&output); err != nil {
		return nil, fmt.Errorf("Unfavorite: decode response: %w", err)
	}
	return &output, nil
}

func (c *FavoriteClient) IsFavorited(ctx context.Context, input IsFavoritedFavoriteInput) (*IsFavoritedFavoriteOutput, error) {
	body, err := json.Marshal(input)
	if err != nil {
		return nil, fmt.Errorf("IsFavorited: marshal input: %w", err)
	}
	url := fmt.Sprintf("%s/api/favorites/%s/is-favorited", c.BaseURL, "")
	req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("IsFavorited: build request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	for k, v := range c.Headers {
		req.Header.Set(k, v)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IsFavorited: execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		errBody, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("IsFavorited: status %d: %s", resp.StatusCode, string(errBody))
	}
	var output IsFavoritedFavoriteOutput
	if err := json.NewDecoder(resp.Body).Decode(&output); err != nil {
		return nil, fmt.Errorf("IsFavorited: decode response: %w", err)
	}
	return &output, nil
}

func (c *FavoriteClient) Count(ctx context.Context, input CountFavoriteInput) (*CountFavoriteOutput, error) {
	body, err := json.Marshal(input)
	if err != nil {
		return nil, fmt.Errorf("Count: marshal input: %w", err)
	}
	url := fmt.Sprintf("%s/api/favorites/%s/count", c.BaseURL, "")
	req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("Count: build request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	for k, v := range c.Headers {
		req.Header.Set(k, v)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("Count: execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		errBody, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("Count: status %d: %s", resp.StatusCode, string(errBody))
	}
	var output CountFavoriteOutput
	if err := json.NewDecoder(resp.Body).Decode(&output); err != nil {
		return nil, fmt.Errorf("Count: decode response: %w", err)
	}
	return &output, nil
}
