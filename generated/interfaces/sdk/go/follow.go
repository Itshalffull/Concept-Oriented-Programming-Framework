// Auto-generated by COPF Interface Kit â€” go-sdk target
// Concept: Follow
// Do not edit manually; regenerate with: copf interface generate

package conduit

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
)

// FollowClient provides HTTP methods for the Follow concept.
type FollowClient struct {
	BaseURL string
	Headers map[string]string
}

// NewFollowClient creates a new client for the Follow concept.
func NewFollowClient(baseURL string) *FollowClient {
	return &FollowClient{BaseURL: baseURL, Headers: map[string]string{}}
}

// --- Request/Response Types ---

type FollowFollowInput struct {
	User string `json:"user"`
	Target string `json:"target"`
}

type FollowFollowOutput struct {
	User string `json:"user"`
	Target string `json:"target"`
}

type UnfollowFollowInput struct {
	User string `json:"user"`
	Target string `json:"target"`
}

type UnfollowFollowOutput struct {
	User string `json:"user"`
	Target string `json:"target"`
}

type IsFollowingFollowInput struct {
	User string `json:"user"`
	Target string `json:"target"`
}

type IsFollowingFollowOutput struct {
	Following bool `json:"following"`
}

// --- Client Methods ---

func (c *FollowClient) Follow(ctx context.Context, input FollowFollowInput) (*FollowFollowOutput, error) {
	body, err := json.Marshal(input)
	if err != nil {
		return nil, fmt.Errorf("Follow: marshal input: %w", err)
	}
	url := fmt.Sprintf("%s/api/follows/%s/follow", c.BaseURL, "")
	req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("Follow: build request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	for k, v := range c.Headers {
		req.Header.Set(k, v)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("Follow: execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		errBody, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("Follow: status %d: %s", resp.StatusCode, string(errBody))
	}
	var output FollowFollowOutput
	if err := json.NewDecoder(resp.Body).Decode(&output); err != nil {
		return nil, fmt.Errorf("Follow: decode response: %w", err)
	}
	return &output, nil
}

func (c *FollowClient) Unfollow(ctx context.Context, input UnfollowFollowInput) (*UnfollowFollowOutput, error) {
	body, err := json.Marshal(input)
	if err != nil {
		return nil, fmt.Errorf("Unfollow: marshal input: %w", err)
	}
	url := fmt.Sprintf("%s/api/follows/%s/unfollow", c.BaseURL, "")
	req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("Unfollow: build request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	for k, v := range c.Headers {
		req.Header.Set(k, v)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("Unfollow: execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		errBody, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("Unfollow: status %d: %s", resp.StatusCode, string(errBody))
	}
	var output UnfollowFollowOutput
	if err := json.NewDecoder(resp.Body).Decode(&output); err != nil {
		return nil, fmt.Errorf("Unfollow: decode response: %w", err)
	}
	return &output, nil
}

func (c *FollowClient) IsFollowing(ctx context.Context, input IsFollowingFollowInput) (*IsFollowingFollowOutput, error) {
	body, err := json.Marshal(input)
	if err != nil {
		return nil, fmt.Errorf("IsFollowing: marshal input: %w", err)
	}
	url := fmt.Sprintf("%s/api/follows/%s/is-following", c.BaseURL, "")
	req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("IsFollowing: build request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	for k, v := range c.Headers {
		req.Header.Set(k, v)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IsFollowing: execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		errBody, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("IsFollowing: status %d: %s", resp.StatusCode, string(errBody))
	}
	var output IsFollowingFollowOutput
	if err := json.NewDecoder(resp.Body).Decode(&output); err != nil {
		return nil, fmt.Errorf("IsFollowing: decode response: %w", err)
	}
	return &output, nil
}
