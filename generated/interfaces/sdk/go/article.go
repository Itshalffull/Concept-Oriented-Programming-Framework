// Auto-generated by Clef Interface Kit â€” go-sdk target
// Concept: Article
// Do not edit manually; regenerate with: clef interface generate

package conduit

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
)

// ArticleClient provides HTTP methods for the Article concept.
type ArticleClient struct {
	BaseURL string
	Headers map[string]string
}

// NewArticleClient creates a new client for the Article concept.
func NewArticleClient(baseURL string) *ArticleClient {
	return &ArticleClient{BaseURL: baseURL, Headers: map[string]string{}}
}

// --- Request/Response Types ---

type CreateArticleInput struct {
	Article string `json:"article"`
	Title string `json:"title"`
	Description string `json:"description"`
	Body string `json:"body"`
	Author string `json:"author"`
}

type CreateArticleOutput struct {
	Article string `json:"article"`
}

type UpdateArticleInput struct {
	Article string `json:"article"`
	Title string `json:"title"`
	Description string `json:"description"`
	Body string `json:"body"`
}

type UpdateArticleOutput struct {
	Article string `json:"article"`
}

type DeleteArticleInput struct {
	Article string `json:"article"`
}

type DeleteArticleOutput struct {
	Article string `json:"article"`
}

type GetArticleInput struct {
	Article string `json:"article"`
}

type GetArticleOutput struct {
	Article string `json:"article"`
	Slug string `json:"slug"`
	Title string `json:"title"`
	Description string `json:"description"`
	Body string `json:"body"`
	Author string `json:"author"`
}

type ListArticleInput struct{}

type ListArticleOutput struct {
	Articles string `json:"articles"`
}

// --- Client Methods ---

func (c *ArticleClient) Create(ctx context.Context, input CreateArticleInput) (*CreateArticleOutput, error) {
	body, err := json.Marshal(input)
	if err != nil {
		return nil, fmt.Errorf("Create: marshal input: %w", err)
	}
	url := fmt.Sprintf("%s/api/articles", c.BaseURL)
	req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("Create: build request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	for k, v := range c.Headers {
		req.Header.Set(k, v)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("Create: execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		errBody, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("Create: status %d: %s", resp.StatusCode, string(errBody))
	}
	var output CreateArticleOutput
	if err := json.NewDecoder(resp.Body).Decode(&output); err != nil {
		return nil, fmt.Errorf("Create: decode response: %w", err)
	}
	return &output, nil
}

func (c *ArticleClient) Update(ctx context.Context, input UpdateArticleInput) (*UpdateArticleOutput, error) {
	body, err := json.Marshal(input)
	if err != nil {
		return nil, fmt.Errorf("Update: marshal input: %w", err)
	}
	url := fmt.Sprintf("%s/api/articles/%s", c.BaseURL, "")
	req, err := http.NewRequestWithContext(ctx, "PUT", url, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("Update: build request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	for k, v := range c.Headers {
		req.Header.Set(k, v)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("Update: execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		errBody, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("Update: status %d: %s", resp.StatusCode, string(errBody))
	}
	var output UpdateArticleOutput
	if err := json.NewDecoder(resp.Body).Decode(&output); err != nil {
		return nil, fmt.Errorf("Update: decode response: %w", err)
	}
	return &output, nil
}

func (c *ArticleClient) Delete(ctx context.Context, id string) (*DeleteArticleOutput, error) {
	url := fmt.Sprintf("%s/api/articles/%s", c.BaseURL, id)
	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("Delete: build request: %w", err)
	}
	for k, v := range c.Headers {
		req.Header.Set(k, v)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("Delete: execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		errBody, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("Delete: status %d: %s", resp.StatusCode, string(errBody))
	}
	var output DeleteArticleOutput
	if err := json.NewDecoder(resp.Body).Decode(&output); err != nil {
		return nil, fmt.Errorf("Delete: decode response: %w", err)
	}
	return &output, nil
}

func (c *ArticleClient) Get(ctx context.Context, id string) (*GetArticleOutput, error) {
	url := fmt.Sprintf("%s/api/articles/%s", c.BaseURL, id)
	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("Get: build request: %w", err)
	}
	for k, v := range c.Headers {
		req.Header.Set(k, v)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("Get: execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		errBody, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("Get: status %d: %s", resp.StatusCode, string(errBody))
	}
	var output GetArticleOutput
	if err := json.NewDecoder(resp.Body).Decode(&output); err != nil {
		return nil, fmt.Errorf("Get: decode response: %w", err)
	}
	return &output, nil
}

func (c *ArticleClient) List(ctx context.Context) (*ListArticleOutput, error) {
	url := fmt.Sprintf("%s/api/articles", c.BaseURL)
	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("List: build request: %w", err)
	}
	for k, v := range c.Headers {
		req.Header.Set(k, v)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("List: execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		errBody, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("List: status %d: %s", resp.StatusCode, string(errBody))
	}
	var output ListArticleOutput
	if err := json.NewDecoder(resp.Body).Decode(&output); err != nil {
		return nil, fmt.Errorf("List: decode response: %w", err)
	}
	return &output, nil
}
