// Auto-generated by Clef Interface Kit — swift-sdk target
// Concept: Article
// Do not edit manually; regenerate with: clef interface generate

import Foundation

// --- Error Type ---

public enum ClientError: Error, LocalizedError {
    case invalidResponse
    case apiError(status: Int, body: String)

    public var errorDescription: String? {
        switch self {
        case .invalidResponse:
            return "Invalid HTTP response"
        case .apiError(let status, let body):
            return "API error \(status): \(body)"
        }
    }
}

// --- ArticleClient ---

public class ArticleClient {

    let baseURL: URL
    var headers: [String: String]
    private let encoder = JSONEncoder()
    private let decoder = JSONDecoder()

    public init(baseURL: URL, headers: [String: String] = [:]) {
        self.baseURL = baseURL
        self.headers = headers
    }

    // --- Request/Response Types ---

    public struct CreateInput: Codable {
        public let article: String
        public let title: String
        public let description: String
        public let body: String
        public let author: String
    }

    public struct CreateOutput: Codable {
        public let article: String
    }

    public struct UpdateInput: Codable {
        public let article: String
        public let title: String
        public let description: String
        public let body: String
    }

    public struct UpdateOutput: Codable {
        public let article: String
    }

    public struct DeleteInput: Codable {
        public let article: String
    }

    public struct DeleteOutput: Codable {
        public let article: String
    }

    public struct GetInput: Codable {
        public let article: String
    }

    public struct GetOutput: Codable {
        public let article: String
        public let slug: String
        public let title: String
        public let description: String
        public let body: String
        public let author: String
    }

    public struct ListInput: Codable {}

    public struct ListOutput: Codable {
        public let articles: String
    }

    // --- Client Methods ---

    /// create — POST /api/articles
    public func create(input: CreateInput) async throws -> CreateOutput {
        let url = baseURL.appendingPathComponent("/api/articles")
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        for (key, value) in headers {
            request.setValue(value, forHTTPHeaderField: key)
        }
        request.httpBody = try encoder.encode(input)
        let (data, response) = try await URLSession.shared.data(for: request)
        guard let httpResponse = response as? HTTPURLResponse else {
            throw ClientError.invalidResponse
        }
        guard httpResponse.statusCode < 400 else {
            let body = String(data: data, encoding: .utf8) ?? ""
            throw ClientError.apiError(status: httpResponse.statusCode, body: body)
        }
        return try decoder.decode(CreateOutput.self, from: data)
    }

    /// update — PUT /api/articles/{id}
    public func update(input: UpdateInput) async throws -> UpdateOutput {
        let path = "/api/articles/{id}".replacingOccurrences(of: "{id}", with: "")
        let url = baseURL.appendingPathComponent(path)
        var request = URLRequest(url: url)
        request.httpMethod = "PUT"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        for (key, value) in headers {
            request.setValue(value, forHTTPHeaderField: key)
        }
        request.httpBody = try encoder.encode(input)
        let (data, response) = try await URLSession.shared.data(for: request)
        guard let httpResponse = response as? HTTPURLResponse else {
            throw ClientError.invalidResponse
        }
        guard httpResponse.statusCode < 400 else {
            let body = String(data: data, encoding: .utf8) ?? ""
            throw ClientError.apiError(status: httpResponse.statusCode, body: body)
        }
        return try decoder.decode(UpdateOutput.self, from: data)
    }

    /// delete — DELETE /api/articles/{id}
    public func delete(id: String) async throws -> DeleteOutput {
        let path = "/api/articles/{id}".replacingOccurrences(of: "{id}", with: id)
        let url = baseURL.appendingPathComponent(path)
        var request = URLRequest(url: url)
        request.httpMethod = "DELETE"
        for (key, value) in headers {
            request.setValue(value, forHTTPHeaderField: key)
        }
        let (data, response) = try await URLSession.shared.data(for: request)
        guard let httpResponse = response as? HTTPURLResponse else {
            throw ClientError.invalidResponse
        }
        guard httpResponse.statusCode < 400 else {
            let body = String(data: data, encoding: .utf8) ?? ""
            throw ClientError.apiError(status: httpResponse.statusCode, body: body)
        }
        return try decoder.decode(DeleteOutput.self, from: data)
    }

    /// get — GET /api/articles/{id}
    public func get(id: String) async throws -> GetOutput {
        let path = "/api/articles/{id}".replacingOccurrences(of: "{id}", with: id)
        let url = baseURL.appendingPathComponent(path)
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        for (key, value) in headers {
            request.setValue(value, forHTTPHeaderField: key)
        }
        let (data, response) = try await URLSession.shared.data(for: request)
        guard let httpResponse = response as? HTTPURLResponse else {
            throw ClientError.invalidResponse
        }
        guard httpResponse.statusCode < 400 else {
            let body = String(data: data, encoding: .utf8) ?? ""
            throw ClientError.apiError(status: httpResponse.statusCode, body: body)
        }
        return try decoder.decode(GetOutput.self, from: data)
    }

    /// list — GET /api/articles
    public func list() async throws -> ListOutput {
        let url = baseURL.appendingPathComponent("/api/articles")
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        for (key, value) in headers {
            request.setValue(value, forHTTPHeaderField: key)
        }
        let (data, response) = try await URLSession.shared.data(for: request)
        guard let httpResponse = response as? HTTPURLResponse else {
            throw ClientError.invalidResponse
        }
        guard httpResponse.statusCode < 400 else {
            let body = String(data: data, encoding: .utf8) ?? ""
            throw ClientError.apiError(status: httpResponse.statusCode, body: body)
        }
        return try decoder.decode(ListOutput.self, from: data)
    }
}
