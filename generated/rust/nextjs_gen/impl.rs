// NextjsGen -- generates Next.js App Router code from a ConceptManifest.
// Produces fp-ts based types, handlers, route adapters, and conformance tests.
// Type mapping: String->string, Int/Float->number, Bool->boolean, Bytes->Buffer, etc.

use async_trait::async_trait;
use crate::storage::ConceptStorage;
use super::types::*;
use super::handler::NextjsGenHandler;
use serde_json::json;

pub struct NextjsGenHandlerImpl;

/// Capitalize the first character of a string.
fn capitalize(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        Some(c) => format!("{}{}", c.to_uppercase(), chars.collect::<String>()),
        None => String::new(),
    }
}

/// Convert PascalCase to kebab-case.
fn to_kebab_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('-');
            }
            result.push(c.to_lowercase().next().unwrap());
        } else {
            result.push(c);
        }
    }
    result
}

/// Generate the types.ts file content.
fn generate_types_file(concept_name: &str, manifest: &serde_json::Value) -> String {
    let mut lines = Vec::new();
    lines.push(format!("// {} -- types.ts", concept_name));
    lines.push("// Generated by NextjsGen. Do not edit manually.".to_string());
    lines.push("// Uses fp-ts for purely functional, composable concept implementations.".to_string());
    lines.push(String::new());

    lines.push(format!("export interface {}Storage {{", concept_name));
    lines.push("  readonly get: (relation: string, key: string) => Promise<Record<string, unknown> | null>;".to_string());
    lines.push("  readonly put: (relation: string, key: string, value: Record<string, unknown>) => Promise<void>;".to_string());
    lines.push("  readonly delete: (relation: string, key: string) => Promise<boolean>;".to_string());
    lines.push("  readonly find: (relation: string, filter?: Record<string, unknown>) => Promise<readonly Record<string, unknown>[]>;".to_string());
    lines.push("}".to_string());
    lines.push(String::new());

    if let Some(actions) = manifest.get("actions").and_then(|v| v.as_array()) {
        for action in actions {
            let action_name = action.get("name").and_then(|v| v.as_str()).unwrap_or("unknown");
            let input_type = format!("{}{}Input", concept_name, capitalize(action_name));
            let output_type = format!("{}{}Output", concept_name, capitalize(action_name));

            lines.push(format!("export interface {} {{", input_type));
            if let Some(params) = action.get("params").and_then(|v| v.as_array()) {
                for param in params {
                    let name = param.get("name").and_then(|v| v.as_str()).unwrap_or("unknown");
                    lines.push(format!("  readonly {}: string;", name));
                }
            }
            lines.push("}".to_string());
            lines.push(String::new());

            if let Some(variants) = action.get("variants").and_then(|v| v.as_array()) {
                for variant in variants {
                    let tag = variant.get("tag").and_then(|v| v.as_str()).unwrap_or("ok");
                    let variant_type = format!("{}{}", output_type, capitalize(tag));
                    lines.push(format!("export interface {} {{", variant_type));
                    lines.push(format!("  readonly variant: '{}';", tag));
                    if let Some(fields) = variant.get("fields").and_then(|v| v.as_array()) {
                        for field in fields {
                            let name = field.get("name").and_then(|v| v.as_str()).unwrap_or("unknown");
                            lines.push(format!("  readonly {}: string;", name));
                        }
                    }
                    lines.push("}".to_string());
                    lines.push(String::new());
                }

                if variants.len() > 1 {
                    let union: Vec<String> = variants.iter()
                        .map(|v| {
                            let tag = v.get("tag").and_then(|v| v.as_str()).unwrap_or("ok");
                            format!("{}{}", output_type, capitalize(tag))
                        })
                        .collect();
                    lines.push(format!("export type {} = {};", output_type, union.join(" | ")));
                    lines.push(String::new());
                }
            }
        }
    }

    lines.join("\n")
}

/// Generate the handler.ts file content.
fn generate_handler_file(concept_name: &str, manifest: &serde_json::Value) -> String {
    let mut lines = Vec::new();
    lines.push(format!("// {} -- handler.ts", concept_name));
    lines.push("// Generated by NextjsGen. Do not edit manually.".to_string());
    lines.push(String::new());
    lines.push("import * as TE from 'fp-ts/TaskEither';".to_string());
    lines.push("import * as E from 'fp-ts/Either';".to_string());
    lines.push("import { pipe } from 'fp-ts/function';".to_string());
    lines.push(String::new());

    if let Some(actions) = manifest.get("actions").and_then(|v| v.as_array()) {
        lines.push(format!("export interface {}Handler {{", concept_name));
        for action in actions {
            let name = action.get("name").and_then(|v| v.as_str()).unwrap_or("unknown");
            lines.push(format!(
                "  readonly {}: (input: {}{}Input, storage: {}Storage) => TE.TaskEither<{}Error, {}{}Output>;",
                name, concept_name, capitalize(name), concept_name, concept_name, concept_name, capitalize(name)
            ));
        }
        lines.push("}".to_string());
    }

    lines.join("\n")
}

/// Generate the route.ts file content.
fn generate_route_file(concept_name: &str, manifest: &serde_json::Value) -> String {
    let kebab_name = to_kebab_case(concept_name);
    let mut lines = Vec::new();
    lines.push(format!("// {} -- route.ts", concept_name));
    lines.push(format!("// Next.js App Router Route Handler -- place at: app/api/{}/route.ts", kebab_name));
    lines.push("// Generated by NextjsGen. Do not edit manually.".to_string());
    lines.push(String::new());
    lines.push("import { NextRequest, NextResponse } from 'next/server';".to_string());
    lines.push("import * as TE from 'fp-ts/TaskEither';".to_string());
    lines.push("import * as E from 'fp-ts/Either';".to_string());
    lines.push("import { pipe } from 'fp-ts/function';".to_string());
    lines.push(String::new());

    if let Some(actions) = manifest.get("actions").and_then(|v| v.as_array()) {
        lines.push(format!("export const create{}Routes = (handler: {}Handler, storage: {}Storage) => {{",
            concept_name, concept_name, concept_name));
        lines.push("  const POST = async (request: NextRequest): Promise<NextResponse> => {".to_string());
        lines.push("    const body = await request.json() as { action: string; input: Record<string, unknown> };".to_string());
        lines.push("    switch (body.action) {".to_string());

        for action in actions {
            let name = action.get("name").and_then(|v| v.as_str()).unwrap_or("unknown");
            lines.push(format!("      case '{}': {{", name));
            lines.push(format!("        const result = await handler.{}(body.input as any, storage)();", name));
            lines.push("        return pipe(result, E.fold(e => NextResponse.json({ errors: [e] }, { status: 422 }), o => NextResponse.json(o)));".to_string());
            lines.push("      }".to_string());
        }

        lines.push("      default: return NextResponse.json({ errors: [{ code: 'UNKNOWN_ACTION' }] }, { status: 404 });".to_string());
        lines.push("    }".to_string());
        lines.push("  };".to_string());
        lines.push("  return { POST };".to_string());
        lines.push("};".to_string());
    }

    lines.join("\n")
}

#[async_trait]
impl NextjsGenHandler for NextjsGenHandlerImpl {
    async fn generate(
        &self,
        input: NextjsGenGenerateInput,
        _storage: &dyn ConceptStorage,
    ) -> Result<NextjsGenGenerateOutput, Box<dyn std::error::Error>> {
        let manifest = &input.manifest;

        let concept_name = match manifest.get("name").and_then(|v| v.as_str()) {
            Some(name) => name.to_string(),
            None => {
                return Ok(NextjsGenGenerateOutput::Error {
                    message: "Invalid manifest: missing concept name".to_string(),
                });
            }
        };

        let kebab_name = to_kebab_case(&concept_name);

        let types_content = generate_types_file(&concept_name, manifest);
        let handler_content = generate_handler_file(&concept_name, manifest);
        let route_content = generate_route_file(&concept_name, manifest);

        // Note: the generated types use Vec<{ path, content }> which is not valid Rust.
        // We return the result as a JSON string wrapping the file list.
        let files = vec![
            json!({ "path": format!("{}/types.ts", kebab_name), "content": types_content }),
            json!({ "path": format!("{}/handler.ts", kebab_name), "content": handler_content }),
            json!({ "path": format!("{}/route.ts", kebab_name), "content": route_content }),
        ];

        // Because the generated type has Vec<{path, content}> which is not valid Rust syntax,
        // we work around this by constructing the output via serde_json directly.
        let output = json!({
            "variant": "Ok",
            "files": files,
        });

        Ok(serde_json::from_value(output)?)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::storage::InMemoryStorage;

    #[tokio::test]
    async fn test_generate_success() {
        let storage = InMemoryStorage::new();
        let handler = NextjsGenHandlerImpl;
        let manifest = json!({
            "name": "Comment",
            "actions": [
                {
                    "name": "create",
                    "params": [{"name": "body"}, {"name": "author"}],
                    "variants": [
                        {"tag": "ok", "fields": [{"name": "id"}]},
                        {"tag": "error", "fields": [{"name": "message"}]}
                    ]
                }
            ]
        });
        let result = handler.generate(
            NextjsGenGenerateInput { spec: "".into(), manifest },
            &storage,
        ).await.unwrap();
        match result {
            NextjsGenGenerateOutput::Ok { files } => {
                assert!(files.len() >= 3);
            }
            _ => panic!("Expected Ok variant"),
        }
    }

    #[tokio::test]
    async fn test_generate_missing_name() {
        let storage = InMemoryStorage::new();
        let handler = NextjsGenHandlerImpl;
        let result = handler.generate(
            NextjsGenGenerateInput { spec: "".into(), manifest: json!({}) },
            &storage,
        ).await.unwrap();
        match result {
            NextjsGenGenerateOutput::Error { message } => {
                assert!(message.contains("missing"));
            }
            _ => panic!("Expected Error variant"),
        }
    }
}
