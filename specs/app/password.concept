concept Password [U] {

  purpose {
    Securely store and validate user credentials using
    salted hashing. Does not handle reset flows â€” those
    are composed via synchronization with a token concept.
  }

  state {
    hash: U -> Bytes
    salt: U -> Bytes
  }

  capabilities {
    requires crypto
  }

  actions {
    action set(user: U, password: String) {
      -> ok(user: U) {
        Generate a random salt. Hash the password with the salt.
        Store both. Return the user reference.
      }
      -> invalid(message: String) {
        If the password does not meet strength requirements,
        return a description of the violation.
      }
    }

    action check(user: U, password: String) {
      -> ok(valid: Bool) {
        Retrieve the salt for the user. Hash the provided
        password with it. Return true if hashes match.
      }
      -> notfound(message: String) {
        If the user has no stored credentials, return an error.
      }
    }

    action validate(password: String) {
      -> ok(valid: Bool) {
        Check that the password meets strength requirements
        without storing anything.
      }
    }
  }

  invariant {
    after set(user: x, password: "secret123") -> ok(user: x)
    then check(user: x, password: "secret123") -> ok(valid: true)
    and  check(user: x, password: "wrongpass")  -> ok(valid: false)
  }
}
