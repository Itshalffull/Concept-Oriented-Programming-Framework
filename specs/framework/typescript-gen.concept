concept TypeScriptGen [S] {

  purpose {
    Generate TypeScript skeleton code from a ConceptManifest.
    Produces type definitions, handler interface, transport adapter,
    lite query implementation, and conformance tests.
  }

  state {
    outputs: S -> list { path: String, content: String }
  }

  actions {
    action generate(spec: S, manifest: ConceptManifest) {
      -> ok(files: list { path: String, content: String }) {
        Map ResolvedTypes to TypeScript types.
        Emit type definitions for action inputs/outputs.
        Emit handler interface with one method per action.
        Emit transport adapter (invocation dispatch, serialization).
        Emit lite query protocol implementation over ConceptStorage.
        Emit conformance tests from invariants.
      }
      -> error(message: String) {
        If the manifest contains types not mappable to TypeScript.
      }
    }

    action register() {
      -> ok(name: String, inputKind: String, outputKind: String, capabilities: list String) {
        Return static metadata for PluginRegistry.
        name: "TypeScriptGen"
        inputKind: "ConceptManifest"
        outputKind: "TypeScriptSource"
        capabilities: ["types", "handler", "adapter", "conformance-tests"]
      }
    }
  }

  invariant {
    after generate(spec: "s1", manifest: {
      name: "Ping", uri: "urn:copf/Ping", typeParams: [], relations: [],
      actions: [{ name: "ping", params: [],
        variants: [{ tag: "ok", fields: [], prose: "Pong." }] }],
      invariants: [], graphqlSchema: "",
      jsonSchemas: { invocations: {}, completions: {} },
      capabilities: [], purpose: "A test."
    }) -> ok(files: f)
    then generate(spec: "s2", manifest: { name: "" }) -> error(message: e)
  }
}
