concept SyncEngine [F] {

  purpose {
    Evaluate synchronizations by matching completions,
    querying state, and producing invocations.
    Supports annotation-aware routing: eager syncs evaluate
    immediately, eventual syncs queue when targets are
    unavailable, local syncs execute on same runtime only.
  }

  state {
    syncs: set SyncRegistration
    pendingFlows: set F
    pendingQueue: list PendingSyncEntry
    conflicts: list ActionCompletion
  }

  actions {
    action registerSync(sync: CompiledSync) {
      -> ok() {
        Register a compiled synchronization for evaluation.
        Index it by concept/action pairs in its when clause.
      }
    }

    action onCompletion(completion: ActionCompletion) {
      -> ok(invocations: list ActionInvocation) {
        Receive a completion, find all syncs that should fire,
        evaluate their where clauses, and produce invocations.
        Annotation-aware routing:
          [eager]    — evaluate immediately (default)
          [eventual] — queue if target unavailable, retry later
          [local]    — execute on same runtime only
      }
    }

    action evaluateWhere(bindings: Bindings, queries: list QueryPlan) {
      -> ok(results: list Bindings) {
        Evaluate a where clause against concept state,
        producing expanded variable bindings.
      }
      -> error(message: String) {
        If a referenced concept is unavailable or a query
        fails, return an error description.
      }
    }

    action queueSync(sync: CompiledSync, bindings: Bindings, flow: String) {
      -> ok(pendingId: String) {
        Queue an [eventual] sync for later execution when the
        target concept becomes available. Store bindings and
        flow context.
      }
    }

    action onAvailabilityChange(conceptUri: String, available: Bool) {
      -> ok(drained: list ActionInvocation) {
        When a concept comes online, re-evaluate all pending
        syncs that reference it. Return produced invocations
        for dispatch.
      }
    }

    action drainConflicts() {
      -> ok(conflicts: list ActionCompletion) {
        Return all conflict completions accumulated during
        eventual sync replay, for downstream handling via
        conflict resolution syncs.
      }
    }
  }

  invariant {
    after registerSync(sync: {
      name: "TestSync", annotations: ["eager"],
      when: [{ concept: "urn:clef/Test", action: "act", inputFields: [], outputFields: [] }],
      where: [],
      then: [{ concept: "urn:clef/Other", action: "do", fields: [] }]
    }) -> ok()
    then onCompletion(completion: {
      id: "c1", concept: "urn:clef/Test", action: "act",
      input: {}, variant: "ok", output: {}, flow: "f1",
      timestamp: "2024-01-01T00:00:00Z"
    }) -> ok(invocations: inv)
  }
}
