concept SchemaGen [S] {

  purpose {
    Transform parsed concept ASTs into rich, language-neutral
    ConceptManifests. The manifest contains everything a code
    generator needs: relation schemas (after merge/grouping),
    fully typed action signatures, structured invariants with
    test values, GraphQL schema fragments, and JSON Schemas.
  }

  state {
    manifests: S -> ConceptManifest
  }

  actions {
    action generate(spec: S, ast: AST) {
      -> ok(manifest: ConceptManifest) {
        Apply state grouping/merge rules to produce relation schemas.
        Resolve all types into ResolvedType trees.
        Transform invariants into structured test scenarios with
        deterministic test IDs for free variables.
        Generate GraphQL schema fragment from relation schemas.
        Generate JSON Schemas for each action invocation/completion.
        Package everything into a ConceptManifest.
      }
      -> error(message: String) {
        If the AST contains unresolvable types or inconsistencies.
      }
    }
  }

  invariant {
    after generate(spec: "s1", ast: {
      name: "Ping", typeParams: ["T"], purpose: "A test.",
      state: [], actions: [{
        name: "ping", params: [],
        variants: [{ name: "ok", params: [], description: "Pong." }]
      }], invariants: [], capabilities: []
    }) -> ok(manifest: m)
    then generate(spec: "s2", ast: { name: "" }) -> error(message: e)
  }
}
