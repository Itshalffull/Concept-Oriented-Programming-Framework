concept SolidityGen [S] {

  purpose {
    Generate Solidity contract skeletons from a ConceptManifest.
    Produces contract definitions, event declarations, and Foundry
    test harnesses. Invariants become require statements.
    Handles Solidity constraints: no generics, fixed-size types.
  }

  state {
    outputs: S -> list { path: String, content: String }
  }

  actions {
    action generate(spec: S, manifest: ConceptManifest) {
      -> ok(files: list { path: String, content: String }) {
        Map ResolvedTypes to Solidity types (string, int256, uint256, bool, bytes, etc.).
        Emit contract skeleton with storage variables from concept state.
        Emit function signatures from actions with return structs for variants.
        Emit event declarations for each action completion.
        Emit Foundry test harness with require statements from invariants.
      }
      -> error(message: String) {
        If the manifest contains types not mappable to Solidity.
      }
    }

    action register() {
      -> ok(name: String, inputKind: String, outputKind: String, capabilities: list String) {
        Return static metadata for PluginRegistry.
        name: "SolidityGen"
        inputKind: "ConceptManifest"
        outputKind: "SoliditySource"
        capabilities: ["contract", "events", "foundry-tests"]
      }
    }
  }

  invariant {
    after generate(spec: "s1", manifest: {
      name: "Ping", uri: "urn:copf/Ping", typeParams: [], relations: [],
      actions: [{ name: "ping", params: [],
        variants: [{ tag: "ok", fields: [], prose: "Pong." }] }],
      invariants: [], graphqlSchema: "",
      jsonSchemas: { invocations: {}, completions: {} },
      capabilities: [], purpose: "A test."
    }) -> ok(files: f)
    then generate(spec: "s2", manifest: { name: "" }) -> error(message: e)
  }
}
