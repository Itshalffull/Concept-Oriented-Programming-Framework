// Auto-generated by COPF Interface Kit â€” cli target
// Concept: ContractTest
// Do not edit manually; regenerate with: copf interface generate

import { Command } from 'commander';

export const contractTestCommand = new Command('contract-test')
  .description('Verify cross target interoperability for concepts that 
 generate code in multiple languages Maintain contract 
 definitions derived from concept specs Track which 
 producer consumer pairs have been verified Gate deployment 
 on contract verification passing');

contractTestCommand
  .command('generate')
  .description('Generate a contract definition from the concept spec 
 The contract captures the wire level interface : action 
 signatures , input output schemas , and expected variants 
 Language independent the same contract applies to 
 every target implementation')
  .requiredOption('--concept <concept>', 'Concept')
  .requiredOption('--spec-path <specPath>', 'Spec Path')
  .option('--json', 'Output as JSON')
  .action(async (opts) => {
    const result = await globalThis.kernel.handleRequest({ method: 'generate', ...opts });
    console.log(opts.json ? JSON.stringify(result) : result);
  });

contractTestCommand
  .command('verify')
  .description('Run contract verification : the consumer sends requests 
 to the producer and checks that responses match the 
 contract definition Tests serialization round trips , 
 variant handling , error propagation , and edge cases')
  .requiredOption('--contract <contract>', 'Contract')
  .requiredOption('--producer-artifact <producerArtifact>', 'Producer Artifact')
  .requiredOption('--producer-language <producerLanguage>', 'Producer Language')
  .requiredOption('--consumer-artifact <consumerArtifact>', 'Consumer Artifact')
  .requiredOption('--consumer-language <consumerLanguage>', 'Consumer Language')
  .option('--json', 'Output as JSON')
  .action(async (opts) => {
    const result = await globalThis.kernel.handleRequest({ method: 'verify', ...opts });
    console.log(opts.json ? JSON.stringify(result) : result);
  });

contractTestCommand
  .command('matrix')
  .description('Return cross target verification matrix 
 Shows which language pairs have been verified 
 for which concepts')
  .requiredOption('--concepts <concepts>', 'Concepts')
  .option('--json', 'Output as JSON')
  .action(async (opts) => {
    const result = await globalThis.kernel.handleRequest({ method: 'matrix', ...opts });
    console.log(opts.json ? JSON.stringify(result) : result);
  });

contractTestCommand
  .command('can-deploy')
  .description('Check if deploying this concept in this language is 
 safe all contract pairs involving this language have 
 been verified for the current spec version')
  .requiredOption('--concept <concept>', 'Concept')
  .requiredOption('--language <language>', 'Language')
  .option('--json', 'Output as JSON')
  .action(async (opts) => {
    const result = await globalThis.kernel.handleRequest({ method: 'canDeploy', ...opts });
    console.log(opts.json ? JSON.stringify(result) : result);
  });

export const contractTestCommandTree = {
  group: 'contract-test',
  description: 'Verify cross target interoperability for concepts that 
 generate code in multiple languages Maintain contract 
 definitions derived from concept specs Track which 
 producer consumer pairs have been verified Gate deployment 
 on contract verification passing',
  commands: [{ action: 'generate', command: 'generate' }, { action: 'verify', command: 'verify' }, { action: 'matrix', command: 'matrix' }, { action: 'canDeploy', command: 'can-deploy' }],
};
